class AVLNode[`k,`v](key: `k,
                     value: `v,
                     parent: AVLNode[`k,`v],
                     left: AVLNode[`k,`v],
                     right: AVLNode[`k,`v],
                     height: int):
   def __init__(self: AVLNode[`k,`v], parent: AVLNode[`k,`v], k: `k, v: `v):
      self.key = k
      self.value = v
      self.parent = parent
      self.left = None
      self.right = None
      self.height = -1

   def find(self, k) -> AVLNode[`k,`v]:
      if k == self.key:
         return self
      elif k < self.key:
         if self.left is None:
            return None
         else:
            return self.left.find(k)
      else:
         if self.right is None:
            return None
         else:
            return self.right.find(k)

   def find_min(self):
      current = self
      while current.left is not None:
         current = current.left
      return current

   def next_larger(self):
      if self.right is not None:
         return self.right.find_min()
      current = self
      while current.parent is not None and current is current.parent.right:
         current = current.parent
      return current.parent

   def insert(self, node):
      if node is None:
         return
      if node.key < self.key:
         if self.left is None:
            node.parent = self
            self.left = node
         else:
            self.left.insert(node)
      else:
         if self.right is None:
            node.parent = self
            self.right = node
         else:
            self.right.insert(node)

   def delete(self):
      if self.left is None or self.right is None:
         if self is self.parent.left:
            self.parent.left = self.left or self.right
            if self.parent.left is not None:
               self.parent.left.parent = self.parent
         else:
            self.parent.right = self.left or self.right
            if self.parent.right is not None:
               self.parent.right.parent = self.parent
         return self
      else:
         s = self.next_larger()
         self.key, s.key = s.key, self.key
         return s.delete()

   def __iter__(self: AVLNode[`k,`v]) -> AVLNode[`k,`v]:
      if self.left:
         for i in self.left:
            yield i
      yield self
      if self.right:
         for i in self.right:
            yield i

def max(x, y):
   return x if x > y else y

def height(node):
   if node is None:
      return -1
   else:
      return node.height

def update_height(node):
   node.height = max(height(node.left), height(node.right)) + 1

extern c exit(code: int) -> void

class AVL[`k,`v](root: AVLNode[`k,`v]):
   def __init__(self: AVL[`k,`v]):
      self.root = None

   def find(self, k) -> AVLNode[`k,`v]:
      if not self.root:
         return None
      return self.root.find(k)

   def find_min(self) -> AVLNode[`k,`v]:
      if not self.root:
         return None
      return self.root.find_min()

   def next_larger(self, k):
      node = self.find(k)
      return node.next_larger() if node else None

   def left_rotate(self, x):
      y = x.right
      y.parent = x.parent
      if y.parent is None:
         self.root = y
      else:
         if y.parent.left is x:
            y.parent.left = y
         elif y.parent.right is x:
            y.parent.right = y
      x.right = y.left
      if x.right is not None:
         x.right.parent = x
      y.left = x
      x.parent = y
      update_height(x)
      update_height(y)

   def right_rotate(self, x):
      y = x.left
      y.parent = x.parent
      if y.parent is None:
         self.root = y
      else:
         if y.parent.left is x:
            y.parent.left = y
         elif y.parent.right is x:
            y.parent.right = y
      x.left = y.right
      if x.left is not None:
         x.left.parent = x
      y.right = x
      x.parent = y
      update_height(x)
      update_height(y)

   def rebalance(self, node):
      while node is not None:
         update_height(node)
         if height(node.left) >= 2 + height(node.right):
            if height(node.left.left) >= height(node.left.right):
               self.right_rotate(node)
            else:
               self.left_rotate(node.left)
               self.right_rotate(node)
         elif height(node.right) >= 2 + height(node.left):
            if height(node.right.right) >= height(node.right.left):
               self.left_rotate(node)
            else:
               self.right_rotate(node.right)
               self.left_rotate(node)
         node = node.parent

   def insert(self, k, v):
      node = AVLNode[`k,`v](None, k, v)
      if self.root is None:
         # The root's parent is None.
         self.root = node
      else:
         self.root.insert(node)
      self.rebalance(node)

   def delete(self, k) -> AVLNode[`k,`v]:
      node = self.find(k)
      if node is None:
         return None
      deleted = None
      if node is self.root:
         pseudoroot = AVLNode[`k,`v](None, 0)
         pseudoroot.left = self.root
         self.root.parent = pseudoroot
         deleted = self.root.delete()
         self.root = pseudoroot.left
         if self.root is not None:
            self.root.parent = None
      else:
         deleted = node.delete()
      self.rebalance(deleted.parent)

   def __setitem__(self: AVL[`k,`v], k: `k, v: `v):
      self.insert(k, v)

   def __getitem__(self: AVL[`k,`v], k: `k):
      nd = self.find(k)
      if not nd:
         print 'whoops', k, 'not found'
         exit(1)
      return nd.value

   def __iter__(self: AVL[`k,`v]):
      if self.root:
         for i in self.root:
            yield i.key, i.value

tree = AVL[int, str]()
tree[3] = "hai3"
tree[5] = "hai5"
tree[1] = "hai1"

print tree[1]
print tree.find(1).value

#print (4 in tree)  # overload __contains__ for this

ei = {
   1: "ow",
   2: "he", 3: "mmm"
}
print ei.get(1, "---")
print ei.get(5, "---")
print (3 in ei)

for i in ei: print i

del ei[2]
for i in ei: print i

for y in tree:
   print y[0], y[1]

# for item in items:
#    tree.insert(item)
#    print()
#    print(tree)

