class Pair[T](a: T, b: T) {
  def sum[S](self: Pair[T], c: S) {
    return self.a + self.b + c
  }

  def dump(self: Pair[T]) {
    print self.a
    print self.b
  }

  def swap(self: Pair[T]) {
    var tmp = self.a
    self.a = self.b
    self.b = tmp
  }

  def iter(self: Pair[T]) {
    yield self.a
    yield self.b
    return
  }


# everything below is really in a giant generic
# function to test cloning capabilities; this can
# safely be ignored when reading the code though
def main[Z](args: Str[]) {
# ---------


def range(a: Int, b: Int) {
  var i = a
  while i < b {
    yield i
    i = i + 1
  }
}

def split(s: Seq, k: Int, step: Int) {
  var i = 0
  while i+k <= s.len {
    yield s[i:i+k]
    i = i + step
  }
}

def enum(s: Seq[]) {
  var i = 0
  for j in range(0, s.len) {
    yield (i, s[j])
    i = i + 1
  }
}

def f(s: Seq) {
  var v = Seq[s.len/32]
  var i = 0
  for t in split(s, 32, 32) {
    v[i] = t
    i = i + 1
  }
  return v
}

var farray = (Seq -> Seq[])[1]
farray[0] = f

def ident(s: Seq) {
  return s
}

source args[0] as input {

  var v = farray[0](input)
  for r in enum(v) {
    print r.1
    print r.2
  }
  print input

  var arr = {Int, Seq}[10]

  print ident(input)

  match input {
    case (q @ `A...`) if q.len > 150: print "match: A"
    case `C...`: print "match: C"
    case `G...`: "match: G"
    case `_...`: "match: _..."
    case _: print "match: _"
  }

  for v1 in split(input, 64, 64) {
    print v1
    for v2 in split(v1, 32, 32) {
      for v3 in split(v2, 16, 16) {
        print v3
      }
      print v2
    }
    print v1
  }
  print ident(input)

  print (v[1], ((v)[2]), (v[1], 4.2)).3.1
}

def hello:
  return "hello world"


def hello2:
  print "hello again"

print hello()
hello2()
print 42 + 2.2
print -13
var x = 4.2
print x
x = .42
print -x if x < 1 else +x
var b = (true, !true)
print b.1
b = (b.1, !!false)
print b.2

def fib(n: Int) {
  type F = {f: (Int -> Int), x: Int}

  def apply(f: (Int -> Int), x: Int): return f(x)

  def rec(pair: F):
    return apply(pair.f, pair.x - 1) + apply(pair.f, pair.x - 2)

  return n if n <= 1 else rec((fib, n))
}

print fib(10)

for i in range(1 if b.1 else 2, 5+5) {
  if i == 3:
    continue
  elif i >= 7:
    break
  else:
    for _ in range(i, i+1): print _
}

type Person = {name: Str, age: Int}

def whois(person: Person) {
  print person.name
  print person.age
}

def birthday(person: Person):
  return Person(person.name, person.age + 1)

var joe = (name: "Joe", age: 42)
whois(joe)
joe = birthday(joe)
whois(joe)

global ints = Int[100]
for i in range(0, ints.len):
  ints[i] = i+1
global s = 0
for _ in range(0, ints.len): s = s + ints[_]
print s

var p = Pair[Int](42, 19)
print p.sum(100.1)  # 42 + 19 + 100 = 161
print p.sum(100)
p.dump()  # 42,19
p.swap()
for a in p.iter(): print a  # 19,42

var q = Pair[Float](4.2, 1.9)
print q.sum(10.0)
for a in q.iter(): print a
q.swap()
Pair[Float].dump(q)

def print_coord(t: {Int, Int, Str}) {
  # this syntax is based largely on Rust's
  match t {
    case (x, y, _) if x == y && x < 5: print "EQUAL"
    case (x @ (0 | 1), y @ 0...1, a @ "a") { print a ; print x ; print y }
    case (x, 0, "b"): print x
    case (0, y, "b"): print y
    case (x, y, "b") { print x ; print y }
    case (x, y, z) {}
  }
}

print_coord((0, 1, "a"))
print "---"
print_coord((13, 0, "b"))
print "---"
print_coord((11, 22, "b"))

var aa = Int?[3]  # array of optional ints
aa[0] = 1?
aa[1] = 2?
aa[2] = 3?

var bb = Int?[][1]
bb[0] = aa

var cc = match bb {
           case [[1?, 2?, ...]]: "one"[0:3]
           case [[2?, ..., 3?]]: "two"
           case []: "three"
           case _: ""
         }

print cc


# ---------
}
}

# run the above twice, and test cloning:
Pair[Str].main[Float](args)
Pair[Seq].main[Int](args)
