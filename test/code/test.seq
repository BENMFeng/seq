# this is a comment

gen split(s: Seq, k: Int, step: Int) -> Seq {
  var i = 0
  while i+k <= s.len {
    yield s[i:i+k]
    i = i + step
  }
}

fun f(s: Seq) -> Seq[]:
  s |> split 32 32 |> collect

let farray = (Seq -> Seq[])[1]
farray[0] = f

fun ident(s: Seq) -> Seq {
  s
}

source args[0] as input {
  input |> substr 0+1 5 {
    _ |> print
    _ |> revcomp |> print
  }

  let v = farray[0](input)
  v |> foreach as r |> (|> count, r, r |> split 1 1) as t {
    t.1 |> print
    _ |> .2 |> print
    t.3 |> print
    continue
  }
  input |> print

  let arr = {Int, Seq}[10]
  arr |> foreach

  input |> ident |> print

  match input {
    case (q @ `A...`) if q.len > 150: "match: A" |> print
    case `C...`: "match: C" |> print
    case `G...`: "match: G" |> print
    case `_...`: "match: _..." |> print
    case _: "match: _" |> print
  }

  for t in split(input, 64, 64) {
    let v1 = t |> print
    v1 |> split 32 32 {
      let v2 = _ |> print
      _ |> split 16 16 {
        _ |> print
        let v3 = _ |> copy |> print
        let v4 = v3 |> print
        v3 |> print
      }
      v2 |> print
    }
    t |> print
  }
  ident(input) |> print

  (v[1], ((v)[2]), (v[1], 4.2)).3 |> .1 |> print
}

fun hello -> Str:
  return "hello world"


fun hello2:
  "hello again" |> print

hello() |> print
hello2()
42 + 2.2 |> print
-13 |> print
var x = 4.2
x |> print
x = .42
if x < 1 then -x else +x |> print
var b = (true, !true)
b.1 |> print
b = (b.1, !!false)
b.2 |> print

fun fib(n: Int) -> Int {
  type F = {f: (Int -> Int), x: Int}

  fun apply(f: (Int -> Int), x: Int) -> Int: f(x)

  fun rec(pair: F) -> Int:
    apply(pair.f, pair.x - 1) + apply(pair.f, pair.x - 2)

  if n <= 1 then n else rec((fib, n))
}

10 |> fib |> print
fib(10) |> print

range (if b.1 then 1 else 2) 5+5 as i {
  if i == 3:
    continue
  elif i >= 7:
    break
  else:
    range i i+1: _ |> print
}

type Person = {name: Str, age: Int}

fun whois(person: Person) {
  person.name |> print
  person.age  |> print
}

fun birthday(person: Person) -> Person:
  (person.name, person.age + 1)


var joe = (name: "Joe", age: 42)
whois(joe)
joe = birthday(joe)
whois(joe)

let ints = Int[100]
range ints.len as i:
  ints[i] = i+1
var s = 0
ints |> foreach as n: s = s + n
s |> print

class Pair[T](a: T, b: T) {
  fun sum(self: Pair[T], c: T) -> T {
    self.a + self.b + c
  }

  fun print(self: Pair[T]) {
    self.a |> print
    self.b |> print
  }

  fun swap(self: Pair[T]) {
    let tmp = self.a
    self.a = self.b
    self.b = tmp
  }

  gen iter(self: Pair[T]) -> T {
    yield self.a
    yield self.b
  }
}

let p = Pair[Int](42, 19)
p.sum(100) |> print  # 42 + 19 + 100 = 161
p.print()  # 42,19
p.swap()
for a in p.iter(): a |> print  # 19,42

let q = Pair[Float](4.2, 1.9)
q.sum(10.0) |> print
for a in q.iter(): a |> print
q.swap()
Pair[Float].print(q)

fun print_coord(t: {Int, Int, Str}) {
  # this syntax is based largely on Rust's
  match t {
    case (x, y, _) if x == y && x < 5: "EQUAL" |> print
    case (x @ (0 | 1), y @ 0...1, a @ "a") { a |> print ; x |> print ; y |> print }
    case (x, 0, "b"): x |> print
    case (0, y, "b"): y |> print
    case (x, y, "b") { x |> print ; y |> print }
    case (x, y, z) {}
  }
}

print_coord((0, 1, "a"))
"---" |> print
print_coord((13, 0, "b"))
"---" |> print
print_coord((11, 22, "b"))

let aa = Int?[3]  # array of optional ints
aa[0] = 1?
aa[1] = 2?
aa[2] = 3?

let bb = Int?[][1]
bb[0] = aa

let cc = match bb {
           case [[1?, 2?, ...]]: "one"[0:3]
           case [[2?, ..., 3?]]: "two"
           case []: "three"
           case _: ""
         }

cc |> print
