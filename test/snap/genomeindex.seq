# Implementation of SNAP aligner's genome index
# https://github.com/amplab/snap/blob/master/SNAPLib/GenomeIndex.{cpp,h}

# Need the following hooks linked to convert C++ GenomeIndex to Seq object:
# snap_index_from_dir(ptr[byte]) -> ptr[byte]     --  read object from specified directory
# snap_index_ht_count(ptr[byte]) -> int           --  extract hash table count
# snap_index_ht_get(ptr[byte], int) -> ptr[byte]  --  extract specified (0-indexed) hash table
# snap_index_overflow_ptr(ptr[byte]) -> ptr[u32]  --  extract overflow table pointer
# snap_index_overflow_len(ptr[byte]) -> int       --  extract overflow table length
# snap_index_count_of_bases(ptr[byte]) -> int     --  extract count of genome bases

from hashtable import SNAPHashTable

class GenomeIndex[`k]:
    hash_tables: array[SNAPHashTable[k16,u32]]
    overflow_table: array[u32]
    count_of_bases: int

    def _partition(k: `k):
        n = int(k.as_int())
        return (k16(n & ((1 << 32) - 1)), n >> 32)

    def __init__(self: GenomeIndex[`k], dir: str):
        assert k16.len() <= `k.len() <= k32.len()
        extern c snap_index_from_dir(ptr[byte]) -> ptr[byte]
        extern c snap_index_ht_count(ptr[byte]) -> int
        extern c snap_index_ht_get(ptr[byte], int) -> ptr[byte]
        extern c snap_index_overflow_ptr(ptr[byte]) -> ptr[u32]
        extern c snap_index_overflow_len(ptr[byte]) -> int
        extern c snap_index_count_of_bases(ptr[byte]) -> int

        p = snap_index_from_dir(dir.c_str())
        hash_tables = array[SNAPHashTable[k16,u32]](snap_index_ht_count(p))
        for i in range(len(hash_tables)):
            hash_tables[i] = SNAPHashTable[k16,u32](snap_index_ht_get(p, i))

        self.hash_tables = hash_tables
        self.overflow_table = array[u32](snap_index_overflow_ptr(p), snap_index_overflow_len(p))
        self.count_of_bases = snap_index_count_of_bases(p)

    def lookup(self: GenomeIndex[`k], seed: `k, hits: ptr[ptr[u32]], rc_hits: ptr[ptr[u32]]):
        FWD, REV = 0, 1
        n_hits, n_rc_hits = 0, 0

        for dir in (FWD, REV):
            kmer, which = GenomeIndex[`k]._partition(seed)
            table = self.hash_tables[which]
            v = table.get_value_for_key(kmer)
            if v != table.invalid_val:
                if dir == FWD:
                    n_hits = self._fill_in_lookup_results(v, hits)
                else:
                    n_rc_hits = self._fill_in_lookup_results(v, rc_hits)
            seed = ~seed  # rev comp

        return (n_hits, n_rc_hits)

    def _fill_in_lookup_results(self: GenomeIndex[`k], value: u32, hits: ptr[ptr[u32]]):
        if int(value) < self.count_of_bases:
            hits[0][0] = value
            return 1
        else:
            overflow_table_offset = int(value) - self.count_of_bases
            hit_count = int(self.overflow_table[overflow_table_offset])
            hits[0] = self.overflow_table.ptr + overflow_table_offset + 1
            return hit_count
