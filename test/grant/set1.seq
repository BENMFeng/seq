# 786

# benchmarks:
# - reverse complementing 10g FASTA
# - printing all 16-mers from 10g FASTA
# - count number of CpG islands (e.g. all CG-only subseqs)

import seqlib

def split(s, k, step):
   i = 0
   while i + k < len(s):
      yield s[i:i + k]
      i += step

def is_cpg(s):
   return s == s'C' or s == s'G'

def cpg(s):
   i = 0
   while i < len(s):
      if is_cpg(s[i]):
         j = i + 1
         while j < len(s) and is_cpg(s[j]):
            j += 1
         yield s[i:j]
         i = j + 1
      else: i += 1

def cpg_count(s):
   count = 0
   for cp in cpg(s):
      count += 1
   return count

def revcomp(c):
   return (s'A' if c == s'T' else \
          (s'C' if c == s'G' else \
          (s'G' if c == s'C' else \
          (s'T' if c == s'A' else c))))

def rc_copy(s):
   cp = s
   for i in range(len(s)):
      print i, s[i], '<->', revcomp(s[i]), len(s) - i - 1, s[len(s) - i - 1], revcomp(s[len(s) - i - 1])
      cp[i] = revcomp(s[len(s) - i - 1])
   print s
   print cp
   return cp

print rc_copy(s'ACGTACGTACGTACGTACGTACGT')

# will need timing constructs
f = file(__argv__[2])
match __argv__[3]:
   case '1': print '>> 1'; iter(f) |> rc_copy
#    case '2': print '>> 2'; iter(f) |> split(16, 1) |> echo
#    case '3':
#       print '>> 3'
#       total = 0
#       for line in iter(f):
#          total += cpg_count(line)
#       # gen = iter(f) |> cpg_count  not working
#       print total
   default: print 'whoops!'