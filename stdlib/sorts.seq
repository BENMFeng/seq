### Constants ###
INSERTION_SORT_THRESHOLD = 24
NINTHER_THRESHOLD = 128
PARTIAL_INSERTION_SORT_LIMIT = 8
BLOCK_SIZE = 64
CACHELINE_SIZE = 64

### Helpers ###

def _floor_log2(n: int) -> int:
    """
        Returns floor(log2(n))
    """
    cdef floor(float) -> float
    cdef log2(float) -> float
    return int(floor(log2(float(n))))

def _heapify[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    """
        Makes the array a heap from [begin, end).
    """
    root = begin
    left = 2 * begin + 1
    right = 2 * begin + 2

    if left < end and comp(arr[root], arr[left]):
        root = left

    if right < end and comp(arr[root], arr[right]):
        root = right
    
    if root != begin:
        arr[begin], arr[root] = arr[root], arr[begin]
        _heapify(arr, root, end, comp)

def _partial_insertion_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> bool:
    if begin == end:
        return True
    
    limit = 0
    cur = begin + 1
    while cur != end:
        if limit > PARTIAL_INSERTION_SORT_LIMIT:
            return False
        
        sift = cur
        sift_1 = cur -1

        if comp(arr[sift], arr[sift_1]):
            tmp = arr[sift]

            while True:
                arr[sift] = arr[sift_1]
                sift -= 1
                sift_1 -= 1
                if sift == begin or not comp(tmp, arr[sift_1]):
                    break
            
            arr[sift] = tmp
            limit += cur - sift
        
        cur += 1
    
    return True


def _partition_left[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> int:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        last -= 1
        if not comp(pivot, arr[last]):
            break
    
    if (last + 1 == end):
        while first < last:
            first += 1
            if comp(pivot, arr[first]):
                break
    
    else:
        while True:
            first += 1
            if comp(pivot, arr[first]):
                break
    
    while first < last:
        arr[first], arr[last] = arr[last], arr[first]
        while True:
            last -= 1
            if not comp(pivot, arr[last]):
                break
        while True:
            first += 1
            if comp(pivot, arr[first]):
                break
    
    pivot_pos = last
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return pivot_pos

def _partition_right[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> tuple[int,int]:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        first += 1
        if not comp(arr[first], pivot):
            break
    
    if first - 1 == begin:
        while first < last:
            last -= 1
            if comp(arr[last], pivot):
                break
    
    else:
        while True:
            last -= 1
            if comp(arr[last], pivot):
                break
    
    already_partitioned = 0
    if first >= last:
        already_partitioned = 1
    
    while first < last:
        arr[first], arr[last] = arr[last], arr[first]
        
        while True:
            first += 1
            if not comp(arr[first], pivot):
                break
        
        while True:
            last -= 1
            if comp(arr[last], pivot):
                break
    
    pivot_pos = first - 1
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return (pivot_pos, already_partitioned)

def _sort2[T](arr: array[T], i: int, j: int, comp: function[bool,T,T]):
    if comp(arr[j], arr[i]):
        arr[i], arr[j] = arr[j], arr[i]

def _sort3[T](arr: array[T], i: int, j: int, k: int, comp: function[bool,T,T]):
    _sort2(arr, i, j, comp)
    _sort2(arr, j, k, comp)
    _sort2(arr, i, j, comp)

def _merge[T](arr: array[T], l: int, m: int, r: int, comp: function[bool,T,T]):
    len1, len2 = m - l, r - m
    left, right = list[T](), list[T]()
    for i in range(len1):
        left.append(arr[l + i])
    for i in range(len2):
        right.append(arr[m + i])
    

    i, j, k = 0, 0, l

    while i < len1 and j < len2:
        if comp(left[i], right[j]):
            arr[k] = left[i]
            i += 1
        else:
            arr[k] = right[j]
            j += 1
        k += 1
    while i < len1:
        arr[k] = left[i]
        k += 1
        i += 1
    while j < len2:
        arr[k] = right[j]
        k += 1
        j += 1

def _count_run[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> tuple[int,int]:
    """
        Returns the # of elements in the next run and if the run is "inorder" or "reversed"
    """

    inorder = 1

    if end - begin == 1:
        return 1, inorder
    
    n = 2
    i = begin + 1
    if not comp(arr[i - 1], arr[i]):
        inorder = 0
        i += 1
        while i < end:
            if comp(arr[i - 1], arr[i]):
                break
            i += 1
            n += 1
    
    else:
        i += 1
        while i < end:
            if not comp(arr[i - 1], arr[i]):
                break
            i += 1
            n += 1

    return n, inorder

def _merge_compute_minrun(n: int) -> int:
    """
        Computes the minrun for Timsort
    """
    r = 0
    while n >= 64:
        r |= n & 1
        n >>=1
    return n + r

def _reverse_sortslice[T](arr: array[T], begin: int, end: int):
    if end - begin < 2:
        return
    arr[begin], arr[end - 1] = arr[end - 1], arr[begin]
    _reverse_sortslice(arr, begin + 1, end - 1)



def _merge_collapse[T](arr: array[T], stack: list[tuple[int,int]], comp: function[bool,T,T]):
    
    while len(stack) > 2:
        X = stack.pop()
        Y = stack.pop()
        Z = stack.pop()
        if Y[1] > X[1] and Z[1] > Y[1] + X[1]:
            break
        if Z[1] < X[1]:
            _merge(arr, Z[0], Y[0], Y[0] + Y[1], comp)
            stack.append((Z[0], Z[1] + Y[1]))
            stack.append(X)
        else:
            _merge(arr, Y[0], X[0], X[0] + X[1], comp)
            stack.append(Z)
            stack.append((Y[0], Y[1] + X[1]))
        

def _final_merge[T](arr: array[T], stack: list[tuple[int,int]], comp: function[bool,T,T]):
    
    while len(stack) > 1:
        X = stack.pop()
        Y = stack.pop()
        _merge(arr, Y[0], X[0], X[0] + X[1], comp)
        stack.append((Y[0], Y[1] + X[1]))

### Private Sorts ###

def _insertion_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    i = begin + 1
    while i < end:
        x = arr[i]
        j = i - 1
        while j >= begin and comp(x, arr[j]):
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = x
        i += 1

def _heap_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    if end - begin < 2:
        return
    
    for i in range(end, begin - 1, -1):
        _heapify(arr, i, end, comp)
    
    for i in range(end -1, begin, -1):
        arr[i], arr[begin] = arr[begin], arr[i]
        _heapify(arr, begin, i, comp)

def _pdq_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T], bad_allowed: int, leftmost: bool):
    while True:
        size = end - begin
        if size < INSERTION_SORT_THRESHOLD:
            _insertion_sort(arr, begin, end, comp)
            return
        
        size_2 = int(size / 2)
        if size > NINTHER_THRESHOLD:
            _sort3(arr, begin, begin + size_2, end - 1, comp)
            _sort3(arr, begin + 1, begin + (size_2 - 1), end - 2, comp)
            _sort3(arr, begin + 2, begin + (size_2 + 1), end - 3, comp)
            _sort3(arr, begin + (size_2 - 1), begin + size_2, begin + (size_2 + 1), comp)
            arr[begin], arr[begin + size_2] = arr[begin + size_2], arr[begin]
        else:
            _sort3(arr, begin + size_2, begin, end - 1, comp)
        
        if not leftmost and not comp(arr[begin - 1], arr[begin]):
            begin = _partition_left(arr, begin, end, comp) + 1
            continue

        part_result = _partition_right(arr, begin, end, comp)
        pivot_pos = part_result[0]
        already_partitioned = part_result[1] == 1

        l_size = pivot_pos - begin
        r_size = end - (pivot_pos + 1)
        hightly_unbalanced = (l_size < (size / 8)) or (r_size < (size / 8))

        if hightly_unbalanced:
            bad_allowed -= 1
            if bad_allowed == 0:
                _heap_sort(arr, begin, end, comp)
                return
            
            if l_size >= INSERTION_SORT_THRESHOLD:
                arr[begin], arr[int(begin + l_size / 4)] = arr[int(begin + l_size / 4)], arr[begin]
                arr[pivot_pos - 1], arr[int(pivot_pos - l_size / 4)] = arr[int(pivot_pos - l_size / 4)], arr[pivot_pos - 1]

                if l_size > NINTHER_THRESHOLD:
                    arr[begin + 1], arr[int(begin + (l_size / 4 + 1))] = arr[int(begin + (l_size / 4 + 1))], arr[begin + 1]
                    arr[begin + 2], arr[int(begin + (l_size / 4 + 2))] = arr[int(begin + (l_size / 4 + 2))], arr[begin + 2]
                    arr[pivot_pos - 2], arr[int(pivot_pos - (l_size / 4 + 1))] = arr[int(pivot_pos - (l_size / 4 + 1))], arr[pivot_pos - 2]
                    arr[pivot_pos - 3], arr[int(pivot_pos - (l_size / 4 + 2))] = arr[int(pivot_pos - (l_size / 4 + 2))], arr[pivot_pos - 3]

            if r_size >= INSERTION_SORT_THRESHOLD:
                arr[pivot_pos + 1], arr[int(pivot_pos + (1 + r_size / 4))] = arr[int(pivot_pos + (1 + r_size / 4))], arr[pivot_pos + 1]
                arr[end - 1], arr[int(end - r_size / 4)] = arr[int(end - r_size / 4)], arr[end - 1]

                if r_size > NINTHER_THRESHOLD:
                    arr[pivot_pos + 2], arr[int(pivot_pos + (2 + r_size / 4))] = arr[int(pivot_pos + (2 + r_size / 4))], arr[pivot_pos + 2]
                    arr[pivot_pos + 3], arr[int(pivot_pos + (3 + r_size / 4))] = arr[int(pivot_pos + (3 + r_size / 4))], arr[pivot_pos + 3]
                    arr[end - 2], arr[int(end - (1 + r_size / 4))] = arr[int(end - (1 + r_size / 4))], arr[end - 2]
                    arr[end - 3], arr[int(end - (2 + r_size / 4))] = arr[int(end - (2 + r_size / 4))], arr[end - 3]

        else:
            if (already_partitioned and _partial_insertion_sort(arr, begin, pivot_pos, comp) and _partial_insertion_sort(arr, pivot_pos + 1, end, comp)):
                return
        
        _pdq_sort(arr, begin, pivot_pos, comp, bad_allowed, leftmost)
        begin = pivot_pos + 1
        leftmost = False

def _tim_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    merge_pending = list[tuple[int,int]]()
    if end - begin < 2:
        return

    minrun = _merge_compute_minrun(end - begin)
    i = begin
    while i < end:
        n, inorder = _count_run(arr, i, end, comp)
        if not inorder:
            _reverse_sortslice(arr, i, i + n)
        if n < minrun:
            force = min(minrun, end)
            _insertion_sort(arr, i, i + force, comp)
            n = force
        merge_pending.append((i, n))
        _merge_collapse(arr, merge_pending, comp)
        i += n

    _final_merge(arr, merge_pending, comp)

### Public Sorts ###

def insertion_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Insertion Sort
        Sorts the array inplace.
    """
    _insertion_sort(collection, 0, size, compare)

def insertion_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Insertion Sort
        Sorts the list inplace.
    """
    insertion_sort_array(collection.arr, collection.len, compare)

def insertion_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Insertion Sort
        Returns the sorted list.
    """
    newlst = copy(collection)
    insertion_sort_inplace(newlst, compare)
    return newlst

def heap_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Heap Sort
        Sorts the array inplace.
    """
    _heap_sort(collection, 0, size, compare)

def heap_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Heap Sort
        Sorts the list inplace.
    """
    heap_sort_array(collection.arr, collection.len, compare)

def heap_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Heap Sort
        Returns a sorted list.
    """
    newlst = copy(collection)
    heap_sort_inplace(newlst, compare)
    return newlst

def pdq_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Pattern-defeating Quicksort
        By Orson Peters, published at https://github.com/orlp/pdqsort

        Sorts the array inplace.
    """
    _pdq_sort(collection, 0, size, compare, _floor_log2(size), True)

def pdq_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Pattern-defeating Quicksort
        By Orson Peters, published at https://github.com/orlp/pdqsort

        Sorts the list inplace.
    """
    pdq_sort_array(collection.arr, collection.len, compare)

def pdq_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Pattern-defeating Quicksort
        By Orson Peters, published at https://github.com/orlp/pdqsort

        Returns a sorted list.
    """
    newlst = copy(collection)
    pdq_sort_inplace(newlst, compare)
    return newlst

def tim_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Timsort
        By Tim Peters, published at https://github.com/python/cpython/blob/master/Objects/listobject.c#L2187

        Sorts the array inplace.
    """
    _tim_sort(collection, 0, size, compare)

def tim_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Timsort
        By Tim Peters, published at https://github.com/python/cpython/blob/master/Objects/listobject.c#L2187

        Sorts the list inplace.
    """
    tim_sort_array(collection.arr, collection.len, compare)

def tim_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Timsort
        By Tim Peters, published at https://github.com/python/cpython/blob/master/Objects/listobject.c#L2187

        Returns a sorted list.
    """
    newlst = copy(collection)
    tim_sort_inplace(newlst, compare)
    return newlst
