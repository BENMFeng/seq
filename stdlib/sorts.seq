### Constants ###
INSERTION_SORT_THRESHOLD = 24
NINTHER_THRESHOLD = 128
PARTIAL_INSERTION_SORT_LIMIT = 8
BLOCK_SIZE = 64
CACHELINE_SIZE = 64

### Helpers ###

def _floor_log2(n: int) -> int:
    """
        Returns floor(log2(n))
    """
    cdef floor(float) -> float
    cdef log2(float) -> float
    return int(floor(log2(float(n))))

def _heapify[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    """
        Makes the array a heap from [begin, end).
    """
    root = begin
    left = 2 * begin + 1
    right = 2 * begin + 2

    if left < end and comp(arr[root], arr[left]):
        root = left

    if right < end and comp(arr[root], arr[right]):
        root = right
    
    if root != begin:
        arr[begin], arr[root] = arr[root], arr[begin]
        _heapify(arr, root, end, comp)

def _partial_insertion_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> bool:
    if begin == end:
        return True
    
    limit = 0
    cur = begin + 1
    while cur != end:
        if limit > PARTIAL_INSERTION_SORT_LIMIT:
            return False
        
        sift = cur
        sift_1 = cur -1

        if comp(arr[sift], arr[sift_1]):
            tmp = arr[sift]

            while True:
                arr[sift] = arr[sift_1]
                sift -= 1
                sift_1 -= 1
                if sift == begin or not comp(tmp, arr[sift_1]):
                    break
            
            arr[sift] = tmp
            limit += cur - sift
        
        cur += 1
    
    return True


def _partition_left[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> int:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        last -= 1
        if not comp(pivot, arr[last]):
            break
    
    if (last + 1 == end):
        while first < last:
            first += 1
            if comp(pivot, arr[first]):
                break
    
    else:
        while True:
            first += 1
            if comp(pivot, arr[first]):
                break
    
    while first < last:
        arr[first], arr[last] = arr[last], arr[first]
        while True:
            last -= 1
            if not comp(pivot, arr[last]):
                break
        while True:
            first += 1
            if comp(pivot, arr[first]):
                break
    
    pivot_pos = last
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return pivot_pos

def _partition_right[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]) -> tuple[int,int]:
    pivot = arr[begin]
    first = begin
    last = end

    while True:
        first += 1
        if not comp(arr[first], pivot):
            break
    
    if first - 1 == begin:
        while first < last:
            last -= 1
            if comp(arr[last], pivot):
                break
    
    else:
        while True:
            last -= 1
            if comp(arr[last], pivot):
                break
    
    already_partitioned = 0
    if first >= last:
        already_partitioned = 1
    
    while first < last:
        arr[first], arr[last] = arr[last], arr[first]
        
        while True:
            first += 1
            if not comp(arr[first], pivot):
                break
        
        while True:
            last -= 1
            if comp(arr[last], pivot):
                break
    
    pivot_pos = first - 1
    arr[begin] = arr[pivot_pos]
    arr[pivot_pos] = pivot

    return (pivot_pos, already_partitioned)

def _sort2[T](arr: array[T], i: int, j: int, comp: function[bool,T,T]):
    if comp(arr[j], arr[i]):
        arr[i], arr[j] = arr[j], arr[i]

def _sort3[T](arr: array[T], i: int, j: int, k: int, comp: function[bool,T,T]):
    _sort2(arr, i, j, comp)
    _sort2(arr, j, k, comp)
    _sort2(arr, i, j, comp)

### Private Sorts ###

def _insertion_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    i = begin + 1
    while i < end:
        x = arr[i]
        j = i - 1
        while j >= 0 and comp(x, arr[j]):
            arr[j+1] = arr[j]
            j -= 1
        arr[j+1] = x
        i += 1

def _heap_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T]):
    if end - begin < 2:
        return
    
    for i in range(end, begin - 1, -1):
        _heapify(arr, i, end, comp)
    
    for i in range(end -1, begin, -1):
        arr[i], arr[begin] = arr[begin], arr[i]
        _heapify(arr, begin, i, comp)

def _pdq_sort[T](arr: array[T], begin: int, end: int, comp: function[bool,T,T], bad_allowed: int, leftmost: bool):
    while True:
        size = end - begin
        if size < INSERTION_SORT_THRESHOLD:
            _insertion_sort(arr, begin, end, comp)
            return
        
        size_2 = int(size / 2)
        if size > NINTHER_THRESHOLD:
            _sort3(arr, begin, begin + size_2, end - 1, comp)
            _sort3(arr, begin + 1, begin + (size_2 - 1), end - 2, comp)
            _sort3(arr, begin + 2, begin + (size_2 + 1), end - 3, comp)
            _sort3(arr, begin + (size_2 - 1), begin + size_2, begin + (size_2 + 1), comp)
            arr[begin], arr[begin + size_2] = arr[begin + size_2], arr[begin]
        else:
            _sort3(arr, begin + size_2, begin, end - 1, comp)
        
        if not leftmost and not comp(arr[begin - 1], arr[begin]):
            begin = _partition_left(arr, begin, end, comp) + 1
            continue

        part_result = _partition_right(arr, begin, end, comp)
        pivot_pos = part_result[0]
        already_partitioned = part_result[1] == 1

        l_size = pivot_pos - begin
        r_size = end - (pivot_pos + 1)
        hightly_unbalanced = (l_size < (size / 8)) or (r_size < (size / 8))

        if hightly_unbalanced:
            bad_allowed -= 1
            if bad_allowed == 0:
                _heap_sort(arr, begin, end, comp)
                return
            
            if l_size >= INSERTION_SORT_THRESHOLD:
                arr[begin], arr[int(begin + l_size / 4)] = arr[int(begin + l_size / 4)], arr[begin]
                arr[pivot_pos - 1], arr[int(pivot_pos - l_size / 4)] = arr[int(pivot_pos - l_size / 4)], arr[pivot_pos - 1]

                if l_size > NINTHER_THRESHOLD:
                    arr[begin + 1], arr[int(begin + (l_size / 4 + 1))] = arr[int(begin + (l_size / 4 + 1))], arr[begin + 1]
                    arr[begin + 2], arr[int(begin + (l_size / 4 + 2))] = arr[int(begin + (l_size / 4 + 2))], arr[begin + 2]
                    arr[pivot_pos - 2], arr[int(pivot_pos - (l_size / 4 + 1))] = arr[int(pivot_pos - (l_size / 4 + 1))], arr[pivot_pos - 2]
                    arr[pivot_pos - 3], arr[int(pivot_pos - (l_size / 4 + 2))] = arr[int(pivot_pos - (l_size / 4 + 2))], arr[pivot_pos - 3]

            if r_size >= INSERTION_SORT_THRESHOLD:
                arr[pivot_pos + 1], arr[int(pivot_pos + (1 + r_size / 4))] = arr[int(pivot_pos + (1 + r_size / 4))], arr[pivot_pos + 1]
                arr[end - 1], arr[int(end - r_size / 4)] = arr[int(end - r_size / 4)], arr[end - 1]

                if r_size > NINTHER_THRESHOLD:
                    arr[pivot_pos + 2], arr[int(pivot_pos + (2 + r_size / 4))] = arr[int(pivot_pos + (2 + r_size / 4))], arr[pivot_pos + 2]
                    arr[pivot_pos + 3], arr[int(pivot_pos + (3 + r_size / 4))] = arr[int(pivot_pos + (3 + r_size / 4))], arr[pivot_pos + 3]
                    arr[end - 2], arr[int(end - (1 + r_size / 4))] = arr[int(end - (1 + r_size / 4))], arr[end - 2]
                    arr[end - 3], arr[int(end - (2 + r_size / 4))] = arr[int(end - (2 + r_size / 4))], arr[end - 3]

        else:
            if (already_partitioned and _partial_insertion_sort(arr, begin, pivot_pos, comp) and _partial_insertion_sort(arr, pivot_pos + 1, end, comp)):
                return
        
        _pdq_sort(arr, begin, pivot_pos, comp, bad_allowed, leftmost)
        begin = pivot_pos + 1
        leftmost = False

### Public Sorts ###

def insertion_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Insertion Sort
        Sorts the array inplace.
    """
    _insertion_sort(collection, 0, size, compare)

def insertion_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Insertion Sort
        Sorts the list inplace.
    """
    insertion_sort_array(collection.arr, collection.len, compare)

def insertion_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Insertion Sort
        Returns the sorted list.
    """
    newlst = copy(collection)
    insertion_sort_inplace(newlst, compare)
    return newlst

def heap_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Heap Sort
        Sorts the array inplace.
    """
    _heap_sort(collection, 0, size, compare)

def heap_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Heap Sort
        Sorts the list inplace.
    """
    heap_sort_array(collection.arr, collection.len, compare)

def heap_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Heap Sort
        Returns a sorted list.
    """
    newlst = copy(collection)
    heap_sort_inplace(newlst, compare)
    return newlst

def pdq_sort_array[T](collection: array[T], size: int, compare: function[bool,T,T]):
    """
        Pattern-defeating Quicksort
        By Orson Peters, published at https://github.com/orlp/pdqsort

        Sorts the array inplace.
    """
    _pdq_sort(collection, 0, size, compare, _floor_log2(size), True)

def pdq_sort_inplace[T](collection: list[T], compare: function[bool,T,T]):
    """
        Pattern-defeating Quicksort
        By Orson Peters, published at https://github.com/orlp/pdqsort

        Sorts the list inplace.
    """
    pdq_sort_array(collection.arr, collection.len, compare)

def pdq_sort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Pattern-defeating Quicksort
        By Orson Peters, published at https://github.com/orlp/pdqsort

        Returns a sorted list.
    """
    newlst = copy(collection)
    pdq_sort_inplace(newlst, compare)
    return newlst