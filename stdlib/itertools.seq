import math

def combinations(pool, r: int):
    """
    combinations(iterable, r)

    Return successive r-length combinations of elements in the iterable.

    combinations(range(4), 3) --> (0,1,2), (0,1,3), (0,2,3), (1,2,3)
    """
    n = len(pool)
    if r > n:
        return
    indices = list(range(r).__iter__())
    yield [pool[i] for i in indices]
    while True:
        b = -1
        for i in reversed(range(r)):
            if indices[i] != i + n - r:
                b = i
                break
        if b == -1:
            return
        indices[b] += 1
        for j in range(b+1, r):
            indices[j] = indices[j-1] + 1
        yield [pool[i] for i in indices]

def combinations_with_replacement(pool, r: int):
    """
    combinations_with_replacement(iterable, r)

    Return successive r-length combinations of elements in the iterable
    allowing individual elements to have successive repeats.
    """
    if r < 0:
        raise ValueError("ValueError: r must be a positive integer.")
    n = len(pool)
    if not n and r:
        return
    indices = [0] * r
    yield [pool[i] for i in indices]
    while True:
        b = -1
        for i in reversed(range(r)):
            if indices[i] != n - 1:
                b = i
                break
        if b == -1:
            return

        indices = [indices[i] for i in range(b)] + [indices[b]+1 for i in range(r-b)]
        yield [pool[indices[i]] for i in range(len(indices))]


def islice(iterable, start: int, stop: int, step: int):
    """
    Make an iterator that returns selected elements from the iterable.

    unlike python, seq requires start, stop and step for now.
    default: start = 0, stop = len(iterable), step = 1
    """
    if start < 0 or stop < 0:
        raise ValueError("ValueError: Indices for islice() must be None or an integer: 0 <= x <= maxint")
    elif step < 0:
        raise ValueError("ValueError: Step for islice() must be a positive integer or None.")

    it = iter(range(start, stop, step))

    nexti = 0
    try:
        nexti = next(it)
    except StopIteration:
        # Consume *iterable* up to the *start* position.
        for i, element in zip(range(start), iterable):
            pass
        return
    b = 0
    try:
        for i , element in enumerate(iterable):
            if i == nexti:
                yield element
                nexti = next(it)
                b = i

    except StopIteration:
        # Consume to *stop*.
        for i, element in zip(range(b + 1, stop), iterable):
            pass

def count(start: float, step: float):
    """
    count(start=0, step=1)

    Return a count object whose .__next__() method returns consecutive values.
    default: start = 0.0, step = 1.0
    """
    n = start
    while True:
        yield n
        n += step

def repeat(object, times: int):
    """

    default for times = None, for now seq will use -1
    """
    if times == -1:
        yield object
    else:
        for i in range(times):
            yield object

def cycle[T](iterable: T):
    """
    """
    saved = [T()] * 0
    for element in iterable:
        yield element
        saved.append(element)

    while saved:
        for element in saved:
              yield element

def compress(data, selectors):
    """
    compress(data, selectors)

    Return data elements corresponding to true selector elements.

    Forms a shorter iterator from selected data elements using the selectors to
    choose the data elements.
    """
    return [d for d, s in zip(data, selectors) if s]

def dropwhile(predicate, iterable):
    """
    dropwhile(predicate, iterable)

    Drop items from the iterable while predicate(item) is true.

    Afterwards, return every element until the iterable is exhausted.
    """
    it = iter(iterable)
    for x in it:
        if not predicate(x):
            yield x
            break
    for x in it:
        yield x

def takewhile(predicate, iterable):
    """
    takewhile(predicate, iterable)

    Return successive entries from an iterable as long as the predicate evaluates to true for each entry.
    """
    for x in iterable:
        if predicate(x):
            yield x
        else:
            break

def filterfalse(predicate, iterable):
    """
    filterfalse(function, iterable)

    Return those items of iterable for which function(item) is false.

    Unlike python, seq will not allow predicate to equal None for now.
        if predicate is None:
            predicate = bool
    """
    for x in iterable:
        if not predicate(x):
            yield x

def permutations(pool, r: int):
    """
    permutations(iterable, r)

    Return successive r-length permutations of elements in the iterable.

    Unlike python, seq does not use None for now so default for r will be len(pool)
    """
    n = len(pool)
    if r > n:
        return

    indices = list(iter(range(n)))
    cycles = list(iter(range(n, n-r, -1)))
    yield [pool[i] for i in indices[:r]]
    while n:
        b = -1
        for i in reversed(range(r)):
            cycles[i] -= 1
            if cycles[i] == 0:
                indices = indices[:i] + indices[i+1:] + indices[i:i+1]
                cycles[i] = n - i
            else:
                b = i
                j = cycles[i]
                indices[i], indices[-j] = indices[-j], indices[i]
                yield [pool[i] for i in indices[:r]]
                break
        if b == -1:
            return

def accumulate(iterable, func, initial):
    """
    accumulate(iterable, func, initial)

    Return series of accumulated sums (or other binary function results).

    Default: func = operator.add, initial = None.
    For now seq will assume initial is None.
    """
    it = iter(iterable)
    if not it.done():
        total = it.next()
        yield total
        while not it.done():
            total = func(total, it.next())
            yield total
        it.destroy()
    else:
        it.destroy()
        return

def product[T](iterables: T, repeat):

    pools = [list(pool) for pool in iterables] * repeat
    # is this right?
    result = [[T()]]
    for pool in pools:
        result = [x+[y] for x in result for y in pool]
    for prod in result:
        yield list(prod)

# def starmap(function, iterable):
#     for args in iterable:
#         # dont know how to unpack...
#         yield function(*args)
