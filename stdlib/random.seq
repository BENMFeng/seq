import C
import sys
import math

class ZeroDivisionError:
    msg: str

# cdef rand() -> int
#
# def randint(a: int, b: int) -> int:
#     return a + rand() % (b - a + 1)
#
# def choice(iter):
#     l = len(iter)
#     i = randint(0, l - 1)
#     return iter[i]

N = 624
M = 397

class Generator:
    state: array[u64]     # the array for the state vector
    state_size: int
    initf: int
    next: int

    def __init__(self: Generator):
        self.state = array[u64](N)
        self.state_size = 0
        self.initf = 0
        self.next = 0

    def gettimeofday(self: Generator):
        type timeval(tv_sec: int, tv_usec: int)
        tv = timeval(0, 0)

        cdef gettimeofday(ptr[timeval], ptr[byte]) -> i32
        err = gettimeofday(__ptr__(tv), ptr[byte]())
        if int(err) != 0:
            raise OSError("whoops") # Todo get nice message via seterr

        SEC_TO_NS = 1000 * 1000
        return tv.tv_sec * SEC_TO_NS + tv.tv_usec

    def init_genrand(self: Generator, s: u64):
        """
        init_genrand(u64) -> void

        initializes state[N] with a seed
        """
        self.state[0] = s & u64(0xffffffff)
        for i in range(1, N):
            self.state[i] = u64(1812433253 * (int(self.state[i-1]) ^ (int(self.state[i-1]) >> 30)) + i)

            # for > 32 bit machines
            self.state[i] &= u64(0xffffffff)

        self.state_size = 1
        self.initf = 1

    def init_by_array(self: Generator, init_key: array[u64], key_length: int):
        """
        initialize by an array with array-length
        init_key is the array for initializing keys
        key_length is its length
        """

        self.init_genrand(u64(19650218))
        i = 1
        j = 0
        k = 0
        if N > key_length:
            k = N
        else:
            k = key_length

        for l in reversed(range(0, k)):
            self.state[i] = u64((int(self.state[i])
                        ^ ((int(self.state[i-1])
                        ^ (int(self.state[i-1]) >> 30))
                        * 1664525))
                        + int(init_key[j])
                        + j)
            # for WORDSIZE > 32 machines
            self.state[i] &= u64(0xffffffff)
            i += 1
            j += 1

            if i >= N:
                self.state[0] = self.state[N-1]
                i = 1
            if j >= key_length:
                j = 0

        for l in reversed(range(0, N-1)):
            self.state[i] = u64((int(self.state[i])
                        ^ ((int(self.state[i-1])
                        ^ (int(self.state[i-1]) >> 30))
                        * 1566083941))
                        - i)
            # for WORDSIZE > 32 machines
            self.state[i] &= u64(0xffffffff)
            i += 1
            if i >= N:
                self.state[0] = self.state[N-1]
                i = 1

        self.state[0] = u64(0x80000000)
        # print self.state[0]
        self.state_size = 1
        self.initf = 1

    def next_state(self: Generator):
        """
        next_state()
        """

        def mixbits(u, v):
            return ((u) & u64(0x80000000)) | ((v) & u64(0x7fffffff))

        def twist(u, v):
            return (mixbits(u,v) >> u64(1)) ^ (u64(0x9908b0df) if (v)& u64(1) else u64(0))

        # if init_genrand() has not been called, a default initial seed is used
        if self.initf == 0:
            self.init_genrand(u64(5489))

        self.next = 0
        self.state_size = N
        i = 0
        for j in range(N-M+1, -1, -1):
            self.state[i] = self.state[M] ^ twist(self.state[i], self.state[i+1])
            i += 1

        for j in range(M, -1, -1):
            self.state[i] = self.state[M-N] ^ twist(self.state[i], self.state[i+1])
            i += 1

        self.state[i] = self.state[M-N] ^ twist(self.state[i], self.state[0])

    def genrand_int32(self: Generator) -> u64:
        """
        genrand_int32() -> u64

        generates a random number on [0,0xffffffff]-interval
        """

        if self.next == self.state_size:
            self.next_state()

        self.next +=1
        y = self.state[self.next]

        # Tempering
        y ^= (y >> u64(11))
        y ^= (y << u64(7)) & u64(0x9d2c5680)
        y ^= (y << u64(15)) & u64(0xefc60000)
        y ^= (y >> u64(18))

        return y

    def genrand_res53(self: Generator) -> float:
        """
        genrand_res53() -> float

        generates a random number on [0,1) with 53-bit resolution
        """

        a = self.genrand_int32() >> u64(5)
        b = self.genrand_int32() >> u64(6)

        return float((int(a) * 67108864.0 + int(b)) * (1.0 / 9007199254740992.0))

    def random_seed_time_pid(self: Generator):
        """
        helper method for seed()
        """

        now = u64(self.gettimeofday())
        key = array[u64](5)
        key[0] = u64(now & u64(0xffffffff))
        key[1] = u64(now >> u64(32))

        cdef getpid() -> int
        key[2] = u64(getpid())

        getmonotonicclock = 12345
        now = u64(getmonotonicclock)       # = getmonotonicclock()
        key[3] = u64(now & u64(0xffffffff))
        key[4] = u64(now >> u64(32))

        self.init_by_array(key, len(key))


    def seed(self):
        """Initialize internal state from hashable object.

        For now a is set to its defaults a = None
        """
        self.random_seed_time_pid()

"""Random number generator base class used by bound module functions.
Used to instantiate instances of Random to get generators that don't
share state.
Class Random can also be subclassed if you want to use a different basic
generator of your own devising: in that case, override the following
methods:  random(), seed(), getstate(), and setstate().
Optionally, implement a getrandbits() method so that randrange()
can cover arbitrarily large ranges.
"""
class Random:
    gen: Generator # comment for another error

    def __init__(self: Random, g: Generator):
        """Initialize an instance.

        Optional argument x controls seeding, as for Random.seed().

        For now x is set to its default None.
        """
        self.gen = g
        # self.gauss_next = None

    def seed(self):
        """Initialize internal state from hashable object.

        None or no argument seeds from current time or from an operating
        system specific randomness source if available.

        If *a* is an int, all bits are used.

        For version 2 (the default), all of the bits are used if *a* is a str,
        bytes, or bytearray.  For version 1 (provided for reproducing random
        sequences from older versions of Python), the algorithm for str and
        bytes generates a narrower range of seeds.

        For now a is set to its defaults a = None
        """
        a = None
        self.gen.seed()
        # self.gauss_next = None

    def from_bytes_big(self: Random, b) -> int:
        """
        Return the integer represented by the given array of bytes.
        The argument b must either be a bytes-like object or an iterable
        producing bytes.
        """
        n = 0
        for x in b:
            n <<= 8
            n |= x
        return n

    def getrandbits(self: Random, k: int) -> int:
        """
        getrandbits(k) -> x.  Generates an int with k random bits.
        """
        if k <= 0:
            raise ValueError('number of bits must be greater than zero')
        numbytes = (k + 7) // 8                       # bits / 8 and rounded up
        cdef urandom(int) -> int
        x = self.from_bytes_big(urandom(numbytes))
        return x >> (numbytes * 8 - k)                # trim excess bits

    # def _randbelow_with_getrandbits(self: Random, n: int) -> int:
    #     """
    #     Return a random int in the range [0,n).  Raises ValueError if n==0.
    #     """
    #     getrandbits = self.getrandbits
    #     k = n.bit_length()  # don't use (n-1) here because n can be 1
    #     r = getrandbits(k)          # 0 <= r < 2**k
    #     while r >= n:
    #         r = getrandbits(k)
    #     return r
    #
    # def randrange(self: Random, start: int, stop, step: int) -> int:
    #     """Choose a random item from range(start, stop[, step]).
    #
    #     Return a randomly selected element from range(start, stop, step).
    #     This is equivalent to choice(range(start, stop, step)), but
    #     doesnâ€™t actually build a range object.
    #
    #     Defaults include: stop = None, step = 1 which for now, are used for
    #     the testing.
    #
    #     for now we will use default values.
    #     """
    #
    #     if stop is None:
    #         if start > 0:
    #             return self._randbelow_with_getrandbits(start)
    #         raise ValueError("empty range for randrange()")
    #
    #     # stop argument supplied.
    #     width = stop - start
    #     if step == 1 and width > 0:
    #         return start + self._randbelow_with_getrandbits(width)
    #     if step == 1:
    #         raise ValueError("empty range for randrange() (" + start + ", " + stop ", " + width + ")")
    #
    #     # Non-unit step argument supplied.
    #     n = math.inf
    #     if step > 0:
    #         n = (width + step - 1) // step
    #     elif step < 0:
    #         n = (width + step + 1) // step
    #     else:
    #         raise ValueError("zero step for randrange()")
    #
    #     if n <= 0:
    #         raise ValueError("empty range for randrange()")
    #
    #     return start + step * self._randbelow_with_getrandbits(n)

    # def randint(self: Random, a: int, b: int):
    #     """
    #     Return random integer in range [a, b], including both end points.
    #     """
    #     return self.randrange(a, b+1)

    def random(self: Random) -> float:
        """
        random(self) -> float

        Return the next random floating point number in the range [0.0, 1.0).
        """
        return self.gen.genrand_res53()

    # def choice(self: Random, seq) -> :
    #     """
    #     Choose a random element from a non-empty sequence.
    #     """
    #     try:
    #         i = self._randbelow_with_getrandbits(len(seq))
    #     except ValueError:
    #         raise IndexError("Cannot choose from an empty sequence") from None
    #     return seq[i]

    # def shuffle(self: Random, x) -> float:
    #     """Shuffle list x in place, and return None.
    #
    #     Optional argument random is a 0-argument function returning a
    #     random float in [0.0, 1.0); if it is the default None, the
    #     standard random.random will be used.
    #
    #     For now seq will use random = None (default)
    #     """
    #     random = None
    #     if random is None:
    #         randbelow = self._randbelow_with_getrandbits
    #         for i in reversed(range(1, len(x))):
    #             # pick an element in x[:i+1] with which to exchange x[i]
    #             j = randbelow(i+1)
    #             x[i], x[j] = x[j], x[i]
    #     else:
    #         for i in reversed(range(1, len(x))):
    #             # pick an element in x[:i+1] with which to exchange x[i]
    #             j = int(random() * (i+1))
    #             x[i], x[j] = x[j], x[i]

    def uniform(self: Random, a: int, b: int) -> float:
        """
        Get a random number in the range [a, b) or [a, b] depending on rounding.
        """
        return a + (b-a) * self.random()

    def triangular(self: Random, low: float, high: float) -> float:
        """Triangular distribution.

        Continuous distribution bounded by given lower and upper limits,
        and having a given mode value in-between.

        http://en.wikipedia.org/wiki/Triangular_distribution

        For now we mode to default: mode = None
        default for low and high : low = 0.0, high = 1.0
        """
        # mode = None
        u = self.random()
        c = 0.0
        try:
            c = 0.5         # if mode is None else (mode - low) / (high - low)
        except ZeroDivisionError:
            return low
        if u > c:
            u = 1.0 - u
            c = 1.0 - c
            low, high = high, low
        return low + (high - low) * math.sqrt(u * c)

init = array[u64](4)
init[0] = u64(0x123)
init[1] = u64(0x234)
init[2] = u64(0x345)
init[3] = u64(0x456)
length = 4

rand_gen = Generator()
rand_o = Random(rand_gen)

# rand_o.getrandbits(3)
rand_o.seed()
print "random()"
print rand_o.random()
print rand_o.random()
print rand_o.random()
print ''
print "uniform()"
print rand_o.uniform(0, 100)
print rand_o.uniform(0, 100)
print rand_o.uniform(0, 100)
print ''
print "triangular()"
print rand_o.triangular(0.0, 1.0)
print rand_o.triangular(0.0, 1.0)
print rand_o.triangular(0.0, 1.0)
# print ''
# print rand_o.getrandbits(9)
# print rand_o.from_bytes_big()
# print rand_o.shuffle([3, 2, 4, 5])
# print rand_o.gen.gettimeofday()
# print rand_o.gen.gettimeofday()





# gauss = rand_o.gauss

# rand_obj = Generator()
# # rand_obj.init_by_array(init, length)
# rand_obj.genrand_res53()
