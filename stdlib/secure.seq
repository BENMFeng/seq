
from secure.mpc import MPCEnv
from secure.ntl import ZZ

#extend list:
#    def __mod__: # per element
    # needs elem +, *
    # needs sendElem

extend list:
    def __mod__(self, y):
        return [i % y for i in self]

    def __add__(self, y):
        return [i + y for i in self]

    def __mul__(self, y):
        return [i + y for i in self]

class Manager[`t](env: MPCEnv):
# TODO:
    def rand_elem(self, fid) -> `t:
        pass
        # return ZZ/vec/etc...
    def prime(fid) -> int:
        pass
        # return primes[fid]
    def switch_seed(self, pid):
        pass
        #prg.find(cur_prg_pid)->second = GetCurrentRandomStream();
        #SetSeed(prg.find(pid)->second);
        #cur_prg_pid = pid;
    def restore_seed(self):
        self.switch_seed(__cp__)

# FINISHED
    def mod(self, x: `t, fid) -> `t:
        return x % self.prime(fid)

    def cp_rand(self, i: int, fid) -> `t:
        self.switch_seed(i)
        x = self.rand_elem(fid)
        self.restore_seed()
        return x

    def reveal(self, a: `t, fid) -> `t:
        b = `t()
        next_cp = 3 - __cp__
        match __cp__:
            case 0:
                return
            case 1:
                self.env.send_elem(a, next_cp, fid)
                b = self.env.receive_elem(next_cp, fid)
            case 2:
                b = self.env.receive_elem(next_cp, fid)
                self.env.send_elem(a, next_cp, fid)
        return self.mod(a + b, fid)

    def beaver_partition(self, a: `t, fid) -> tuple[`t, `t]:
        if __cp__ == 0:
            am = self.mod(sum(self.cp_rand(i, fid) for i in (1, 2)), fid)
            return (`t(), am)
        else:
            am = self.cp_rand(0, fid)
            ar = self.reveal(self.mod(a - am, fid), fid)
            return (ar, am)

    def beaver_mult(self, ar: `t, am: `t, br: `t, bm: `t, fid) -> `t:
        match __cp__:
            case 0:
                return self.mod(am * bm, fid)
            case 1:
                return self.mod(ar * bm + am * br + ar * br, fid)
            case 2:
                return self.mod(ar * bm + am * br, fid)

    def beaver_reconstruct(self, ab: `t, fid) -> `t:
        match __cp__:
            case 0:
                ab -= self.cp_rand(1)
                self.env.send_elem(self.mod(ab, fid), 2, fid)
                return ab
            case 1:
                ambm = self.env.receive_elem(0, fid)
                return self.mod(ab + ambm, fid)
            case 2:
                ambm = self.cp_rand(0, fid)
                return self.mod(ab + ambm, fid)

# template over list[ZZ] as well
class SInt(share: ZZ, M: Manager[ZZ]):
    # Protocol 3
    def __add__(x: SInt, y: SInt):
        return x.share + y.share

    # Protocol 4
    def __add__(x: SInt, y: int):
        if __cp__ == 1:
            return x.share + y
        else:
            return x.share

    # Protocol 5
    def __mul__(x: SInt, y: int):
        return x.share * y

    # Protocol 7
    def __mul__(a: SInt, b: SInt, fid):
        ar, am = self.M.beaver_partition(a.share, fid)
        br, bm = self.M.beaver_partition(b.share, fid)
        c = self.M.beaver_mult_elem(ar, am, br, bm, fid)
        return SInt(self.M.beaver_reconstruct(c, fid), self.M)
