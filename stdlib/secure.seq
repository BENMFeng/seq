from secure.mpc import MPCEnv
from secure.ntl import ZZ, ZZ_p, zzp2zz, zz2zzp

class SInt(share: ZZ_p):
    def _init(self: SInt, share: ZZ_p):
        match __cp__:
            case 0:
                __mpc_env__.switch_seed(1)
                r = __mpc_env__.rand_elem()
                __mpc_env__.restore_seed()

                self.share = share
                share2 = zzp2zz(share - r)
                __mpc_env__.send_elem(share2, 2, 0)
            case 1:
                __mpc_env__.switch_seed(0)
                self.share = __mpc_env__.rand_elem()
                __mpc_env__.restore_seed()
            case 2:
                self.share = zz2zzp(__mpc_env__.receive_elem(0, 0))
            default:
                assert False

    def __init__(self: SInt, share: ZZ_p):
        self._init(share)

    def __init__(self: SInt, share: int):
        self._init(ZZ_p(share))

    # Protocol 3
    def __add__(x: SInt, y: SInt):
        return x.share + y.share

    # Protocol 4
    def __add__(x: SInt, y: int):
        if __cp__ == 1:
            return x.share + y
        else:
            return x.share

    # Protocol 5
    def __mul__(x: SInt, y: int):
        return x.share * y

    # Protocol 7
    def __mul__(a: SInt, b: SInt, fid):
        ar, am = __mpc_env__.beaver_partition(a.share, fid)
        br, bm = __mpc_env__.beaver_partition(b.share, fid)
        c = __mpc_env__.beaver_mult_elem(ar, am, br, bm, fid)
        return SInt(__mpc_env__.beaver_reconstruct(c, fid))

    def __print__(self: SInt):
        print __cp__, ':', self.share
