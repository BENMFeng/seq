from err import *

class File:
    sz: int
    buf: ptr[byte]
    fp: ptr[byte]

    def _reset(self: File):
        self.buf = ptr[byte]()
        self.sz = 0

    def __init__(self: File, fp: ptr[byte]):
        self.fp = fp
        self._reset()

    def __init__(self: File, path: str, mode: str):
        cdef fopen(ptr[byte], ptr[byte]) -> ptr[byte]
        self.fp = fopen(path.c_str(), mode.c_str())
        if not self.fp:
            raise IOError("file " + path + " could not be opened")
        self._reset()

    def close(self):
        cdef fclose(ptr[byte]) -> int
        cdef free(ptr[byte])
        if self.fp:
            fclose(self.fp)
        if self.buf:
            free(self.buf)
            self._reset()

    def _iter(self: File):
        cdef getline(ptr[ptr[byte]], n: ptr[int], file: ptr[byte]) -> int
        while True:
            # pass pointers to individual class fields:
            rd = getline(ptr[ptr[byte]](self.__raw__() + 8), ptr[int](self.__raw__()), self.fp)
            if rd != -1:
                if self.buf[rd - 1] == byte(10):
                    rd -= 1
                yield str(self.buf, rd)
            else:
                break

    def __iter__(self: File):
        for a in self._iter():
            yield copy(a)

    def readlines(self):
        return [l for l in self]

    def write(self, s: str):
        cdef fwrite(ptr[byte], int, int, ptr[byte]) -> int
        fwrite(s.ptr, 1, s.len, self.fp)

    def write_gen[T](self, g: generator[T]):
        for s in g:
            self.write(str(s))

def open(path: str, mode: str):
    return File(path, mode)
