import C
import algorithms

class TypeError:
    msg: str

class ValueError:
    msg: str

def ord(s: str) -> byte:
    if len(s) != 1:
        raise TypeError("TypeError: ord() expected a character, but string of length " + str(len(s)) + " found")
    return s.ptr[0]

def chr(b: int) -> str:
    p = ptr[byte](1)
    p[0] = byte(b)
    return str(p, 1)

def search(text: str, pattern: str) -> list[int]:
    return algorithms.string_search_slow(text, pattern)

extend str:
    def isdigit(self: str) -> bool:
        """
        str.isdigit() -> bool

        Return True if all characters in str are digits
        and there is at least one character in str, False otherwise.
        """

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.isdigit(int(self.ptr[0])) > 0

        for i in range(len(self)):
            if C.isdigit(int(self.ptr[i])) == 0:
                return False
        return True

    def islower(self: str) -> bool:
        """
        str.islower() -> bool

        Return True if all cased characters in str are lowercase and there is
        at least one cased character in str, False otherwise.
        """
        cased = False

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.islower(int(self.ptr[0])) > 0

        for i in range(len(self)):
            if C.isupper(int(self.ptr[i])) > 0:
                return False
            elif cased == False and C.islower(int(self.ptr[i])):
                cased = True
        return cased

    def isupper(self: str) -> bool:
        """
        str.isupper() -> bool

        Return True if all cased characters in str are uppercase and there is
        at least one cased character in str, False otherwise.
        """
        cased = False

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.isupper(int(self.ptr[0])) > 0

        for i in range(len(self)):
            if C.islower(int(self.ptr[i])) > 0:
                return False
            elif cased == False and C.isupper(int(self.ptr[i])):
                cased = True
        return cased

    def isalnum(self: str) -> bool:
        """
        str.isalnum() -> bool

        Return True if all characters in str are alphanumeric
        and there is at least one character in str, False otherwise.
        """

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.isalnum(int(self.ptr[0])) > 0

        for i in range(len(self)):
            if C.isalnum(int(self.ptr[i])) == 0:
                return False
        return True

    def isalpha(self: str) -> bool:
        """
        str.isalpha() -> bool

        Return True if all characters in str are alphabetic
        and there is at least one character in str, False otherwise.
        """

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.isalpha(int(self.ptr[0])) > 0

        for i in range(len(self)):
            if C.isalpha(int(self.ptr[i])) == 0:
                return False
        return True

    def isspace(self: str) -> bool:
        """
        str.isspace() -> bool

        Return True if all characters in str are whitespace
        and there is at least one character in str, False otherwise.
        """

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.isspace(int(self.ptr[0])) > 0

        for i in range(len(self)):
            if C.isspace(int(self.ptr[i])) == 0:
                return False
        return True

    def istitle(self: str) -> bool:
        """
        str.istitle() -> bool

        Return True if str is a titlecased string and there is at least one
        character in str, i.e. uppercase characters may only follow uncased
        characters and lowercase characters only cased ones. Return False
        otherwise.
        """

        # For empty strings
        if len(self) == 0:
            return False

        # For single character strings
        if len(self) == 1:
            return C.isupper(int(self.ptr[0])) > 0

        cased = False
        prev_is_cased = False
        for i in range(len(self)):
            if C.isupper(int(self.ptr[i])) > 0:
                if prev_is_cased:
                    return False
                prev_is_cased = True
                cased = True
            elif C.islower(int(self.ptr[i])) > 0:
                if not prev_is_cased:
                    return False
                prev_is_cased = True
                cased = True
            else:
                prev_is_cased = False
        return cased

    def capitalize(self: str) -> str:
        """
        str.capitalize() -> copy of str

        Return a copy of str with only its first character capitalized (ASCII)
        and the rest lower-cased.
        """

        if len(self) > 0:
            # Capitalize first letter
            s = str(chr(C.toupper(int(self.ptr[0]))))

            # Make any following char lowercase
            for i in range(1, len(self)):
                if C.isupper(int(self.ptr[i])):
                    s = s + str(chr(C.tolower(int(self.ptr[i]))))
                else:
                    s = s + self[i]
            return s

        # Empty string
        return ''

    def isdecimal(self: str) -> bool:
        """
        str.isdecimal() -> bool

        Return True if str is a decimal string, False otherwise.
        str is a decimal string if all characters in str are decimal and
        there is at least one character in str.
        """
        # Empty string
        if len(self) == 0:
            return False

        for i in range(len(self)):
            # test ascii values 48-57 == 0-9
            if not (48 <= int(self.ptr[i]) <= 57):
                return False
        return True

    def lower(self: str) -> str:
        """
        str.lower() -> copy of str

        Return a copy of str with all ASCII characters converted to lowercase.
        """
        s = ''
        # Empty string
        if len(self) == 0:
            return s

        for i in range(len(self)):
            if C.isupper(int(self.ptr[i])):
                s = s + str(chr(C.tolower(int(self.ptr[i]))))
            else:
                s = s + str(self.ptr[i])
        return s

    def upper(self: str) -> str:
        """
        str.upper() -> copy of str

        Return a copy of str with all ASCII characters converted to uppercase.
        """
        s = ''
        # Empty string
        if len(self) == 0:
            return s

        for i in range(len(self)):
            if C.islower(int(self.ptr[i])):
                s = s + str(chr(C.toupper(int(self.ptr[i]))))
            else:
                s = s + str(self.ptr[i])
        return s

    def isascii(self: str) -> bool:
        """
        str.isascii() -> bool

        Return True if str is empty or all characters in str are ASCII,
        False otherwise.
        """
        return all(int(ord(char)) < 128 for char in self)

    def casefold(self: str) -> str:
        """
        str.casefold() -> copy of str

        Return a version of the string suitable for caseless comparisons.

        Unlike Python, casefold() deals with just ASCII characters.
        """
        return self.lower()

    def swapcase(self: str) -> str:
        """
        str.swapcase() -> copy of str

        Return a copy of str with uppercase ASCII characters converted
        to lowercase ASCII and vice versa.
        """
        s = ''

        # Empty string
        if len(self) == 0:
            return s

        for i in range(len(self)):
            if C.islower(int(self.ptr[i])):
                s = s + str(chr(C.toupper(int(self.ptr[i]))))
            elif C.isupper(int(self.ptr[i])):
                s = s + str(chr(C.tolower(int(self.ptr[i]))))
            else:
                s = s + str(self.ptr[i])
        return s

    def title(self: str) -> str:
        """
        str.title() -> copy of str

        Return a titlecased version of str, i.e. ASCII words start with uppercase
        characters, all remaining cased characters have lowercase.
        """
        s = ''
        prev_is_cased = False

        # Empty string
        if len(self) == 0:
            return s

        for i in range(len(self)):
            if C.islower(int(self.ptr[i])):
                # lowercase to uppercase
                if not prev_is_cased:
                    s = s + str(chr(C.toupper(int(self.ptr[i]))))
                else:
                    s = s + str(self.ptr[i])
                prev_is_cased = True
            elif C.isupper(int(self.ptr[i])):
                # uppercase to lowercase
                if prev_is_cased:
                    s = s + str(chr(C.tolower(int(self.ptr[i]))))
                else:
                    s = s + str(self.ptr[i])
                prev_is_cased = True
            else:
                s = s + str(self.ptr[i])
                prev_is_cased = False
        return s

    def isnumeric(self: str) -> bool:
        """
        str.isdecimal() -> bool

        Return True if the string is a numeric string, False otherwise.
        A string is numeric if all characters in the string are numeric
        and there is at least one character in the string.

        Unlike Python, isnumeric() deals with just ASCII characters.
        """
        return self.isdecimal()

    def ljust(self: str, width: int, fillchar: str) -> str:
        """
        ljust(width[, fillchar]) -> string

        Return a left-justified string of length width.

        Padding is done using the specified fill character (default is a space).
        """
        s = ''
        s = s + self

        if width <= len(self):
            return self

        for i in range(width - len(self)):
            s = s + fillchar
        return s

    def rjust(self: str, width: int, fillchar: str) -> str:
        """
        rjust(width[, fillchar]) -> string

        Return a right-justified string of length width.

        Padding is done using the specified fill character (default is a space).
        """
        s = ''

        if width <= len(self):
            return self

        for i in range(width - len(self)):
            s = s + fillchar

        s = s + self
        return s

    def center(self: str, width: int, fillchar: str) -> str:
        """
        str.center(width[, fillchar]) -> string

        Return str centered in a string of length width. Padding is
        done using the specified fill character (default is a space)
        """
        s = ''

        if width <= len(self):
            return self

        pad = width - len(self)
        left_pad = pad // 2
        right_pad = width - len(self) - left_pad

        for i in range(left_pad):
            s = s + fillchar
        s = s + self
        for i in range(right_pad):
            s = s + fillchar
        return s

    def zfill(self: str, width: int) -> str:
        """
        str.zfill(width) -> string

        Pad a numeric string str with zeros on the left, to fill a field
        of the specified width.  The string str is never truncated.
        """
        s = ''
        sign = False

        if width <= len(self):
            return self

        if self[0] == '+' or self[0] == '-':
            # move sign to beginning of string
            s = s + self[0]
            sign = True

        fill = width - len(self)

        for i in range(fill):
            s = s + '0'

        if sign:
            s = s + self[1:]
        else:
            s = s + self
        return s

    def count(self: str, sub: str, start: int, end: int) -> int:
        """
        str.count(sub[, start[, end]]) -> int

        Return the number of occurrences of subsection sub in
        bytes str[start:end].  Optional arguments start and end are interpreted
        as in slice notation.
        """
        return len(search(self[start:end], sub))

    def find(self: str, sub: str, start: int, end: int) -> int:
        """
        str.find(sub [,start [,end]]) -> int

        Return the lowest index in str where substring sub is found,
        such that sub is contained within str[start:end].  Optional
        arguments start and end are interpreted as in slice notation.

        Return -1 on failure.
        """
        sub_list = search(self[start:end], sub)

        if len(sub_list) == 0:
            return -1

        if start > end:
            return -1

        if sub == '' and (start <= end <= len(self)):
            return start

        return sub_list[0] + start  # add start position because of truncation

    def rfind(self: str, sub: str, start: int, end: int) -> int:
        """
        str.rfind(sub [,start [,end]]) -> int

        Return the highest index in str where substring sub is found,
        such that sub is contained within str[start:end].  Optional
        arguments start and end are interpreted as in slice notation.

        Return -1 on failure.
        """
        sub_list = search(self[start:end], sub)

        if len(sub_list) == 0:
            return -1

        if start > end:
            return -1

        return sub_list[len(sub_list)-1] + start  # add start position because of truncation

    def isidentifier(self: str) -> bool:
        """
        str.isidentifier() -> bool

        Return True if the string is a valid identifier, False otherwise.
        Unlike Python, isidentifier() deals with just ASCII characters.
        """
        # empty string
        if len(self) == 0:
            return False

        # is not a letter or _
        if not self[0].isalpha():
            if self[0] != '_':
                return False

        if self[0].isalpha() or self[0] == '_':
            for i in range(1, len(self)):
                if not self[i].isalpha():
                    if not self[i].isdecimal():
                        if self[i] != '_':
                            return False

        return True

    def isprintable(self: str) -> bool:
        """
        str.isprintable() -> bool

        Return True if the string is printable or empty, False otherwise.
        Unlike Python, isprintable() deals with just ASCII characters.
        """
        return all(31 < int(ord(char)) < 128 for char in self)

    def lstrip(self: str, chars: str) -> str:
        """
        str.lstrip([chars]) -> string

        Return a copy of the string str with leading whitespace removed.
        If chars is given, remove characters in chars instead.
        Unlike Python, lstrip() deals with just ASCII characters.
        """
        # no chars to strip
        if chars == '':
            i = 0
            # lstrip
            while i < len(self) and self[i].isspace():
                i += 1

            if i == 0:
                return self

            return self[i:]

        # with chars to strip
        else:
            i = 0
            # lstrip
            for k in range(len(self)):
                l = 0
                for l in range(len(chars)):
                    if chars[l] == self[i]:
                        i += 1
                if l == len(chars) - 1:
                    break

            if i == 0:
                return self

            return self[i:]

    def rstrip(self: str, chars: str) -> str:
        """
        str.rstrip([chars]) -> string

        Return a copy of the string str with trailing whitespace removed.
        If chars is given, remove characters in chars instead.
        Unlike Python, lstrip() deals with just ASCII characters.
        """
        # no chars to strip
        if chars == '':
            i = len(self)-1
            # rstrip
            while i < len(self) and self[i].isspace():
                i -= 1

            i += 1
            if i == len(self):
                return self

            return self[:i]

        # with chars to strip
        else:
            i = len(self)-1
            # rstrip
            for k in range(len(self)):
                l = 0
                for l in range(len(chars)):
                    if chars[l] == self[i]:
                        i -= 1
                if l == len(chars) - 1:
                    break

            i += 1
            if i == 0:
                return self

            return self[:i]

    def strip(self: str, chars: str) -> str:
        """
        str.strip([chars]) -> string

        Return a copy of the string str with leading and trailing
        whitespace removed.
        If chars is given, remove characters in chars instead.
        Unlike Python, lstrip() deals with just ASCII characters.
        """
        lstr = self.lstrip(chars)
        rstr = lstr.rstrip(chars)
        return rstr

    def partition(self: str, sep: str) -> tuple[str, str, str]:
        """
        str.partition(sep) -> (head, sep, tail)

        Search for the separator sep in str, and return the part before it,
        the separator itself, and the part after it.  If the separator is not
        found, return str and two empty strings.
        """
        li = search(self, sep)

        if len(li) == 0:
            return self,'',''

        if not li[0]:
            return '',  sep, self[li[0]+len(sep):]

        return self[:li[0]],sep,self[li[0]+len(sep):]

    def rpartition(self: str, sep: str) -> tuple[str, str, str]:
        """
        str.rpartition(sep) -> (head, sep, tail)

        Search for the separator sep in str, starting at the end of str, and return
        the part before it, the separator itself, and the part after it.  If the
        separator is not found, return two empty strings and str.
        """
        li = search(self, sep)
        i = len(li)-1

        if len(li) == 0:
            return '', '', self

        if not li[0]:
            return '',  sep, self[li[i]+len(sep):]

        return self[:li[i]], sep, self[li[i]+len(sep):]

    def split(self: str, sep: str, maxsplit: int) -> list[str]:
        """
        str.split([sep [,maxsplit]]) -> list of strings

        Return a list of the words in the string str, using sep as the
        delimiter string.  If maxsplit is given, at most maxsplit
        splits are done. If sep is not specified, any
        whitespace string is a separator and empty strings are removed
        from the result.
        """
        li = search(self, sep)
        str_split = list[str]()

        if len(li) == 0:
            return [self]
        if len(sep) > len(self):
            return [self]
        if maxsplit == 0:
            return [self]

        if maxsplit == -1 or maxsplit > len(li):
            maxsplit = len(li)

        prev = li[0]
        # append first part of string
        # if sep is found in index 0, add '' to separate
        if li[0] == 0:
            str_split.append('')
        else:
            str_split.append(self[:li[0]])

        # split the rest of the string according to separator
        if len(li) > 1 and maxsplit > 1:
            for j in range(1, maxsplit):
                # when separators are beside each other, append '' to list
                if li[j] - 1 == prev:
                    str_split.append('')
                    prev = li[j]
                else:
                    str_split.append(self[prev+len(sep):li[j]])
                    prev = li[j]

        if prev != len(self):
            str_split.append(self[prev+len(sep):])
            return str_split
        else:
            return  str_split

    def startswith(self: str, prefix: str, start: int, end: int) -> bool:
        """
        str.startswith(prefix[, start[, end]]) -> bool

        Return True if str starts with the specified prefix, False otherwise.
        With optional start, test str beginning at that position.
        With optional end, stop comparing str at that position.
        """
        if end < 0:
            end += len(self)
        elif start < 0:
            start += len(self)

        # length prefix is longer than range of string being compared to
        if start + len(prefix) > len(self):
            return False

        # length of prefix is longer than range of string[start:end]
        if end - start < len(prefix):
            return False

        # prefix is an empty string
        if prefix == '':
            return True

        return prefix == self[start:start + len(prefix)]
