import python as py

class _set_entry[T]:
    k: T
    hash: int
    next: _set_entry[T]

    def __init__(self: _set_entry[T], k: T, hash: int):
        self.k = k
        self.hash = hash
        self.next = None

    def eq(self: _set_entry[T], k: T, hash: int):
        return self.hash == hash and self.k == k

class set[T]:
    table: array[_set_entry[T]]
    size: int

    def _make_table(len: int):
        table = array[_set_entry[T]](len)
        for i in range(len):
            table[i] = None
        return table

    def _find(self: set[T], k: T, h: int):
        idx = h & (self.table.len - 1)
        e = self.table[idx]
        while e:
            if e.eq(k, h):
                break
            e = e.next
        return e

    def _entry_iter(self: set[T]) -> _set_entry[T]:
        table = self.table
        for i in range(table.len):
            e = table[i]
            while e:
                n = e.next
                yield e
                e = n

    def _insert(self: set[T], table: array[_set_entry[T]], e: _set_entry[T]):
        idx = e.hash & (table.len - 1)
        e.next = table[idx]
        table[idx] = e
        self.size += 1

    def _resize(self: set[T]):
        table = set[T]._make_table(2 * self.table.len)
        for e in self._entry_iter():
            self._insert(table, e)
        self.table = table

    def __init__(self: set[T]):
        self.table = set[T]._make_table(16)
        self.size = 0

    def __contains__(self: set[T], k: T):
        return self._find(k, hash(k)).__bool__()

    def add(self: set[T], k: T):
        h = hash(k)
        if not self._find(k, h):
            if self.size*2 >= self.table.len:
                self._resize()
            self._insert(self.table, _set_entry[T](k, h))

    def remove(self: set[T], k: T):
        h = hash(k)
        idx = h & (self.table.len - 1)
        e = self.table[idx]
        prev = e  # hacky way to ensure type of `prev` is correct
        prev = None

        while e:
            if e.eq(k, h):
                if prev:
                    prev.next = e.next
                else:
                    self.table[idx] = e.next
                self.size -= 1
                return
            prev = e
            e = e.next

    def __iter__(self: set[T]):
        for e in self._entry_iter():
            yield e.k

    def __len__(self: set[T]):
        return self.size

    def __str__(self: set[T]) -> str:
        n = len(self)
        if n == 0:
            return "{}"
        else:
            lst = list[str]()
            lst.append("{")
            first = True
            for e in self.__iter__():
                if not first:
                    lst.append(", ")
                else:
                    first = False
                lst.append(e.__str__())
            lst.append("}")
            return str.cat(lst)

    def __to_py__(self: set[T]):
        cdef seq_py_set_new() -> ptr[byte]
        cdef seq_py_set_add(ptr[byte], ptr[byte])

        pyset = seq_py_set_new()
        for a in self:
            seq_py_set_add(pyset, py.py(a).p)
        return py.PyObject(pyset)
