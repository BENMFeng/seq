import bisect
import random
from math import frexp as _frexp, floor as _floor, fabs as _fabs, gcd as _gcd, exp as _exp, log as _log

def median[T](data: list[T]) -> float:
    """
    median(data)

    Return the median (middle value) of numeric data.

    When the number of data points is odd, return the middle data point.
    When the number of data points is even, the median is interpolated by
    taking the average of the two middle values:
    """
    data = sorted(data)
    n = len(data)

    if n%2 == 1:
        return float(data[n//2])
    i = n//2
    return (data[i - 1] + data[i]) / 2

def median_low[T](data: list[T]) -> float:
    """
    median_low(data)

    Return the low median of numeric data.

    When the number of data points is odd, the middle value is returned.
    When it is even, the smaller of the two middle values is returned.
    """
    data = sorted(data)
    n = len(data)

    if n%2 == 1:
        return float(data[n//2])
    else:
        return float(data[n//2 -1])

def median_high[T](data: list[T]) -> float:
    """
    median_high(data)

    Return the high median of data.

    When the number of data points is odd, the middle value is returned.
    When it is even, the larger of the two middle values is returned.
    """
    data = sorted(data)
    n = len(data)
    return float(data[n//2])

def _find_lteq[T](a: list[T], x: float):
    """
    Locate the leftmost value exactly equal to x
    """
    i = bisect.bisect_left(a, x)
    if i != len(a) and a[i] == x:
        return i

def _find_rteq[T](a: list[T], l: int, x: float):
    """
    Locate the rightmost value exactly equal to x
    """
    i = bisect.bisect_right(a, x, lo=l)
    if i != (len(a)+1) and a[i-1] == x:
        return i-1

def median_grouped[T](data: list[T], interval = 1) -> float:
    """
    median_grouped(data, interval)

    Return the 50th percentile (median) of grouped continuous data.

    TODO/CAVEATS:
    @jordan - interval only accepts integers for now
    """
    data = sorted(data)
    n = len(data)
    if n == 1:
        return float(data[0])

    # Find the value at the midpoint.
    x = float(data[n//2])
    L = x - float(interval)/2  # The lower limit of the median interval.

    # Find the position of leftmost occurrence of x in data
    l1 = _find_lteq(data, x)
    # Find the position of rightmost occurrence of x in data[l1...len(data)]
    # Assuming always l1 <= l2
    l2 = _find_rteq(data, l1, x)
    cf = l1
    f = l2 - l1 + 1
    return L + interval*(n/2 - cf)/f

def mode[T](data: list[T]) -> T:
    """
    mode(data)

    Return the most common data point from discrete or nominal data.

    TODO/CAVEATS:
    @jordan- implement mode with Counter(data).most_common(1) when Counter is implemented
    """
    counter = 0
    elem = data[0]

    for i in data:
        curr_frequency = data.count(i)
        if curr_frequency > counter:
            counter = curr_frequency
            elem = i
    return elem

def multimode[T](data: list[T]):
    """
    multimode(data)

    Return a list of the most frequently occurring values.

    Will return more than one result if there are multiple modes
    or an empty list if *data* is empty.

    TODO/CAVEATS:
    @jordan- implement multimode with Counter(data).most_commone() when Counter is implemented
    """
    elem = data[0]
    counter = data.count(elem)
    li = sorted(data)
    mulmode = list[T]()

    for i in li:
        curr_frequency = data.count(i)
        if curr_frequency > counter:
            mulmode = list[T]()
            mulmode.append(i)
            counter = curr_frequency
        elif curr_frequency == counter and i not in mulmode:
            mulmode.append(i)
    return mulmode

def quantiles[T](data: list[T], n = 4, method = 'exclusive') -> list[float]:
    """
    quantiles(data, n, method)

    Divide *data* into *n* continuous intervals with equal probability.

    Returns a list of (n - 1) cut points separating the intervals.

    Set *n* to 4 for quartiles (the default).  Set *n* to 10 for deciles.
    Set *n* to 100 for percentiles which gives the 99 cuts points that
    separate *data* in to 100 equal sized groups.

    The *data* can be any iterable containing sample.
    The cut points are linearly interpolated between data points.

    If *method* is set to *inclusive*, *data* is treated as population
    data.  The minimum value is treated as the 0th percentile and the
    maximum value is treated as the 100th percentile.

    TODO/CAVEATS:
    @jordan- need to check if n<1 and len(data)<2 and correct method called
    """
    data = sorted(data)
    ld = len(data)

    if method == 'inclusive':
        m = ld - 1
        result = list[float]()
        for i in range(1, n):
            j = i * m // n
            delta = (i * m) - (j * n)
            interpolated = (data[j] * (n - delta) + data[j+1] * delta) / n
            result.append(interpolated)
        return result
    if method == 'exclusive':
        m = ld + 1
        result = list[float]()
        for i in range(1, n):
            j = i * m // n                               # rescale i to m/n
            j = 1 if j < 1 else ld-1 if j > ld-1 else j  # clamp to 1 .. ld-1
            delta = (i * m) - (j * n)                           # exact integer math
            interpolated = (data[j-1] * (n - delta) + data[j] * delta) / n
            result.append(interpolated)
        return result

def as_integer_ratio(x: float):
    """
    as_integer_ratio()

    Express a float in the form n / d.

    Returns a pair (n, d) of integers.
    """
    float_part, exponent = _frexp(x)      # x == float_part * 2**exponent exactly


    for i in range(300):
        if float_part == _floor(float_part): break
        float_part *= 2.0
        exponent -= 1

    numerator = int(float_part)
    denominator = 1
    _exponent = int(_fabs(float(exponent)))

    # fold in 2**exponent
    if exponent > 0: numerator <<= _exponent
    else: denominator <<= _exponent

    return (numerator, denominator)

def _lcm(x: int, y: int):
    """
    _lcm(x, y)

    Returns the lowest common multiple bewteen x and y
    """
    greater = 0
    if x > y:
        greater = x
    else:
        greater = y
    
    while(True):
        if greater % x == 0 and greater % y == 0:
            lcm = greater
            return lcm
        greater += 1
        

def _sum(data: list[float]) -> float:
    """
    _sum(data [, start]) -> (type, sum, count)

    Return a high-precision sum of the given numeric data as a fraction,
    together with the type to be converted to and the count of items.

    If optional argument ``start`` is given, it is added to the total.
    If ``data`` is empty, ``start`` (defaulting to 0) is returned.

    TODO/CAVEATS
    @jordan - the start argument should default to 0 or 0.0
            - Assumes input is floats
    """
    if len(data) == 1:
        return data[0]

    n, d = as_integer_ratio(data[0])    # First fraction
    total = 0.0

    # sum fractions (n, d) + (a, b)
    for a, b in map(as_integer_ratio, data[1:]):
        lcm = _lcm(d, b)
    
        if lcm > d:
            multiplier = lcm//d
            n *= multiplier
            d *= multiplier
        
        if lcm > b:
            multiplier = lcm//b
            a *= multiplier

        n += a
        gcd = int(_gcd(float(n), float(d)))
        n //= gcd
        d //= gcd

    total = n/d
    return total

def mean(data: list[float]) -> float:
    """
    mean(data)

    Return the sample arithmetic mean of data.

    TODO/CAVEATS
    @jordan - Assumes input is floats
            - Does not address NAN or INF
    """
    n = len(data)
    if n < 1:
        raise StatisticsError('mean requires at least one data point')
    total = _sum(data)
    return total/n

def fmean(data: list[float]) -> float:
    """
    fmean(data)

    Convert data to floats and compute the arithmetic mean.
    
    TODO/CAVEATS
    @jordan- fsum is not implemented in math.seq yet and the above 
             mean(data) deals with only floats. Thus this function is passed for now.
    """
    pass

def geometric_mean(data: list[float]) -> float:
    """
    geometric_mean(data)

    Convert data to floats and compute the geometric mean.
    
    Raises a StatisticsError if the input dataset is empty,
    if it contains a zero, or if it contains a negative value.

    TODO/CAVEATS:
    @jordan- Assumes input is a list of floats
    """
    if len(data) == 0:
        raise StatisticsError("geometric mean requires a non-empty dataset")
    return _exp(mean(list(map(_log, data))))

class NormalDist:
    """
    Normal distribution of a random variable
    """
    mu: float
    sigma: float

    def __init__(self: NormalDist, mu: float=0.0, sigma: float=1.0):
        """
        NormalDist where mu is the mean and sigma is the standard deviation.
        """
        if sigma < 0.0:
            raise StatisticsError('sigma must be non-negative')
        self.mu = mu
        self.sigma = sigma

    @property
    def mean(self: NormalDist):
        """
        mean(self)

        Arithmetic mean of the normal distribution.
        """
        return self.mu

    @property
    def median(self: NormalDist):
        """
        median(self)

        Return the median of the normal distribution
        """
        return self.mu

    @property
    def mode(self: NormalDist):
        """
        mode(self)

        Return the mode of the normal distribution

        The mode is the value x where which the probability density
        function (pdf) takes its maximum value.
        """
        return self.mu

    @property
    def stdev(self: NormalDist):
        """
        stdev(self)

        Standard deviation of the normal distribution.
        """
        return self.sigma

    @property
    def variance(self: NormalDist):
        """
        variance(self)

        Square of the standard deviation.
        """
        return self.sigma ** 2.0

    def samples[T](self: NormalDist, n, seed: optional[T]=None):
        """
        samples(self, n, seed)

        Generate *n* samples for a given mean and standard deviation.

        TODO/CAVEATS:
        @jordan- gauss needs to deal with seed=None
                 gauss = random.gauss if seed is None else random.Random(seed).gauss
        """
        if seed:
            print('here')
        else:
            print 'None'
        gauss = random.gauss if seed else random.Random(seed).gauss

        return [gauss(self.mu, self.sigma) for i in range(n)]
