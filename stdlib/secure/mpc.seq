from secure.socket import Socket
from secure.ntl import ZZ, ZZ_p

def bytes_from_zz(buf: ptr[byte], zz: ZZ, n: int):
    extern c ZZ_ToBytes(ptr[byte], ptr[byte], int)
    ZZ_ToBytes(buf, zz.p, n)

def zz_from_bytes(buf: ptr[byte], n: int):
    extern c ZZ_FromBytes(ptr[byte], int) -> ptr[byte]
    return ZZ(ZZ_FromBytes(buf, n))

type MPCEnv(p: ptr[byte])
extend MPCEnv:
    def __init__(self: MPCEnv, pairs: list[tuple[int,int]], pid: int) -> MPCEnv:
        extern c seq_mpc_new(int, array[tuple[int,int]]) -> ptr[byte]
        return (seq_mpc_new(pid, array[tuple[int,int]](pairs.arr.ptr, pairs.len)),)

    def buf(self: MPCEnv):
        extern c seq_mpc_get_buf(ptr[byte]) -> ptr[byte]
        return seq_mpc_get_buf(self.p)

    def zz_bytes(self: MPCEnv, fid: int):
        extern c seq_mpc_zz_bytes(ptr[byte], int) -> int
        return seq_mpc_zz_bytes(self.p, fid)

    def zz_bits(self: MPCEnv, fid: int):
        extern c seq_mpc_zz_bits(ptr[byte], int) -> int
        return seq_mpc_zz_bits(self.p, fid)

    def zz_bytes(self: MPCEnv, fid: int):
        extern c seq_mpc_zz_per_buf(ptr[byte], int) -> int
        return seq_mpc_zz_per_buf(self.p, fid)

    def socket(self: MPCEnv, from_pid: int) -> Socket:
        extern c seq_mpc_socket(ptr[byte], int) -> ptr[byte]
        return (seq_mpc_socket(self.p, from_pid),)

    def receive_elem(self: MPCEnv, from_pid: int, fid: int):
        s = self.socket(from_pid)
        s.receive_secure(self.buf(), self.zz_bytes(fid), 0)
        return zz_from_bytes(self.buf(), self.zz_bytes(fid))

    def send_elem(self: MPCEnv, zz: ZZ, to_pid: int, fid: int):
        s = self.socket(to_pid)
        bytes_from_zz(self.buf(), zz, self.zz_bytes(fid))
        s.send_secure(self.buf(), self.zz_bytes(fid), 0)

    def switch_seed(self: MPCEnv, pid: int):
        extern c seq_mpc_switch_seed(ptr[byte], int)
        seq_mpc_switch_seed(pid)

    def restore_seed(self: MPCEnv):
        extern c seq_mpc_switch_seed(ptr[byte])
        seq_mpc_switch_seed()

    def rand_elem(self: MPCEnv):
        return ZZ_p.random()

    def mod[`t](self, x: `t, fid) -> `t:
        return x % prime(fid)

    def cp_rand[`t](self, i: int, fid) -> `t:
        self.switch_seed(i)
        x = self.rand_elem()
        self.switch_seed(__cp__)
        return x

    def reveal[`t](self, a: `t, fid) -> `t:
        b = `t()
        next_cp = 3 - __cp__
        match __cp__:
            case 0:
                return
            case 1:
                self.send_elem(a, next_cp, fid)
                b = self.receive_elem(next_cp, fid)
            case 2:
                b = self.receive_elem(next_cp, fid)
                self.send_elem(a, next_cp, fid)
            default:
                assert False
        return self.mod(a + b, fid)

    def beaver_partition[`t](self, a: `t, fid) -> tuple[`t, `t]:
        if __cp__ == 0:
            am = self.mod(sum(self.cp_rand(i, fid) for i in (1, 2)), fid)
            return (`t(), am)
        else:
            am = self.cp_rand(0, fid)
            ar = self.reveal(self.mod(a - am, fid), fid)
            return (ar, am)

    def beaver_mult[`t](self, ar: `t, am: `t, br: `t, bm: `t, fid) -> `t:
        match __cp__:
            case 0:
                return self.mod(am * bm, fid)
            case 1:
                return self.mod(ar * bm + am * br + ar * br, fid)
            case 2:
                return self.mod(ar * bm + am * br, fid)
            default:
                assert False

    def beaver_reconstruct[`t](self, ab: `t, fid) -> `t:
        match __cp__:
            case 0:
                ab -= self.cp_rand(1)
                self.send_elem(self.mod(ab, fid), 2, fid)
                return ab
            case 1:
                ambm = self.receive_elem(0, fid)
                return self.mod(ab + ambm, fid)
            case 2:
                ambm = self.cp_rand(0, fid)
                return self.mod(ab + ambm, fid)
            default:
                assert False
