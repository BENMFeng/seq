from secure.socket import Socket
# from secure.ntl import 

type MPCEnv(p: ptr[byte], fid: int):
    def __init__(self: MPCEnv, pairs: list[tuple[int,int]], pid: int) -> MPCEnv:
        extern c seq_mpc_new(int, array[tuple[int,int]]) -> ptr[byte]
        return (seq_mpc_new(pid, array[tuple[int,int]](pairs.arr.ptr, pairs.len)), 0)

    def cleanup(self: MPCEnv):
        extern c seq_mpcenv_cleanup(ptr[byte]) -> ptr[byte]
        self.p = seq_mpcenv_cleanup(self.p)

    def buf(self: MPCEnv):
        extern c seq_mpc_get_buf(ptr[byte]) -> ptr[byte]
        return seq_mpc_get_buf(self.p)

    def zz_bytes(self: MPCEnv):
        extern c seq_mpc_zz_bytes(ptr[byte], int) -> int
        return seq_mpc_zz_bytes(self.p, self.fid)

    def zz_bits(self: MPCEnv):
        extern c seq_mpc_zz_bits(ptr[byte], int) -> int
        return seq_mpc_zz_bits(self.p, self.fid)

    def zz_per_buf(self: MPCEnv):
        extern c seq_mpc_zz_per_buf(ptr[byte], int) -> int
        return seq_mpc_zz_per_buf(self.p, self.fid)

    def socket(self: MPCEnv, from_pid: int) -> Socket:
        extern c seq_mpc_socket(ptr[byte], int) -> ptr[byte]
        return (seq_mpc_socket(self.p, from_pid), )

    def switch_seed(self: MPCEnv, pid: int):
        extern c seq_mpc_switch_seed(ptr[byte], int)
        seq_mpc_switch_seed(self.p, pid)

    def restore_seed(self: MPCEnv):
        extern c seq_mpc_restore_seed(ptr[byte])
        seq_mpc_restore_seed(self.p)

    ######################################################################

    def send[`t](self: MPCEnv, to_pid: int, what: `t):
        s = self.socket(to_pid)
        what.send(s, self.buf(), self.zz_bytes(), self.zz_per_buf())
        
    def receive[`t](self: MPCEnv, from_pid: int, what: `t) -> `t:
        s = self.socket(from_pid)
        return `t.receive(len(what), s, self.buf(), self.zz_bytes(), self.zz_per_buf())

    def rand_at[`t](self: MPCEnv, at: int, what: `t) -> `t:
        self.switch_seed(at)
        x = `t.random(len(what))
        self.restore_seed()
        return x

    def share[`t](self: MPCEnv, x: `t) -> `t:
        """Protocol 1: ShareSecret (p.7)"""
        match __cp__:
            case 0:
                r = self.rand_at[`t](1, x)
                self.send(2, x - r)
                return x
            case 1:
                r = self.rand_at[`t](0, x)
                return r
            case 2:
                xr = self.receive[`t](0, x)
                return xr
            default:
                assert False

    def reveal[`t](self: MPCEnv, a: `t) -> `t:
        """Protocol 2: ReconstructSecret (p.8)"""
        next_cp = 3 - __cp__
        match __cp__:
            case 0:
                return copy(a)
            case 1:
                self.send(next_cp, a)
                b = self.receive[`t](next_cp, a)
                return a + b
            case 2:
                b = self.receive[`t](next_cp, a)
                self.send(next_cp, a)
                return a + b
            default:
                assert False

    def beaver_partition[`t](self: MPCEnv, a: `t) -> tuple[`t, `t]:
        """Protocol 8: BeaverPartition (p.11) """
        if __cp__ == 0:
            # essentially sum of 2 random numbers...
            am = self.rand_at[`t](1, a) + self.rand_at[`t](2, a)
            return (`t(len(am)), am)
        else:
            am = self.rand_at[`t](0, a)
            ar = a - am
            ar = self.reveal(ar)
            return (ar, am)

    def beaver_mult[`t](self: MPCEnv, ar: `t, am: `t, br: `t, bm: `t):
        """Protocol 9: part of EvaluatePolynomial (p.12)"""
        match __cp__:
            case 0:
                return am * bm
            case 1:
                return ar * bm + am * br + ar * br
            case 2:
                return ar * bm + am * br
            default:
                assert False

    def beaver_reconstruct[`t](self: MPCEnv, ab: `t) -> `t:
        """Protocol 9: part of EvaluatePolynomial (p.12)"""
        match __cp__:
            case 0:
                mask = self.rand_at[`t](1, ab)
                ab -= mask
                self.send(2, ab)
                return ab
            case 1:
                ambm = self.rand_at[`t](0, ab)
                return ab + ambm
            case 2:
                ambm = self.receive[`t](0, ab)
                return ab + ambm
            default:
                assert False


