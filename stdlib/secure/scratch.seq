__mpc_env__.beaver_partition => BP (T -> S, S)
__mpc_env__.beaver_inner => BI (S, S -> S)
__mpc_env__.beaver_reconstruct => BR (S -> S)

from secure import Secure as S

# __mul__ [elem], __matmul__ [normal]
# TODO: check VecMat manually
# TODO: Add "Mod" automatically to Zx ones... 
# todo check add/addsclalar

DoubleToFP(one, 1, Param::NBIT_K, Param::NBIT_F)

def inner_prod(a):
  ar, am = BP(a)
  c = BI(ar, am) # for Vec/Mat this iterates
  return BR(c)

def householder(x: Vec) -> Vec:
  xr, xm = BP(x)

  xdot = Vec([BI(xr, xm)])
  xdot = S.trunc(BR(xdot))
  xnorm, _ = S.sqrt(xdot)

  x1 = Vec([x[0]])
  x1sign = S.is_positive(x_1)
  x1sign *= 2
  if CP1: x1sign[0] -= 1
  shift = S.mul(xnorm, x1sign)
  sr, sm = BP(shift[0])
  dot_shift = BM(xr[0], xm[0], sr, sm)
  dot_shift = S.trunc(BR(dot_shift))

  vdot = Vec(1)
  if CP: vdot[0] = 2 * (xdot[0] + dot_shift)
  _, vnorm_inv = S.sqrt(vdot)
  invr, invm = BP(vnorm_inv[0])
  
  vr = xr if CP else Vec(n)
  if CP: vr[0] += sr 
  vm = xm
  vm[0] += sm

  v = BM(vr, vm, invr, invm)
  return S.trunc(BR(v))

def qr_factor_square(A: Mat) -> tuple[Mat, Mat]:
  n = A.rows
  R = Mat(n, n)
  Ap = A if CP else Mat(n, n)
  Q = Mat()

  for i in range(n - 1):
    v = Mat(1, Ap.cols)
    v[0] = S.householder(Ap[0])
    vt = S.transpose(v) if CP else Mat(Ap.cols, 1)
    P = S.trunc(S.matmul(vt, v))
    if CP:
      P *= -2
      if CP1:
        for j in range(P.cols): 
          P[j][j] += Float.cache(1, NBIT_K, NBIT_F)
    if i == 0:
      Q = P
      B = S.trunc((S(Ap) @ S(P)).sh)
    else:
      Qsub = Mat(n - i, n)
      if CP: 
        Qsub.update(0, n - i, Q[i:n])

      l0, l1 = P, Ap
      r0, r1 = Qsub, P
      p0, p1 = S.trunc(S.matmul(l0, r0)), S.trunc(S.matmul(l1, r1))

      B = Mat(n - i, n - i)
      if CP: 
        Q.update(i, n, p0[0:n - i])
        B = p1
    
    Ap = Mat(n - 1 - i, n - 1 - i)
    if CP:
      for j in range(n - i): 
        R[i + j][i] = B[j][0]
      if i == n - 2: 
        R[n-1][n-1] = B[1][1]
      for j in range (n - 1 - i): 
        for k in range(n - 1 - i):
          Ap[j][k] = B[j + 1][k + 1]
  return Q, R
      
def orthonormal_basis(A: Mat) -> Mat:
	c, n = len(A)

	v_list = list[Vec](c)
	Ap = A if CP else Mat(c, n)

	for i in range(c):
		v = Mat(1, Ap.cols)
		v[0] = S.householder(Ap[0])

		v_list[i] = v[0] if CP else Vec(Ap.cols)
		vt = S.transpose(v) if CP else Mat(Ap.cols, 1)

		Apv = S.trunc(S.matmul(Ap, vt))
		B = S.trunc(S.matmul(Apv, v))
		if CP:
			B *= 2
			B += Ap

		Ap = Mat(B.rows - 1, B.cols - 1)
		if CP:
			for j in range(Ap.rows):
				for k in range(Ap.cols):
					Ap[j][k] = B[j + 1][k + 1]

	# TODO clear matrix at initialization
	Q = Mat(c, n) 
	if CP1:
		for i in range(c):
			Q[i][i] = Float.cache(1.0)

	# TODO check range
	for i in range(c - 1, -1, -1):
		v = Mat(1, len(v_list[i]))
		if CP: v[0] = v_list[i]

		vt = S.transpose(v) if CP else Mat(v.cols, 1)
		Qsub = Mat(c, n - i)
		if CP:
			for j in range(c): 
				for k in range(n - i):
					Qsub[j][k] = Q[j][k + i]

		Qv = S.trunc(S.matmul(Qsub, vt))
		Qvv = S.trunc(S.matmul(Qv, v))
		if CP:
			Qvv *= -2
			for j in range(c): 
				for k in range(n - i):
					Q[j][k + i] += Qvv[j][k]
	return Q

def tridiag(A: Mat) -> tuple[Mat, Mat]:
	n = A.rows
  Q, T = Mat(n, n), Mat(n, n)
	if CP1:
		for i in range(n):
			Q[i][i] = Float.cache(1.0, NBIT_K, NBIT_F)

	Ap = A if CP else Mat(n, n)
	for i in range(n - 2):
		x = Ap[0][1:] if CP else Vec(Ap.cols - 1)
		v = Mat(1, len(x))
		v[0] = S.householder(x)

		vt = S.transpose(v) if CP else Mat(len(x), 1)
		vv = S.trunc(S.matmul(vt, v))
		P = Mat(Ap.cols, Ap.cols)
		if CP:
			P[0][0] = Float.cache(1.0, NBIT_K, NBIT_F) if CP1 else 0z
			for j in range(1, Ap.cols):
				for k in range(1, Ap.cols):
					P[j][k] = -2 * vv[j - 1][k - 1]
          if CP1 and j == k:
            P[j][k] += Float.cache(1.0, NBIT_K, NBIT_F)

    PAp = S.trunc(S.matmul(P, Ap))
    B = S.trunc(S.matmul(PAp, P))
    Qsub = Mat(n, n - i)
		if CP:
			for j in range(n): 
				for k in range(n - i):
					Qsub[j][k] = Q[j][k + i]
		Qsub = S.trunc(S.matmul(Qsub, P))
    Ap = Mat(B.rows - 1, B.cols - 1)
		if CP:
			for j in range(c): 
				for k in range(n - i):
					Q[j][k + i] += Qsub[j][k]

      indices = [(0, 0), (1, 0), (0, 1)]
      if i == n - 3:
        indices += [(1, 1), (1, 2), (2, 1), (2, 2)]
			for x, y in indices:
		    T[i + x][i + y] = B[x][y]

    	for j in range(Ap.rows):
				for k in range(Ap.cols):
					Ap[j][k] = B[j + 1][k + 1]

	return T, Q

def eigen_decomposition(A: Mat) -> tuple[Mat, Vec]:
	n = A.rows
	L = Vec(n)

	Ap, Q = S.tridiag(A)
	V = S.transpose(Q) if CP else Mat(n, n)
	for i in range(n - 1, 0, -1):
		for it in range(ITER_PER_EVAL):
			shift = Ap[i][i]
			if CP:
				for j in range(Ap.cols):
					Ap[j][j] -= shift
			Q, R = S.qr_factor_square(Ap)
			Ap = S.trunc(S.matmul(Q, R))
			if CP: 
				for j in range(Ap.cols):
					Ap[j][j] += shift

			Vsub = Mat(i + 1, n) 
			if CP:
        Vsub.update(0, i + 1, V[0:i + 1])
			Vsub = S.trunc(S.matmul(Q, Vsub))

			if CP:
        V.update(0, i + 1, Vsub[0:i + 1])

		L[i] = Ap[i][i]
		if i == 1:
			L[0] = Ap[0][0]

		Ap_copy = [r[:i] for r in Ap[:i]]
	return V, L

# Bit operations

# less_than_bits: 0 for private, 2 for publuic
def less_than_bits_aux(a: ZMat, b: ZMat, public: int) -> ZVec:
	n, L = a.rows, a.cols

 	# Calculate XOR 
 	x = ZMat(n, L)
	if public == 0:
		x = S.mul(a, b)
  	if CP: 
      x = S.mod(a + b - 2 * x)
	elif CP:
		x = a + b - 2 * (a * b)
		if CP2:
			x -= a if public == 1 else b
		x = S.mod(x)
  	
	f = S.prefix_or(x)
	del x
	if CP:
		for i in range(n):
			for j in range(L - 1, 0, -1):
				f[i][j] -= f[i][j - 1]
		f = S.mod(f)

	if public == 2:
		c = ZVec([sum(f[i][j] * b[i][j] for j in range(L)) for i in range(n)]) if CP 
        else ZVec(n)
  	return mod(c)
	else:
		f_arr = [ZMat(1, L) for i in range(n)] 
    b_arr = [ZMat(L, 1) for i in range(n)]
  	if CP:
  		for i in range(n):
  			f_arr[i][0] = f[i];
      	for j in range(L):
    			b_arr[i][j][0] = b[i][j]
    c_arr = [S.matmul(f_arr[i], b_arr[i]) for i in range(n)]    	
    return ZVec([c_arr[i][0][0] for i in range(n)]) if CP else ZVec(n)

# not_less_than: this + flib_bit
def less_than(a: Vec, b: Vec) -> Vec:
	ac = a - b if CP else Vec(len(a))
	return S.flip_bit(S.is_positive(ac))

# not_less_than_public: this + flib_bit
def less_than_public(a: Vec, b) -> Vec:
	ac = a if CP else Vec(len(a))
  if CP1: ac -= b
  return S.flip_bit(S.is_positive(ac))
	
def is_positive(a: Vec) -> Vec:
	n = len(a)
	nbits = self.zz_bits()[0]
	self.fid = 2

	r, r_bits = Vec(), ZMat(n, nbits)
  if CP0:
    r = self.random(a)
		r_bits = r.num_to_bits(nbits) 

		self.switch_seed(1)
		r_mask, r_bits_mask = self.random(a), self.random(r_bits)
		self.restore_seed()

		r -= r_mask  
		r_bits = mod(r_bits - r_bits_mask)
			
		self.send(r, 2)
		self.send(r_bits, 2)
  elif CP1:
		r, r_bits = self.receive(0, a), self.receive(0, r_bits)
	elif CP2:
		self.switch_seed(0)
		r, r_bits = self.random(a), self.random(r_bits)
		self.restore_seed()
	
	c = 2 * a + r if CP else Vec(n)
	c = self.reveal(c)
	c_bits = c.num_to_bits(nbits) if CP else ZMat(n, nbits)
  	
	# Incorrect result if r = 0, which happens with probaility 1 / BASE_P
	no_overflow = S.less_than_bits_public(r_bits, c_bits)

	c_xor_r = ZVec(n)
	if CP:
		for i in range(n):
			c_xor_r[i] = r_bits[i][nbits - 1] - 2 * c_bits[i][nbits - 1] * \
				           r_bits[i][nbits - 1]
			if CP1: c_xor_r[i] += c_bits[i][nbits - 1]
		c_xor_r = S.mod(c_xor_r)

	lsb = S.mul(c_xor_r * no_overflow)
	if CP:
		lsb *= 2
		for i in range(n):
      lsb[i] -= no_overflow[i] + c_xor_r[i]
  	if CP1: lsb += 1
  	lsb = S.mod(lsb)

  if CP1:
    lsb = mod(lsb + 1)
  return S.table_lookup(lsb, 0)[0]

# __not__ (a = flip(a) )
def flip_bit(a: Vec) -> Vec:
	b = -1 * a if CP else Vec(len(a))
	if CP1: b += 1
	return b

#@batch
def sqrt(a: Vec) -> tuple[Vec, Vec]:
	n = len(a)
	if n > DIV_MAX_N:
    nbatch = math.ceil(n / float(DIV_MAX_N))
    b, b_inv = Vec(n), Vec(n)
    for i in range(nbatch):
    	start = DIV_MAX_N * i
      end = min(start + DIV_MAX_N, n)
      batch_size = end - start

    	a_copy = [a[start + j] for j in range(batch_size)]
  		b_copy, b_inv_copy = S.sqrt(Vec(a_copy))
      b.update(start, start + batch_size, b_copy)
      b_inv.update(start, start + batch_size, b_inv_copy)
    return b, b_inv
	
	niter = 2 * math.ceil(math.log2(NBIT_K / 3.5))

	# Initial approximation: 1 / sqrt(a_scaled) ~= 
	# 	~= 2.9581 - 4 * a_scaled + 2 * a_scaled^2 */
	s, s_sqrt = S.normalize_even_exp(a)
	a_scaled = S.trunc(S.mul(a, s), NBIT_K, NBIT_K - NBIT_F)
	a_scaled_sq = S.truct(S.mul(a_scaled * a_scaled))

	scaled_est = Vec(n)
	if CP:
		scaled_est = -4 * a_scaled + 2 * a_scaled_sq
		if CP1:
			scaled_est += Float.cache(2.9581, NBIT_K, NBIT_F)

	h, g = Mat(1, n), Mat(1, n)
	h[0] = S.mul(scaled_est, s_sqrt)
  h = S.trunc(h, NBIT_K / 2 + NBIT_F + 2, ((NBIT_K - NBIT_F) / 2) + 1)
	# Our scaled initial approximation (scaled_est) 
	# has bit length <= NBIT_F + 2 and s_sqrt is at most NBIT_K/2 bits, 
	# so their product is at most NBIT_K/2 + NBIT_F + 2
	g[0] = S.trunc(S.mul(h[0] * 2, a))

	for it in range(niter):
		r = - S.trunc(S.mul(h, g))
		if CP1:
			for i in range(n):
				r[0][i] += Float.cache(1.5, NBIT_K, NBIT_F)
		h, g = S.trunc(S.mul(h, r)), S.trunc(S.mul(g, r))

	return g[0], 2 * h[0]
 
#@batch 			
def div(a: Shared[Vec], b: Shared[Vec]) -> Shared[Vec]:
	n = len(a)
	if n > DIV_MAX_N:	
		nbatch = ceil(n / float(DIV_MAX_N))
  	c = Vec(n)	
  	for i in range(nbatch):
  		start = DIV_MAX_N * i
  		end = min(start + DIV_MAX_N, n)
  		batch_size = end - start
  		c_copy = div(a[start:start + batch_size], b_copy[start:start + batch_size])
  		c.update(start, start + batch_size, c_copy)
  	return c

	niter = 2 * math.ceil(math.log2((NBIT_K) / 3.5)) + 1

	# Initial approximation: 1 / x_scaled ~= 
	# 	~= 5.9430 - 10 * x_scaled + 5 * x_scaled^2 
	s, s_sqrt = S.normalizer_even_exp(b)
	b_scaled = S.trunc(S.mul(b, s), NBIT_K, NBIT_K - NBIT_F)
	b_scaled_eq = S.trunc(S.mul(b_scaled, b_scaled))

	scaled_est = -10 * b_scaled + 5 * b_scaled_sq if CP else Vec(n)
	if CP1:
		scaled_est += Float.cache(5.9430, NBIT_K, NBIT_F)

  # scaled_est has bit length <= NBIT_F + 2, and s has bit length <= NBIT_K
	# so the bit length of w is at most NBIT_K + NBIT_F + 2
	w = S.trunc(S.mul(scaled_est, s), NBIT_K + NBIT_F + 2, NBIT_K - NBIT_F)
	x = S.trunc(S.mul(w, b))
  	
	x *= -1
	if CP1: x += Float.cache(1, NBIT_K, NBIT_F)
	y = S.trunc(S.mul(a, w))
	for i in range(niter):
		(xr, xm), (yr, ym) = BP(x), BP(y)
		xpr = xr
		if CP: xpr += Float.cache(1, NBIT_K, NBIT_F)
		y = BME(yr, ym, xpr, xm)
		x = BME(xr, xm, xr,  xm)
  	x, y = S.trunc(BR(x)), S.trunc(BR(y))

	if CP1: x += Float.cache(1, NBIT_K, NBIT_F)
  return S.trunc(S.mul(y, x))
 
# for vector... S.trunc(Mat([a]), k, m)[0]
# for int... S.trunc(Mat([[i]]), k, m)[0][0]
# k_def = NBIT_K + NBIT_F ; m = NBIT_F
def trunc(a: Mat, k: int, m: int) -> Mat:
  r, r_low = Mat(), Mat()
  if CP0:
    r = self.rand_mat_bits(a, k + NBIT_V)
    r_low = [[ZZ.trunc(rep(cl), m) for cl in rw] for rw in r]

    self.switch_seed(1)
    r_mask, r_low_mask = self.random(a), self.random(a)
    self.restore_seed()

    r -= r_mask 
    r_low -= r_low_mask
    self.send(2, r)
    self.send(2, r_low)
  elif CP1:
    self.switch_seed(0)
    r, r_low = self.random(a), self.random(a)  
    self.restore_seed()
  elif CP2:
    r, r_low = self.receive(0, a), self.receive(0, a)
  
  c = a + r if CP else Mat(a.rows, a.cols)
  c = self.reveal(c)

  if CP: 
    c_low = Mat([[ZZ.trunc(rep(cl), m) for cl in rw] for rw in c]) 
    a += r_low
    if CP1: a -= c_low

    # TODO caching here
    twoinv = 2z.inv().power(m)
    a = a * twoinv
  return a

def prefix_or(a: ZMat) -> ZMat:
  n = a.rows
  L = int(math.ceil(math.sqrt(float(a.cols))))
  L2 = L * L

  a_padded = ZMat(n, L2) if not CP 
    else ZMat([
      [0 if j < L2 - a.cols else a[i][j - L2 + a.cols] for j in range(L2)]
      for i in range(n)])
  a_padded = S.reshape(a_padded, n * L, L)
  x = S.fan_in_or(a_padded)
  xpre = ZMat(n * L, L)
  if CP:
    for i in range(n): 
      for j in range(L):
        xpi = L * i + j
        for k in range(L):
          xpre[xpi][k] = x[L * i + k] if k <= j else ZZ(0)

  y = S.fan_in_or(xpre)
  del xpre
  
  f = [ZMat(1, l) for _ in range(n)]
  if CP:
    for i in range(n):
      for j in range(L):
        f[i][0][j] = x[L * i] if j == 0 else y[L * i + j] - y[L * i + j - 1]
      f[i] = S.mod(f[i])
  del x
  
  tmp = [ZMat(L, L) for _ in range(n)]
  if CP:
    for i in range(n):
      for j in range(L):
        tmp[i][j] = a_padded[L * i + j]
  del a_padded

  c = [S.matmul(f[i], tmp[i]) for i in range(n)]
  del tmp

  cpre = ZMat(n * L, L)
  if CP:
    for i in range(n):
      for j in range(L):
        cpi = L * i + j
        for k in range(L):
          cpre[cpi][k] = c[i][0][k] if k <= j else ZZ(0)
  del c
    
  bdot_vec = S.fan_in_or(cpre)
  del cpre

  bdot = [ZMat(1, L) for _ in range(n)]
  if CP:
    for i in range(n):
      for j in range(L):
        bdot[i][0][j] = bdot_vec[L * i + j]
  del bdot_vec
  f = [S.reshape(m, L, 1) for m in f]
  s = [S.matmul(f[i], bdot[i]) for i in range(n)]
  del bdot

  b = ZMat(n, a.cols)
  if CP:
    for i in range(n):
      for j in range(a.cols):
        j_pad = L2 - a.cols + j;
        il = int(j_pad / L)
        jl = j_pad - il * L
        b[i][j] = s[i][il][jl] + y[L * i + il] - f[i][il][0]
  del s, y, f
  return S.mod(b);

def fan_in_or(a: ZMat) -> ZVec:
  n, d = a.rows, a.cols
  a_sum = ZVec(n)
  if CP:
    for i in range(n):
      a_sum[i] = 1 if pid == 1 else 0
      for j in range(d):
        a_sum[i] += a[i][j]
    a_sum = S.mod(a_sum)

  # TODO caching
  coeff = MatZZ(1, d + 1)
  y = ZVec([0 if i == 0 else 1 for i in range(d + 1)])
  coeff[0] = S.lagrange_interp_simple(y)
  return S.evaluate_poly(a_sum, coeff)[0]

def share_random_bits(k: int, n: int) -> tuple[Vec, ZMat]:
  if CP0:
    r = RandVecBits(n, k + NBIT_V)
    rbits = NumToBits(r, k)

    self.switch_seed(1)
    # TODO slow [refactor it]
    r_mask, rbits_mask = self.random(Vec(n)), self.random(Mat(n, k))
    self.restore_seed();

    r -= r_mask
    rbits = self.mod(rbits - rbits_mask)
    
    self.send(2, r)
    self.send(2, rbits)
    return r, rbits
  elif CP1:
    self.switch_seed(0);
    r_mask, rbits_mask = self.random(Vec(n)), self.random(Mat(n, k))
    self.restore_seed()
    return r, rbits
  elif CP2:
    r, r_bits = self.receive(0, Vec(n)), self.receive(0, Mat(n, k))
    return r, rbits

# TODO Needs ZVec -> Vec conversion implemented
def table_lookup(a, id: int) -> Mat:
  return S.evaluate_poly(Vec(a), cache[id])

def normalizer_even_exp(a: Vec) -> tuple[Vec, Vec]:
  # Base field index 1
  n = len(a)
  self.fid = 1
  
  r, r_bits = self.share_random_bits(NBIT_K, n)
  e = a + r if CP else Vec(n)
  del r
  e = S.reveal(e)

  ebits = S.num_to_bits(e, NBIT_K) if CP else ZMat(n, NBIT_K)
  del e
  
  c = S.less_than_bits_public(rbits, ebits)
  if CP:
    c = -c
    if CP1: c += 1
    c = S.mod(c)

  ep = ZMat(n, NBIT_K + 1)
  if CP:
    for i in range(n):
      ep[i][0] = c[i]
      for j in range(1, NBIT_K + 1):
        ep[i][j] = (1 - 2 * ebits[i][j - 1]) * rbits[i][j - 1]
        if CP1: ep[i][j] += ebits[i][j - 1]
    ep = S.mod(ep)
  del c

  E = S.prefix_or(ep)
  del ep
  
  tpneg = ZMat(n, NBIT_K)
  if CP:
    tpneg = S.mod(ZMat([
      [E[i][j] - rbits[i][j] * (1 - ebits[i][j]) for j in range(NBIT_K)]
      for i in range(n)]))
  Tneg = S.prefix_or(tpneg)
  del E, tpneg

  efir = S.mod(ebits * Tneg) if CP else ZMat(n, NBIT_K)
  rfir = S.mul(rbits, Tneg)
  double_flag = S.less_than_bits(efir, rfir)
  del ebits, rbits, efir, rfir

  half_len = NBIT_K / 2
  odd_bits, even_bits = ZMat(n, half_len), ZMat(n, half_len)
  if CP:
    for i in range(n):
      for j in range(half_len):
        odd_bits[i][j] = 1 - Tneg[i][2*j+1] if CP1 else -Tneg[i][2*j+1]
        even_bits[i][j] = (1 - Tneg[i][2*j+2] if CP1 else -Tneg[i][2*j+2]) \
          if 2 * j + 2 < NBIT_K else 0
    odd_bits, even_bits = S.mod(odd_bits), S.mod(even_bits)
  del Tneg

  odd_bit_sum, even_bit_sum = ZVec(n), ZVec(n)
  for i in range(n):
    odd_bit_sum[i] += sum(odd_bits[i])
    even_bit_sum[i] += sum(even_bits[i])
    if CP0: 
      odd_bit_sum[i] += 1
      even_bit_sum[i] += 1
  odd_bit_sum, even_bit_sum = S.mod(odd_bit_sum), S.mod(even_bit_sum)
  del odd_bits, even_bits

  # If double_flag = true, then use odd_bits, otherwise use even_bits
  diff = S.mod(odd_bit_sum - even_bit_sum) if CP else ZVec(n)
  diff = S.mul(double_flag, diff)
  del double_flag

  chosen_bit_sum = S.mod(even_bits_sum + diff) if CP else ZVec(n)
  del odd_bit_sum, even_bit_sum, diff
  b_mat = S.table_lookup(chosen_bit_sum, 1)
  return b_mat[1], b_mat[0] if CP else ZVec(n), ZVec(n)

def beaver_partition[`t](self: MPCEnv, a: `t) -> tuple[`t, `t]:
  """Protocol 8: BeaverPartition (p.11) """
  if CP0:
    # essentially sum of 2 random numbers...
    am = self.rand_at[`t](1, a) + self.rand_at[`t](2, a)
    return (`t(len(am)), am)
  else:
    am = self.rand_at[`t](0, a)
    ar = a - am
    ar = self.reveal(ar)
    return (ar, am)

# same for inner, pass __mul__; otherwise... pass __matmul__
def beaver_mult[`t](self: MPCEnv, ar: `t, am: `t, br: `t, bm: `t, mul):
  """Protocol 9: part of EvaluatePolynomial (p.12)"""
  if CP0:
    return S.mod(mul(am, bm))
  elif CP1:
    return S.mod(mul(ar, bm) + mul(am, br) + mul(ar, br))
  elif CP2:
    return S.mod(mul(ar, bm) + mul(am, br))

def beaver_reconstruct[`t](self: MPCEnv, ab: `t) -> `t:
  """Protocol 9: part of EvaluatePolynomial (p.12)"""
  if CP0:
    mask = self.rand_at[`t](1, ab)
    ab = S.mod(ab - mask)
    self.send(2, ab)
    return ab
  elif CP1:
    ambm = self.rand_at[`t](0, ab)
    return S.mod(ab + ambm)
  elif CP2:
    ambm = self.receive[`t](0, ab)
    return S.mod(ab + ambm)
 

def beaver_flip[`t](a: Vec[`t], a_mask: Vec[`t]) -> tuple[Vec[`t], Vec[`t]]:
  if CP:
    return -a + 1, -a_mask
  else:
    return a, -a_mask
  

################################################################################

# Vec[] -> Mat[t] ... should be for ZZ as well
def powers(a: Vec[`t], pow: int) -> Mat[`t]:
  n = len(a)
  if pow == 1:
    b = Mat[`t](2, n)
    if CP:
      if CP1: S.add_scalar(b[0], `t(1))
      b[1] = a
    return b
  else:
    ar, am = BP(a)
    if CP0:
      ampow = am * am
      for p in range(1, ampow.rows):
        ampow[p] = S.mod(ampow[p - 1] * am)
      
      self.switch_seed(1)
      ampow = S.mod(ampow - self.random(ampow))
      self.restore_seed()
      self.send(2, ampow)
      return Mat[`t](pow + 1, n)
    else:
      ampow = Mat[`t](pow - 1, n)
      ampow = self.rand_at(0, ampow) if CP1 else self.receive(0, ampow)
      arpow = ar * ar
      for p in range(1, ampow.rows):
        arpow[p] = S.mod(arpow[p - 1] * ar)
      t = S.get_pascal_matrix(pow)

      b = Mat[`t](pow + 1, n)
      if CP1: S.add_scalar(b[0], `t(1))
      b[1] = a
      for p in range(2, pow + 1):
        if CP1: 
          b[p] = arpow[p - 2]
        if CP2:
          b[p] += t[p][1] * (ar * am)
        else:
          b[p] += t[p][1] * (arpow[p - 3] * am)
          for j in range(2, p - 1):
            b[p] += t[p][j] * (arpow[p - 2 - j] * ampow[j - 2])
          b[p] += t[p][p - 1] * (ar * ampow[p - 3])
        b[p] += ampow[p - 2]
      return S.mod(b)

def evaluate_poly[`t](a: Vec[`t], coeff: Mat[`t]) -> Mat[`t]:
  n, npoly, deg = len(a), coeff.rows, coeff.cols - 1
  apow = S.powers(a, deg)
  if CP: 
    return S.mod(coeff * apow)
  else:
    return Mat[`t](npoly, n)

def reveal[`t](a: `t) -> `t:
"""Protocol 2: ReconstructSecret (p.8)"""
  next_cp = 3 - __cp__
  if CP0:
    return `t(len(a))
  elif CP1:
    self.send(next_cp, a)
    b = self.receive(next_cp, a)
    return S.mod(a + b)
  elif CP2:
    b = self.receive(next_cp, a)
    self.send(next_cp, a)
    return S.mod(a + b)

def add_public(x, y):
  if CP1: return x + y
  else: return x

def add(x: `t, y: `t) -> `t:
  return x + y

def mul_public(x, y):
  return x.sh * y

def mul[`t, `u](a: `t, b: `u):
  ar, am = BP(a.sh)
  br, bm = BP(b.sh)
  c = BM(ar, am, br, bm, `t.__mul__)
  return BR(c)

def matmul[`t, `u](a: `t, b: `u):
  ar, am = BP(a.sh)
  br, bm = BP(b.sh)
  c = BM(ar, am, br, bm, `t.__matmul__)
  return BR(c)

#################

def reshape[`t](a: `t) -> Mat[`t]:
  return Mat([[a]])
def reshape[`t](a: Mat[`t]) -> Vec[`t]:
  # diagonal
  if CP:
    return Vec([[c for c in r] for r in a])
  else:
    return Vec[`t](a.rows, a.cols)
def reshape(a: Mat[`t], nrows: int, ncols: int):
  if CP0:
    assert a.rows * a.cols == nrows * ncols
    a.setDim(nrows, ncols)
  else:
    a.reshape(nrows, ncols)
def reshape[`t](a: Vec[`t], nrows, ncols) -> Mat[`t]:
  if CP0:
    assert len(a) == nrows * ncols
    return Mat[`t](nrows, ncols)
  else:
    return Mat([[a[r * ncols + c] for c in range(ncols)] for r in range(nrows)])

def transpose(a: Mat[`t]):
  if CP0:
    return Mat[`t](a.cols, a.rows)
  else:
    return Mat([[a[r][c] for r in range(a.rows)] for c in range(a.cols)])
# TODO!
def inverse(a: Mat[`t]):
  assert False

def num_to_bits[`t](a: Vec, bitlen: int) -> Mat[`t]:
  return Mat([
    [bit(rep(el), bitlen - 1 - j) for c in range(bitlen)] 
    for el in a])

def rand_mat_bits(nr: int, nc: int, bitlen: int) -> ZMat:
  return ZMat([[ZZ.rand_bits(bitlen) for j in range(nc)] for i in range(nr)])
def rand_vec_bits(n: int, bitlen: int) -> ZVec:
  return ZVec([ZZ.rand_bits(bitlen) for j in range(n)])

# DEF: Caching!
def pascal_matrix[`t](pow: int) -> Mat[`t]:
  t = Mat[`t](pow + 1, pow + 1)
  for i in range(pow + 1):
    for j in range(pow + 1):
      if j < i: t[i][j] = 0
      elif j == 0 or j == i: t[i][j] = 1
      else:
        t[i][j] = S.mod(t[i - 1][j - 1] + t[i - 1][j])
  return r

def lagrange_interpolation(x: Vec[int], y: Vec[`t]) -> Vec[`t]:
  n = len(y)
  inv_table = dict[int, `t]()
  for i in range(n):
    for j in range(n):
      if i == j: continue
      key = abs(x[i] - x[j])
      if key not in inv_table:
        inv_table[key] = `t(key).inverse()

  numer = Mat([y if i == 0 else Vec[`t](n, 0) for i in range(n)])
  denom_inv = Vec[`t](n, 1)
  for i in range(n):
    for j in range(n):
      if i == j: continue
      for k in range(n - 1, -1, -1):
        numer[k][j] = S.mod(
          (`t(0) if k == 0 else numer[k - 1][j]) - x[i] * numer[k][j])
      denom_inv[i] = S.mod(
        denom_inv[i] * (1 if x[i] > x[j] else -1) * inv_table[abs(x[i] - x[j])])
  return S.mod(numer @ denom_inv)  
  
def lagrange_interpolation_simple(y: ZVec) -> Vec[`t]:
  return lagrange_interpolation(Vec(list(range(1, n + 1))), y)

