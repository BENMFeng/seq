
class ZZ(p: ptr[byte]):
    def __init__(self: ZZ, p: ptr[byte]):
        self.p = p
    def __init__(self: ZZ, v: int):
        extern c ZZ_init(int) -> ptr[byte]
        self.p = ZZ_init(v)
    def __del__(self: ZZ):
        extern c ZZ_free(ptr[byte])
        ZZ_free(self.p)

    def __add__(a: ZZ, b: ZZ):
        extern c ZZ_O_add(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_add(a.p, b.p))
    def __sub__(a: ZZ, b: ZZ):
        extern c ZZ_O_sub(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_sub(a.p, b.p))
    def __mul__(a: ZZ, b: ZZ):
        extern c ZZ_O_mul(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_mul(a.p, b.p))
    def __div__(a: ZZ, b: ZZ):
        extern c ZZ_O_truediv(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_truediv(a.p, b.p))
    def __mod__(a: ZZ, b: ZZ):
        extern c ZZ_O_mod(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_mod(a.p, b.p))

    def __eq__(a: ZZ, b: ZZ):
        extern c ZZ_O_eq(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_eq(a.p, b.p)
    def __ne__(a: ZZ, b: ZZ):
        extern c ZZ_O_ne(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_ne(a.p, b.p)
    def __lt__(a: ZZ, b: ZZ):
        extern c ZZ_O_lt(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_lt(a.p, b.p)
    def __le__(a: ZZ, b: ZZ):
        extern c ZZ_O_le(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_le(a.p, b.p)
    def __gt__(a: ZZ, b: ZZ):
        extern c ZZ_O_gt(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_gt(a.p, b.p)
    def __ge__(a: ZZ, b: ZZ):
        extern c ZZ_O_ge(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_ge(a.p, b.p)

    def __str__(a: ZZ):
        extern c ZZ_O_str(ptr[byte]) -> ptr[byte]
        extern c strlen(ptr[byte]) -> int
        p = ZZ_O_str(a.p)
        return str(p, strlen(p))

    def zz_p(x: ZZ) -> ZZ_p:
        extern c ZZ_to_ZZ_p(ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_to_ZZ_p(x.p))

    def bytes(zz: ZZ, buf: ptr[byte], n: int):
        extern c ZZ_ToBytes(ptr[byte], ptr[byte], int)
        ZZ_ToBytes(zz.p, buf, n)

    def from_bytes(buf: ptr[byte], n: int):
        extern c ZZ_FromBytes(ptr[byte], int) -> ptr[byte]
        return ZZ(ZZ_FromBytes(buf, n))

class ZZ_p(p: ptr[byte]):
    def __init__(self: ZZ_p):
        extern c ZZ_p_init(int) -> ptr[byte]
        self.p = ZZ_p_init(0)
    def __init__(self: ZZ_p, p: ptr[byte]):
        self.p = p
    def __init__(self: ZZ_p, v: int):
        extern c ZZ_p_init(int) -> ptr[byte]
        self.p = ZZ_p_init(v)
    def __del__(self: ZZ_p):
        extern c ZZ_p_free(ptr[byte])
        ZZ_p_free(self.p)
    def __copy__(self: ZZ_p):
        extern c ZZ_p_copy(ptr[byte]) -> ptr[byte]
        return ZZ_p(self.p)

    def __add__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_add(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_add(a.p, b.p))
    def __sub__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_sub(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_sub(a.p, b.p))
    def __mul__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_mul(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_mul(a.p, b.p))
    def __div__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_truediv(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_truediv(a.p, b.p))

    def __eq__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_eq(ptr[byte], ptr[byte]) -> bool
        return ZZ_p_O_eq(a.p, b.p)
    def __ne__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_ne(ptr[byte], ptr[byte]) -> bool
        return ZZ_p_O_ne(a.p, b.p)

    def __str__(a: ZZ_p):
        extern c ZZ_p_O_str(ptr[byte]) -> ptr[byte]
        extern c strlen(ptr[byte]) -> int
        p = ZZ_p_O_str(a.p)
        return str(p, strlen(p))

    def __len__(self: ZZ_p) -> int:
        return 0

    def init(a: ZZ):
        extern c ZZ_p_init_p(ptr[byte])
        ZZ_p_init_p(a.p)

    def modulus():
        extern c ZZ_p_modulus() -> ptr[byte]
        return ZZ(ZZ_p_modulus())

    def random(sz: int):
        extern c ZZ_p_rand() -> ptr[byte]
        return ZZ_p(ZZ_p_rand())

    def zz(x: ZZ_p) -> ZZ:
        extern c ZZ_p_to_ZZ(ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_p_to_ZZ(x.p))


class Vec(items: list[ZZ_p]):
    def __add__(a: Vec, b: Vec):
        return Vec([i + j for i, j in zip(a.items, b.items)])
    def __sub__(a: Vec, b: Vec):
        return Vec([i - j for i, j in zip(a.items, b.items)])
    def __mul__(a: Vec, b: Vec):
        return Vec([i * j for i, j in zip(a.items, b.items)])
    def __div__(a: Vec, b: Vec):
        return Vec([i / j for i, j in zip(a.items, b.items)])

    def __eq__(a: Vec, b: Vec):
        if len(a) == len(b):
            for i in len(a):
                if a.items[i] != b.items[i]:
                    return False
            return True
        else: 
            return False
        return Vec([i + j for i, j in zip(a.items, b.items)])
    def __ne__(a: Vec, b: Vec):
        return not a.__eq__(b)

    def __str__(a: Vec):
        return a.items.__str__()
    
    def __len__(self: Vec) -> int:
        return self.items.__len__()

    def __copy__(self: Vec):
        return self.items.__copy__()

    def random(sz: int):
        return Vec([ZZ_p.random(0) for i in range(sz)])

