
extern c free(ptr[byte])
extern c strlen(ptr[byte]) -> int

class ZZ(p: ptr[byte]):
    def __init__(self: ZZ, p: ptr[byte]):
        self.p = p
    def __init__(self: ZZ, v: int):
        extern c ZZ_init(int) -> ptr[byte]
        self.p = ZZ_init(v)
    def __del__(self: ZZ):
        extern c ZZ_free(ptr[byte])
        ZZ_free(self.p)

    def __add__(a: ZZ, b: ZZ):
        extern c ZZ_O_add(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_add(a.p, b.p))
    def __sub__(a: ZZ, b: ZZ):
        extern c ZZ_O_sub(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_sub(a.p, b.p))
    def __mul__(a: ZZ, b: ZZ):
        extern c ZZ_O_mul(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_mul(a.p, b.p))
    def __div__(a: ZZ, b: ZZ):
        extern c ZZ_O_truediv(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_truediv(a.p, b.p))
    def __mod__(a: ZZ, b: ZZ):
        extern c ZZ_O_mod(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_mod(a.p, b.p))

    def __eq__(a: ZZ, b: ZZ):
        extern c ZZ_O_eq(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_eq(a.p, b.p)
    def __ne__(a: ZZ, b: ZZ):
        extern c ZZ_O_ne(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_ne(a.p, b.p)
    def __lt__(a: ZZ, b: ZZ):
        extern c ZZ_O_lt(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_lt(a.p, b.p)
    def __le__(a: ZZ, b: ZZ):
        extern c ZZ_O_le(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_le(a.p, b.p)
    def __gt__(a: ZZ, b: ZZ):
        extern c ZZ_O_gt(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_gt(a.p, b.p)
    def __ge__(a: ZZ, b: ZZ):
        extern c ZZ_O_ge(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_ge(a.p, b.p)

    def __str__(a: ZZ):
        extern c ZZ_O_str(ptr[byte]) -> ptr[byte]
        extern c strlen(ptr[byte]) -> int
        p = ZZ_O_str(a.p)
        return str(p, strlen(p))

class ZZ_p(p: ptr[byte]):
    def __init__(self: ZZ_p):
        extern c ZZ_p_init(int) -> ptr[byte]
        self.p = ZZ_p_init(0)
    def __init__(self: ZZ_p, p: ptr[byte]):
        self.p = p
    def __init__(self: ZZ_p, v: int):
        extern c ZZ_p_init(int) -> ptr[byte]
        self.p = ZZ_p_init(v)
    def __del__(self: ZZ_p):
        extern c ZZ_p_free(ptr[byte])
        ZZ_p_free(self.p)
    def __copy__(self: ZZ_p):
        extern c ZZ_p_copy(ptr[byte]) -> ptr[byte]
        # return ZZ_p(ZZ_p_copy(self.p))
        return ZZ_p(self.p)

    def __add__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_add(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_add(a.p, b.p))
    def __sub__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_sub(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_sub(a.p, b.p))
    def __mul__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_mul(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_mul(a.p, b.p))
    def __div__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_truediv(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ_p(ZZ_p_O_truediv(a.p, b.p))

    def __eq__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_eq(ptr[byte], ptr[byte]) -> bool
        return ZZ_p_O_eq(a.p, b.p)
    def __ne__(a: ZZ_p, b: ZZ_p):
        extern c ZZ_p_O_ne(ptr[byte], ptr[byte]) -> bool
        return ZZ_p_O_ne(a.p, b.p)

    def __str__(a: ZZ_p):
        extern c ZZ_p_O_str(ptr[byte]) -> ptr[byte]
        extern c strlen(ptr[byte]) -> int
        p = ZZ_p_O_str(a.p)
        return str(p, strlen(p))

    def init(a: ZZ):
        extern c ZZ_p_init_p(ptr[byte])
        ZZ_p_init_p(a.p)
    def modulus():
        extern c ZZ_p_modulus() -> ptr[byte]
        return ZZ(ZZ_p_modulus())

    def random():
        extern c ZZ_p_rand() -> ptr[byte]
        return ZZ_p(ZZ_p_rand())

def zz2zzp(x: ZZ):
    extern c ZZ_to_ZZ_p(ptr[byte]) -> ptr[byte]
    return ZZ_p(ZZ_to_ZZ_p(x.p))

def zzp2zz(x: ZZ_p):
    extern c ZZ_p_to_ZZ(ptr[byte]) -> ptr[byte]
    return ZZ(ZZ_p_to_ZZ(x.p))

