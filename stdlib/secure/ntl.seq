from secure.socket import Socket

class ModInt(p: ptr[byte]):
    def __init__(self: ModInt):
        extern c ZZ_p_init(int) -> ptr[byte]
        self.p = ZZ_p_init(0)
    def __init__(self: ModInt, p: ptr[byte]):
        self.p = p
    def __init__(self: ModInt, v: int):
        extern c ZZ_p_init(int) -> ptr[byte]
        self.p = ZZ_p_init(v)
    def __del__(self: ModInt):
        extern c ZZ_p_free(ptr[byte])
        ZZ_p_free(self.p)
    def __copy__(self: ModInt):
        extern c ZZ_p_copy(ptr[byte]) -> ptr[byte]
        return ModInt(self.p)

    def __add__(a: ModInt, b: ModInt):
        extern c ZZ_p_O_add(ptr[byte], ptr[byte]) -> ptr[byte]
        return ModInt(ZZ_p_O_add(a.p, b.p))
    def __sub__(a: ModInt, b: ModInt):
        extern c ZZ_p_O_sub(ptr[byte], ptr[byte]) -> ptr[byte]
        return ModInt(ZZ_p_O_sub(a.p, b.p))
    def __mul__(a: ModInt, b: ModInt):
        extern c ZZ_p_O_mul(ptr[byte], ptr[byte]) -> ptr[byte]
        return ModInt(ZZ_p_O_mul(a.p, b.p))
    def __div__(a: ModInt, b: ModInt):
        extern c ZZ_p_O_truediv(ptr[byte], ptr[byte]) -> ptr[byte]
        return ModInt(ZZ_p_O_truediv(a.p, b.p))

    def __eq__(a: ModInt, b: ModInt):
        extern c ZZ_p_O_eq(ptr[byte], ptr[byte]) -> bool
        return ZZ_p_O_eq(a.p, b.p)
    def __ne__(a: ModInt, b: ModInt):
        extern c ZZ_p_O_ne(ptr[byte], ptr[byte]) -> bool
        return ZZ_p_O_ne(a.p, b.p)

    def __str__(a: ModInt):
        extern c ZZ_p_O_str(ptr[byte]) -> ptr[byte]
        extern c strlen(ptr[byte]) -> int
        p = ZZ_p_O_str(a.p)
        return str(p, strlen(p))

    def __len__(self: ModInt) -> int:
        return 0

    #@static
    def modulus():
        extern c ZZ_p_modulus() -> ptr[byte]
        return ZZ(ZZ_p_modulus())

    #@static
    def random(sz: int):
        extern c ZZ_p_rand() -> ptr[byte]
        return ModInt(ZZ_p_rand())

    def to_bytes(self: ModInt, buf: ptr[byte], n: int):
        extern c ZZ_ToBytes(ptr[byte], ptr[byte], int)
        extern c ZZ_p_to_ZZ(ptr[byte]) -> ptr[byte]
        ZZ_ToBytes(ZZ_p_to_ZZ(self.p), buf, n)

    #@static
    def from_bytes(buf: ptr[byte], n: int) -> ModInt:
        extern c ZZ_FromBytes(ptr[byte], int) -> ptr[byte]
        extern c ZZ_to_ZZ_p(ptr[byte]) -> ptr[byte]
        return ModInt(ZZ_to_ZZ_p(ZZ_FromBytes(buf, n)))

    def send(self: ModInt, s: Socket, buf: ptr[byte], bytes: int, per_buf: int):
        self.to_bytes(buf, bytes)
        s.send_secure(buf, bytes, 0)

    def receive(sz: int, s: Socket, buf: ptr[byte], bytes: int, per_buf: int) -> ModInt:
        s.receive_secure(buf, bytes, 0)
        return ModInt.from_bytes(buf, bytes)


class Vec(items: list[ModInt]):
    def __add__(a: Vec, b: ModInt):
        return Vec([i + b for i in a.items])
    def __sub__(a: Vec, b: ModInt):
        return Vec([i - b for i in a.items])
    def __mul__(a: Vec, b: ModInt):
        return Vec([i * b for i in a.items])
    def __div__(a: Vec, b: ModInt):
        return Vec([i / b for i in a.items])

    def __add__(a: Vec, b: Vec):
        return Vec([i + j for i, j in zip(a.items, b.items)])
    def __sub__(a: Vec, b: Vec):
        return Vec([i - j for i, j in zip(a.items, b.items)])
    def __mul__(a: Vec, b: Vec):
        return sum(i * j for i, j in zip(a.items, b.items))

    def __eq__(a: Vec, b: Vec):
        if len(a) == len(b):
            for i in len(a):
                if a.items[i] != b.items[i]:
                    return False
            return True
        else: 
            return False
    def __ne__(a: Vec, b: Vec):
        return not a.__eq__(b)

    def __str__(self: Vec):
        return self.items.__str__()
    
    def __len__(self: Vec) -> int:
        return self.items.__len__()

    def __copy__(self: Vec):
        return self.items.__copy__()

    def random(sz: int):
        return Vec([ModInt.random(0) for i in range(sz)])

    def send(self: Vec, s: Socket, buf: ptr[byte], bytes: int, per_buf: int):
        stored_in_buf, buf_ptr = 0, buf
        for i in len(self):
            if stored_in_buf == per_buf:
                s.send_secure(buf, stored_in_buf * bytes, 0)
                stored_in_buf, buf_ptr = 0, buf
            self[i].to_bytes(buf_ptr, bytes)
            stored_in_buf += 1
            buf_ptr += bytes
        if stored_in_buf > 0:
            s.send_secure(buf, bytes * stored_in_buf, 0)

    def receive(sz: int, s: Socket, buf: ptr[byte], bytes: int, per_buf: int) -> Vec:
        items = list[ModInt](sz)
        remaining = sz
        stored_in_buf, buf_ptr = 0, buf
        for i in range(sz):
            if stored_in_buf == 0:
                count = remaining if remaining < per_buf else per_buf
                s.receive_secure(buf, count * bytes, 0)
                stored_in_buf += count
                remaining -= count
                buf_ptr = buf
            items[i] = ModInt.from_bytes(buf_ptr, bytes)
            buf_ptr += bytes
            stored_in_buf -= 1  
        return Vec(items)


class Mat(items: list[list[ModInt]]):
    def __add__(a: Mat, b: ModInt):
        return Mat([[c + b for c in r] for r in a.items])
    def __sub__(a: Mat, b: ModInt):
        return Mat([[c - b for c in r] for r in a.items])
    def __mul__(a: Mat, b: ModInt):
        return Mat([[c * b for c in r] for r in a.items])
    def __div__(a: Mat, b: ModInt):
        return Mat([[c / b for c in r] for r in a.items])

    def __add__(a: Mat, b: Mat):
        return Mat([
            [ci + cj for ci, cj in zip(ri, rj)]
            for ri, rj in zip(a.items, b.items)])
    def __sub__(a: Mat, b: Mat):
        return Mat([
            [ci - cj for ci, cj in zip(ri, rj)]
            for ri, rj in zip(a.items, b.items)])

    def __eq__(a: Mat, b: Mat):
        if len(a) == len(b):
            nr, nc = len(a)
            for r in nr:
                for c in nc:
                    if a.items[r][c] != b.items[r][c]:
                        return False
            return True
        else: 
            return False
    def __ne__(a: Mat, b: Mat):
        return not a.__eq__(b)

    def __str__(self: Mat):
        return self.items.__str__()
    
    def __len__(self: Mat) -> tuple[int, int]:
        return (len(self.items), 
            0 if len(self.items) == 0 else len(self.items[0]))

    def __copy__(self: Mat):
        return self.items.__copy__()

    def random(sz: tuple[int, int]):
        nr, nc = sz
        return Mat([
            [ModInt.random(0) for c in range(nc)] 
            for r in range(nr)])

########################################################################

class ZZ(p: ptr[byte]):
    def __init__(self: ZZ, p: ptr[byte]):
        self.p = p
    def __init__(self: ZZ, v: int):
        extern c ZZ_init(int) -> ptr[byte]
        self.p = ZZ_init(v)
    def __del__(self: ZZ):
        extern c ZZ_free(ptr[byte])
        ZZ_free(self.p)

    def __add__(a: ZZ, b: ZZ):
        extern c ZZ_O_add(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_add(a.p, b.p))
    def __sub__(a: ZZ, b: ZZ):
        extern c ZZ_O_sub(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_sub(a.p, b.p))
    def __mul__(a: ZZ, b: ZZ):
        extern c ZZ_O_mul(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_mul(a.p, b.p))
    def __div__(a: ZZ, b: ZZ):
        extern c ZZ_O_truediv(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_truediv(a.p, b.p))
    def __mod__(a: ZZ, b: ZZ):
        extern c ZZ_O_mod(ptr[byte], ptr[byte]) -> ptr[byte]
        return ZZ(ZZ_O_mod(a.p, b.p))

    def __eq__(a: ZZ, b: ZZ):
        extern c ZZ_O_eq(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_eq(a.p, b.p)
    def __ne__(a: ZZ, b: ZZ):
        extern c ZZ_O_ne(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_ne(a.p, b.p)
    def __lt__(a: ZZ, b: ZZ):
        extern c ZZ_O_lt(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_lt(a.p, b.p)
    def __le__(a: ZZ, b: ZZ):
        extern c ZZ_O_le(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_le(a.p, b.p)
    def __gt__(a: ZZ, b: ZZ):
        extern c ZZ_O_gt(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_gt(a.p, b.p)
    def __ge__(a: ZZ, b: ZZ):
        extern c ZZ_O_ge(ptr[byte], ptr[byte]) -> bool
        return ZZ_O_ge(a.p, b.p)

    def __str__(a: ZZ):
        extern c ZZ_O_str(ptr[byte]) -> ptr[byte]
        extern c strlen(ptr[byte]) -> int
        p = ZZ_O_str(a.p)
        return str(p, strlen(p))

    def zz_p(x: ZZ) -> ModInt:
        extern c ZZ_to_ZZ_p(ptr[byte]) -> ptr[byte]
        return ModInt(ZZ_to_ZZ_p(x.p))
