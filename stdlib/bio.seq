from file import *
from err import *

extend seq:
    def __init__(self: seq, s: str):
        return seq(s.ptr, s.len)

    def __hash__(self: seq):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def __getitem__(self: seq, idx: int):
        if idx < 0:
            idx += len(self)
        assert 0 <= idx <= len(self)
        return seq(self.ptr + idx, 1)

    def __slice__(self: seq, a: int, b: int):
        if a < 0: a += len(self)
        if b < 0: b += len(self)
        if a > len(self): a = len(self)
        if b > len(self): b = len(self)
        return seq(self.ptr + a, b - a)

    def __slice_left__(self: seq, b: int):
        if b < 0: b += len(self)
        if b > len(self): b = len(self)
        return seq(self.ptr, b)

    def __slice_right__(self: seq, a: int):
        if a < 0: a += len(self)
        if a > len(self): a = len(self)
        return seq(self.ptr + a, len(self) - a)

    def __copy__(self: seq):
        n = self.len
        p = ptr[byte](n)
        str.memcpy(p, self.ptr, n)
        return seq(p, n)

    def split(self: seq, k: int, step: int):
        i = 0
        while i + k <= len(self):
            yield self[i:i+k]
            i += step

    def kmersx[K](self: seq, step: int):
        k = K.len()
        n = len(self)

        if step >= k:
            # naive
            i = 0
            while i + k <= n:
                yield K(self[i:i+k])
                i += step
        elif n >= k:
            # sliding encoding
            kmer = K(self[:k])
            yield kmer
            i = 0
            while i + k + step <= n:
                j = i + k
                kmer <<= self[j:j+step]
                i += step
                yield kmer

    def kmers[K](self: seq, step: int):
        k = K.len()
        n = len(self)
        i = 0
        while i + k <= n:
            sub = self[i:i+k]
            if not sub.N():
                yield K(sub)
            i += step

    def N(self: seq):
        i = 0
        n = len(self)
        while i < n:
            if self[i] == s"N":
                return i + 1
            i += 1
        return 0

    def __invert__(self: seq) -> seq:
        return self.__copy__().revcomp()

    def revcomp(self: seq) -> seq:
        p = self.ptr
        a = 0
        b = self.len - 1
        while a < b:
            p[a], p[b] = p[b].comp(), p[a].comp()
            a += 1
            b -= 1
        return self

def split(self: seq, k: int, step: int):
    return self.split(k, step)

def kmers[K](self: seq, step: int):
    return self.kmers[K](step)

type Seqs(file: File):
    def __init__(self: Seqs, path: str) -> Seqs:
        return (open(path, "r"),)

    def __iter__(self: Seqs):
        for a in self.file._iter():
            yield copy(seq(a.ptr, a.len))
        self.file.close()

type FASTQ(file: File):
    def __init__(self: FASTQ, path: str) -> FASTQ:
        return (open(path, "r"),)

    def __iter__(self: FASTQ):
        line = 0
        for a in self.file._iter():
            if line % 4 == 1:
                yield copy(seq(a.ptr, a.len))
            line += 1
        self.file.close()

type FASTA(file: File, fai: list[int]):
    def __init__(self: FASTA, path: str) -> FASTA:
        cdef atoi(ptr[byte]) -> int
        fai_file = open(path + ".fai", "r")
        fai = list[int]()
        for line in fai_file:
            assert line
            while line[0] != "\t":
                line = line[1:]
            fai.append(atoi(line.ptr))
        fai_file.close()
        return (open(path, "r"), fai)

    def __iter__(self: FASTA):
        idx = 0
        p = ptr[byte]()
        n = 0
        m = 0

        for a in self.file._iter():
            if a[0] == ">":
                if n > 0:
                    assert m == n
                    yield seq(p, n)

                n = self.fai[idx]
                p = ptr[byte](n)
                m = 0
                idx += 1
            else:
                assert m + len(a) <= n
                str.memcpy(p + m, a.ptr, len(a))
                m += len(a)

        if n > 0:
            assert m == n
            yield seq(p, n)

        self.file.close()

def seqs(path: str):
    return iter(Seqs(path))

def fastq(path: str):
    return iter(FASTQ(path))

def fasta(path: str):
    return iter(FASTA(path))

type Block(p: ptr[byte], seq_len: int, num_seqs: int):
    def __iter__(self: Block):
        p, seq_len, num_seqs = self.p, self.seq_len, self.num_seqs
        for i in range(num_seqs):
            yield seq(p + i*seq_len, seq_len)

def _blocks_diff_line_lens():
    raise IOError("all sequences must be of same length for blocking")

def blocks(gg, sz: int):
    buf = ptr[byte]()
    n = l = i = 0
    for s in iter(gg):
        if l == 0:
            l = s.len
            i = 0
            buf = ptr[byte](l * sz)
        if s.len != l:
            _blocks_diff_line_lens()
        str.memcpy(buf + n, s.ptr, l)
        n += l
        i += 1
        if i == sz:
            yield Block(buf, l, i)
            buf = ptr[byte](l * sz)
            n, i = 0, 0
    if i > 0:
        yield Block(buf, l, i)

def block_seqs(name: str, size: int):
    cdef fopen(ptr[byte], ptr[byte]) -> ptr[byte]
    cdef fclose(ptr[byte]) -> int
    cdef getline(ptr[ptr[byte]], n: ptr[int], file: ptr[byte]) -> int
    cdef fgets(ptr[byte], int, ptr[byte]) -> ptr[byte]
    cdef free(ptr[byte])

    fp = fopen(name.c_str(), "r".ptr)

    if not fp:
        raise IOError("file " + name + " could not be opened")

    buf = ptr[byte]()
    sz = 0
    rd = getline(__ptr__(buf), __ptr__(sz), fp)

    if rd != -1:
        if buf[rd - 1] == byte(10):
            rd -= 1

        done = False
        while not done:
            idx = 0
            block = ptr[byte](size*rd + 2)  # one for '\n', one for '\0'
            if buf:
                str.memcpy(block, buf, rd)
                free(buf)
                buf = ptr[byte]()
                idx += 1

            while idx < size:
                off = idx * rd
                p = fgets(block + off, rd + 2, fp)

                if not p:
                    done = True
                    break

                if block[off + rd] != byte(10):
                    _blocks_diff_line_lens()

                idx += 1

            yield Block(block, rd, idx)

    fclose(fp)


# alignment
# adapted from ksw2:
ALIGN_SCORE_NEG_INF = -0x40000000
ALIGN_SCORE_ONLY    = 0x01
ALIGN_RIGHT         = 0x02
ALIGN_GENERIC_SC    = 0x04
ALIGN_APPROX_MAX    = 0x08
ALIGN_EXTZ_ONLY     = 0x40
ALIGN_REV_CIGAR     = 0x80
ALIGN_SPLICE_FOR    = 0x100
ALIGN_SPLICE_REV    = 0x200
ALIGN_SPLICE_FLANK  = 0x400

def _validate_gap(g: int):
    if g < 0 or g >= 128:
        raise ArgumentError("gap penalty for alignment must be in range [0, 127]")

def _validate_match(m: int):
    if m < 0 or m >= 128:
        raise ArgumentError("match/mismatch penalty for alignment must be in range [0, 127]")

type AlignConfig(mat: ptr[Int[8]], gap1: tuple[int,int], gap2: tuple[int,int], bandwidth: int, zdrop: int, flags: int):
    def _gen_mat(a: int, b: int):
        _validate_match(a)
        _validate_match(b)
        m = 5
        mat = ptr[Int[8]](m * m)
        for i in range(m - 1):
            for j in range(m - 1):
                mat[i*m + j] = Int[8](a if i == j else -b)
            mat[i*m + m-1] = Int[8](0)
        for j in range(m):
            mat[(m-1)*m + j] = Int[8](0)
        return mat

    def __init__(self: AlignConfig, match_score: int, mismatch_score: int) -> AlignConfig:
        mat = AlignConfig._gen_mat(match_score, mismatch_score)
        gap1 = (4,2)
        gap2 = (13,1)
        bandwidth = -1
        zdrop = -1
        flags = 0
        return (mat, gap1, gap2, bandwidth, zdrop, flags)

    def gap1(self: AlignConfig, o: int, e: int) -> AlignConfig:
        _validate_gap(o)
        _validate_gap(e)
        mat, gap1, gap2, bandwidth, zdrop, flags = self
        return (mat, (o, e), gap2, bandwidth, zdrop, flags)

    def gap2(self: AlignConfig, o: int, e: int) -> AlignConfig:
        _validate_gap(o)
        _validate_gap(e)
        mat, gap1, gap2, bandwidth, zdrop, flags = self
        return (mat, gap1, (o, e), bandwidth, zdrop, flags)

    def bandwidth(self: AlignConfig, w: int) -> AlignConfig:
        mat, gap1, gap2, bandwidth, zdrop, flags = self
        return (mat, gap1, gap2, w, zdrop, flags)

    def zdrop(self: AlignConfig, z: int) -> AlignConfig:
        mat, gap1, gap2, bandwidth, zdrop, flags = self
        return (mat, gap1, gap2, bandwidth, z, flags)

    def flags(self: AlignConfig, f: int) -> AlignConfig:
        mat, gap1, gap2, bandwidth, zdrop, flags = self
        return (mat, gap1, gap2, bandwidth, zdrop, f)

type CIGAR(value: ptr[UInt[32]], len: int):
    def __init__(self: CIGAR) -> CIGAR:
        return (ptr[UInt[32]](), 0)

    def __len__(self: CIGAR):
        return self.len

    def __getitem__(self: CIGAR, idx: int):
        assert idx < len(self)
        v = self.value[idx]
        return (int(v) >> 4, "MIDNSHP=X"[int(v) & 0xf])

    def __iter__(self: CIGAR):
        for i in range(len(self)):
            yield self[i]

    def __str__(self: CIGAR):
        def op_to_str(op):
            return str(op[0]) + str(op[1])
        return str.cat([op_to_str(op) for op in self])

type Alignment(cigar: CIGAR, score: int):
    def __init__(self: Alignment) -> Alignment:
        return (CIGAR(), 0)

extend seq:
    def align(self: seq, other: seq, config: AlignConfig):
        cdef seq_align(seq, seq, ptr[Int[8]], Int[8], Int[8], int, int, int, ptr[Alignment])
        mat, gap1, gap2, bandwidth, zdrop, flags = config
        out = Alignment()
        seq_align(self, other, mat, Int[8](gap1[0]), Int[8](gap1[1]), bandwidth, zdrop, flags, __ptr__(out))
        return out

    def align_dual(self: seq, other: seq, config: AlignConfig):
        cdef seq_align_dual(seq, seq, ptr[Int[8]], Int[8], Int[8], Int[8], Int[8], int, int, int, ptr[Alignment])
        mat, gap1, gap2, bandwidth, zdrop, flags = config
        out = Alignment()
        seq_align_dual(self, other, mat, Int[8](gap1[0]), Int[8](gap1[1]), Int[8](gap2[0]), Int[8](gap2[1]), bandwidth, zdrop, flags, __ptr__(out))
        return out

    def align_splice(self: seq, other: seq, config: AlignConfig):
        cdef seq_align_splice(seq, seq, ptr[Int[8]], Int[8], Int[8], Int[8], Int[8], int, int, ptr[Alignment])
        mat, gap1, gap2, bandwidth, zdrop, flags = config
        out = Alignment()
        seq_align_splice(self, other, mat, Int[8](gap1[0]), Int[8](gap1[1]), Int[8](gap2[0]), Int[8](gap2[1]), zdrop, flags, __ptr__(out))
        return out

    def align_global(self: seq, other: seq, config: AlignConfig):
        cdef seq_align_global(seq, seq, ptr[Int[8]], Int[8], Int[8], int, ptr[Alignment])
        mat, gap1, gap2, bandwidth, zdrop, flags = config
        out = Alignment()
        seq_align_global(self, other, mat, Int[8](gap1[0]), Int[8](gap1[1]), bandwidth, __ptr__(out))
        return out

    def __matmul__(self: seq, other: seq):
        cdef seq_align_default(seq, seq, ptr[Alignment])
        out = Alignment()
        seq_align_default(self, other, __ptr__(out))
        return out
