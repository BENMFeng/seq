import python as py

class _dict_entry[K,V]:
    k: K
    v: V
    hash: int
    next: _dict_entry[K,V]

    def __init__(self: _dict_entry[K,V], k: K, v: V, hash: int):
        self.k = k
        self.v = v
        self.hash = hash
        self.next = None

    def eq(self: _dict_entry[K,V], k: K, hash: int):
        return self.hash == hash and self.k == k

class dict[K,V]:
    table: array[_dict_entry[K,V]]
    size: int

    def _make_table(len: int):
        table = array[_dict_entry[K,V]](len)
        for i in range(len):
            table[i] = None
        return table

    def _find(self: dict[K,V], k: K, h: int):
        idx = h & (self.table.len - 1)
        e = self.table[idx]
        while e:
            if e.eq(k, h):
                break
            e = e.next
        return e

    def _entry_iter(self: dict[K,V]):
        table = self.table
        for i in range(table.len):
            e = table[i]
            while e:
                n = e.next
                yield e
                e = n

    def _insert(self: dict[K,V], table: array[_dict_entry[K,V]], e: _dict_entry[K,V]):
        idx = e.hash & (table.len - 1)
        e.next = table[idx]
        table[idx] = e

    def _resize(self: dict[K,V]):
        table = dict[K,V]._make_table(2 * self.table.len)
        for e in self._entry_iter():
            self._insert(table, e)
        self.table = table

    def __init__(self: dict[K,V], cap: int):
        cap_actual = 1
        while cap_actual < cap:
            cap_actual *= 2
        self.table = dict[K,V]._make_table(cap_actual)
        self.size = 0

    def __init__(self: dict[K,V]):
        self.table = dict[K,V]._make_table(16)
        self.size = 0

    def get(self: dict[K,V], k: K, s: V):
        e = self._find(k, hash(k))
        return e.v if e else s

    def __contains__(self: dict[K,V], k: K):
        return self._find(k, hash(k)).__bool__()

    def __getitem__(self: dict[K,V], k: K):
        e = self._find(k, hash(k))
        if e:
            return e.v

    def __setitem__(self: dict[K,V], k: K, v: V):
        h = hash(k)
        e = self._find(k, h)
        if e:
            e.v = v
        else:
            if self.size*2 >= self.table.len:
                self._resize()
            self._insert(self.table, _dict_entry[K,V](k, v, h))
            self.size += 1

    def __delitem__(self: dict[K,V], k: K):
        h = hash(k)
        idx = h & (self.table.len - 1)
        e = self.table[idx]
        prev = e  # hacky way to ensure type of `prev` is correct
        prev = None

        while e:
            if e.eq(k, h):
                if prev:
                    prev.next = e.next
                else:
                    self.table[idx] = e.next
                self.size -= 1
                return
            prev = e
            e = e.next

    def __eq__(self: dict[K,V], other: dict[K,V]):
        if len(self) != len(other):
            return False
        for k,v in self.items():
            e = self._find(k, hash(k))
            if not e or v != e.v:
                return False
        return True

    def __ne__(self: dict[K,V], other: dict[K,V]):
        return not (self == other)

    def keys(self: dict[K,V]):
        for e in self._entry_iter():
            yield e.k

    def values(self: dict[K,V]):
        for e in self._entry_iter():
            yield e.v

    def items(self: dict[K,V]):
        for e in self._entry_iter():
            yield (e.k, e.v)

    def iteritems(self: dict[K,V]):
        for i in self._entry_iter():
            yield i.k, i.v

    def __iter__(self: dict[K,V]):
        return self.keys()

    def __len__(self: dict[K,V]):
        return self.size

    def __str__(self: dict[K,V]) -> str:
        n = len(self)
        if n == 0:
            return "{}"
        else:
            lst = list[str]()
            lst.append("{")
            first = True
            for e in self._entry_iter():
                if not first:
                    lst.append(", ")
                else:
                    first = False
                lst.append(str(e.k))
                lst.append(": ")
                lst.append(str(e.v))
            lst.append("}")
            return str.cat(lst)

    def __to_py__(self: dict[K,V]):
        cdef seq_py_dict_new() -> ptr[byte]
        cdef seq_py_dict_setitem(ptr[byte], ptr[byte], ptr[byte])

        pydict = seq_py_dict_new()
        for k,v in self.iteritems():
            seq_py_dict_setitem(pydict, py.py(k).p, py.py(v).p)
        return py.PyObject(pydict)

    def __from_py__(d: py.PyObject):
        cdef seq_py_dict_next(ptr[byte], ptr[int], ptr[ptr[byte]], ptr[ptr[byte]]) -> bool

        b = dict[K,V]()
        pos = 0
        k_ptr = ptr[byte]()
        v_ptr = ptr[byte]()
        while seq_py_dict_next(d.p, __ptr__(pos), __ptr__(k_ptr), __ptr__(v_ptr)):
            k = py.get[K](py.PyObject(k_ptr))
            v = py.get[V](py.PyObject(v_ptr))
            b[k] = v
        return b

    def __pickle__(self: dict[K,V], jar: Jar):
        n = len(self)
        pickle(n, jar)

        cap = len(self.table)
        pickle(cap, jar)

        for k,v in self.items():
            pickle(k, jar)
            pickle(v, jar)

    def __unpickle__(jar: Jar):
        n = unpickle[int](jar)
        cap = unpickle[int](jar)
        d = dict[K,V](cap)
        for i in range(n):
            k = unpickle[K](jar)
            v = unpickle[V](jar)
            d[k] = v
        return d
