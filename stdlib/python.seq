PY_LIB = "/usr/local/Cellar/python/3.7.4_1/Frameworks/Python.framework/Versions/3.7/lib/libpython3.7m.dylib"

from C import dlopen, DLException
try:
    dlopen(PY_LIB)
except DLException:
    PY_LIB = "\0" + PY_LIB

from PY_LIB cimport PyUnicode_AsEncodedString(cobj, cobj, cobj) -> cobj
from PY_LIB cimport PyBytes_AsString(cobj) -> cobj
from PY_LIB cimport PyErr_Fetch(ptr[cobj], ptr[cobj], ptr[cobj])
from PY_LIB cimport PyObject_GetAttrString(cobj, cobj) -> cobj
from PY_LIB cimport PyObject_Str(cobj) -> cobj
from PY_LIB cimport PyRun_SimpleString(cobj)
from PY_LIB cimport Py_IncRef(cobj)
from PY_LIB cimport Py_DecRef(cobj)
from PY_LIB cimport PyObject_CallObject(cobj, cobj) -> cobj
from PY_LIB cimport PyObject_SetAttrString(cobj, cobj, cobj) -> cobj
from PY_LIB cimport PyObject_Length(cobj) -> int
from PY_LIB cimport Py_Initialize()
from PY_LIB cimport PyImport_ImportModule(cobj) -> cobj
from PY_LIB cimport PyLong_FromLong(int) -> cobj
from PY_LIB cimport PyLong_AsLong(cobj) -> int
from PY_LIB cimport PyFloat_FromDouble(float) -> cobj
from PY_LIB cimport PyFloat_AsDouble(cobj) -> float
from PY_LIB cimport PyBool_FromLong(int) -> cobj
from PY_LIB cimport PyObject_IsTrue(cobj) -> int
from PY_LIB cimport PyUnicode_DecodeFSDefaultAndSize(cobj, int) -> cobj
from PY_LIB cimport PyTuple_New(int) -> cobj
from PY_LIB cimport PyTuple_SetItem(cobj, int, cobj)
from PY_LIB cimport PyTuple_GetItem(cobj, int, cobj)
from PY_LIB cimport PyList_New(int) -> cobj
from PY_LIB cimport PyList_SetItem(cobj, int, cobj) -> cobj
from PY_LIB cimport PyList_GetItem(cobj, int) -> cobj
from PY_LIB cimport PySet_New(int) -> cobj
from PY_LIB cimport PySet_Add(cobj, cobj) -> cobj
from PY_LIB cimport PyDict_New(int) -> cobj
from PY_LIB cimport PyDict_SetItem(cobj, cobj, cobj) -> cobj
from PY_LIB cimport PyDict_Next(cobj, ptr[int], ptr[cobj], ptr[cobj]) -> int

class PyException:
    msg: str
    pytype: str

type pyobj(p: ptr[byte]):
    def to_str(self: pyobj, errors: str, empty: str = "") -> str:
        obj = PyUnicode_AsEncodedString(self.p, "utf-8".c_str(), errors.c_str())
        if obj == cobj():
            return empty

        bts = PyBytes_AsString(obj)
        pyobj(obj).decref()
        return str.from_ptr(bts)

    def exc_check():
        ptype, pvalue, ptraceback = cobj(), cobj(), cobj()
        PyErr_Fetch(__ptr__(ptype), __ptr__(pvalue), __ptr__(ptraceback))
        if ptype != cobj():
            py_msg = PyObject_Str(pvalue) if pvalue != cobj() else pvalue
            msg = pyobj(py_msg).to_str("ignore", "<empty Python message>")
            typ = pyobj.to_str(pyobj(PyObject_GetAttrString(ptype, "__name__".c_str())), "ignore")

            pyobj(ptype).decref()
            pyobj(pvalue).decref()
            pyobj(ptraceback).decref()
            pyobj(py_msg).decref()

            raise PyException(msg, typ)

    def exc_wrap(_retval):
        pyobj.exc_check()
        return _retval

    def run(code: str):
        PyRun_SimpleString(code.c_str())

    def incref(self: pyobj):
        Py_IncRef(self.p)

    def decref(self: pyobj):
        Py_DecRef(self.p)

    def call(self: pyobj, args : optional[pyobj] = None):
        args_py = (~args).p if args else cobj()
        return pyobj.exc_wrap(pyobj(PyObject_CallObject(self.p, args_py)))

    def __getitem__(self: pyobj, name: str):
        return pyobj.exc_wrap(pyobj(PyObject_GetAttrString(self.p, name.c_str())))

    def __setitem__(self: pyobj, name: str, val: pyobj):
        return pyobj.exc_wrap(pyobj(PyObject_SetAttrString(self.p, name.c_str(), val.p)))

    def __len__(self: pyobj):
        return pyobj.exc_wrap(PyObject_Length(self.p))

    def __to_py__(self: pyobj):
        return self

def init():
    Py_Initialize()
init()

def import_module(name: str):
    return pyobj.exc_wrap(pyobj(PyImport_ImportModule(name.c_str())))

def none():
    #cimport seq_py_none() -> ptr[byte]
    #return pyobj(seq_py_none())
    raise PyException("not yet done", "n/a")

# conversions

def py(x) -> pyobj:
    return x.__to_py__()

def get[T](x: pyobj) -> T:
    return T.__from_py__(x)

extend int:
    def __to_py__(self: int):
        return pyobj.exc_wrap(pyobj(PyLong_FromLong(self)))

    def __from_py__(i: pyobj):
        return pyobj.exc_wrap(PyLong_AsLong(i.p))

extend float:
    def __to_py__(self: float):
        return pyobj.exc_wrap(pyobj(PyFloat_FromDouble(self)))

    def __from_py__(d: pyobj):
        return pyobj.exc_wrap(PyFloat_AsDouble(d.p))

extend bool:
    def __to_py__(self: bool):
        return pyobj.exc_wrap(pyobj(PyBool_FromLong(self)))

    def __from_py__(b: pyobj):
        return pyobj.exc_wrap(PyObject_IsTrue(b.p)) != 0

extend byte:
    def __to_py__(self: byte):
        return str.__to_py__(str(__ptr__(self), 1))

    def __from_py__(c: pyobj):
        return str.__from_py__(c).p[0]

extend str:
    def __to_py__(self: str):
        return pyobj.exc_wrap(PyUnicode_DecodeFSDefaultAndSize(self.p, self.len))

    def __from_py__(s: pyobj):
        r = s.to_str("strict")
        pyobj.exc_check()
        return r

extend seq:
    def __to_py__(self: seq):
        return str(self).__to_py__()

    def __from_py__(s: pyobj) -> seq:
        return seq(str.__from_py__(s))

def py_tuple_new(len: int) -> pyobj:
    return pyobj.exc_wrap(pyobj(PyTuple_New(len)))

def py_tuple_setitem(obj: pyobj, idx: int, val: pyobj):
    PyTuple_SetItem(obj.p, idx, val.p)
    pyobj.exc_check()

def py_tuple_getitem(obj: pyobj, idx: int) -> pyobj:
    return pyobj.exc_wrap(pyobj(PyTuple_GetItem(obj.p, idx)))

def tuple_to_py(t):
    obj = pyobj.exc_wrap(pyobj(PyTuple_New(len(t))))
    idx = 0
    for i in t:
        val = i.__to_py__()
        PyTuple_SetItem(obj.p, idx, val.p)
        pyobj.exc_check()
        idx += 1
    return obj

def tuple_getitem(self: pyobj, idx: int):
    return pyobj.exc_wrap(pyobj(PyTuple_GetItem(self.p, idx)))
