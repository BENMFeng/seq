""" PDQ Sort """
INSERTION_SORT_THRESHOLD = 24
NINTHER_THRESHOLD = 128
PARTIAL_INSERTION_SORT_LIMIT = 8
BLOCK_SIZE = 64
CACHELINE_SIZE = 64

def _make_heap[T](lst: list[T], begin: int, end: int, comp: function[bool,T,T]):
    root = begin
    l = 2 * begin + 1
    r = 2 * begin + 2

    if l < end and comp(lst[l], lst[root]):
        root = l
    
    if r < end and comp(lst[r], lst[root]):
        root = r
    
    if root != begin:
        lst[begin], lst[root] = lst[root], lst[begin]
        _make_heap(lst, root, end, comp)

def _heap_sort[T](lst: list[T], begin: int, end: int, comp: function[bool,T,T]):
    if end - begin < 2:
        return

    for i in range(end, begin - 1, -1):
        _make_heap(lst, i, end, comp)
    
    for i in range(end - 1, begin, -1):
        lst[i], lst[begin] = lst[begin], lst[i]
        _make_heap(lst, begin, i, comp)

def _insertion_sort[T](lst: list[T], begin: int, end: int, comp):
    i = begin + 1
    while i < end:
        x = lst[i]
        j = i - 1
        while j >= 0 and comp(x, lst[j]):
            lst[j+1] = lst[j]
            j -= 1
        lst[j+1] = x
        i += 1

def _partial_insertion_sort[T](lst: list[T], begin, end, comp):
    if begin == end:
        return True
    
    limit = 0

    cur = begin + 1
    while cur != end:
        cur += 1
        if limit > PARTIAL_INSERTION_SORT_LIMIT:
            return False
        
        sift = cur
        sift_1 = cur - 1

        if comp(lst[sift], lst[sift_1]):
            tmp = lst[sift]

            while True:
                lst[sift] = lst[sift_1]
                sift -= 1
                sift_1 -= 1
                if sift == begin or not comp(tmp, lst[sift_1]):
                    break
                lst[sift] = tmp
                limit += cur - sift
    
    return True

def _swap_list[T](lst: list[T], i: int, j: int):
    lst[i], lst[j] = lst[j], lst[i]

def _sort2[T](lst: list[T], i: int, j: int, comp):
    if comp(lst[j], lst[i]):
        _swap_list(lst, i, j)

def _sort3[T](lst: list[T], i: int, j: int, k: int, comp):
    _sort2(lst, i, j, comp)
    _sort2(lst, j, k, comp)
    _sort2(lst, i, j, comp)

def _floor_log2(n: int) -> int:
    cdef floor(float) -> float
    cdef log2(float) -> float
    return int(floor(log2(float(n))))

def _partition_right[T](lst: list[T], begin: int, end: int, comp) -> tuple[int,int]:
    pivot = lst[begin]
    first = begin
    last = end

    while True:
        first += 1
        if not comp(lst[first], pivot):
            break
    
    if first - 1 == begin:
        while first < last:
            last -= 1
            if comp(lst[last], pivot):
                break
    else:
        while True:
            last -= 1
            if comp(lst[last], pivot):
                break
    
    already_partitioned = 0
    if first >= last:
        already_partitioned = 1
    
    while first < last:
        _swap_list(lst, first, last)
        while True:
            first += 1
            if not comp(lst[first], pivot):
                break
        while True:
            last -= 1
            if comp(lst[last], pivot):
                break
    
    pivot_pos = first - 1
    lst[begin] = lst[pivot_pos]
    lst[pivot_pos] = pivot

    return (pivot_pos, already_partitioned)

def _partition_left[T](lst: list[T], begin: int, end: int, comp) -> int:
    pivot = lst[begin]
    first = begin
    last = end

    while True:
        last -= 1
        if not comp(pivot, lst[last]):
            break
    
    if (last + 1 == end):
        while first < last:
            first += 1
            if comp(pivot, lst[first]):
                break
    else:
        while True:
            first += 1
            if comp(pivot, lst[first]):
                break
    
    while first < last:
        _swap_list(lst, first, last)
        while True:
            last -= 1
            if not comp(pivot, lst[last]):
                break
        while True:
            first += 1
            if comp(pivot, lst[first]):
                break
    
    pivot_pos = last
    lst[begin] = lst[pivot_pos]
    lst[pivot_pos] = pivot

    return pivot_pos


def _pdq_sort[T](lst: list[T], begin: int, end: int, comp, bad_allowed: int, leftmost: bool):
    while True:
        size = end - begin
        if (size < INSERTION_SORT_THRESHOLD):
            _insertion_sort(lst, begin, end, comp)
            return
        
        s2 = int(size / 2)
        if (size > NINTHER_THRESHOLD):
            # Tukey's ninther to select the pivot?
            _sort3(lst, begin, begin + s2, end - 1, comp)
            _sort3(lst, begin + 1, begin + (s2 - 1), end - 2, comp)
            _sort3(lst, begin + 2, begin + (s2 + 1), end - 3, comp)
            _sort3(lst, begin + (s2 - 1), begin + s2, begin + (s2 + 1), comp)
            _swap_list(lst, begin, begin + s2)
        else:
            _sort3(lst, begin + s2, begin, end -1, comp)
        
        if not leftmost and not comp(lst[begin - 1], lst[begin]):
            begin = _partition_left(lst, begin, end, comp) + 1
            continue
        
        part_result = _partition_right(lst, begin, end, comp)
        pivot_pos = part_result[0]
        already_partitioned = part_result[1] == 1

        l_size = pivot_pos - begin
        r_size = end - (pivot_pos + 1)
        highly_unbalanced = (l_size < (size / 8)) or (r_size < (size / 8))

        if (highly_unbalanced):
            bad_allowed -= 1
            if bad_allowed == 0:
                _heap_sort(lst, begin, end, comp)
                return

            if l_size >= INSERTION_SORT_THRESHOLD:
                _swap_list(lst, begin, int(begin + l_size / 4))
                _swap_list(lst, pivot_pos - 1, int(pivot_pos - l_size / 4))

                if l_size > NINTHER_THRESHOLD:
                    _swap_list(lst, begin + 1, int(begin + (l_size / 4 + 1)))
                    _swap_list(lst, begin + 2, int(begin + (l_size / 4 + 2)))
                    _swap_list(lst, pivot_pos - 2, int(pivot_pos - (l_size / 4 + 1)))
                    _swap_list(lst, pivot_pos - 3, int(pivot_pos - (l_size / 4 + 2)))
            
            if r_size >= INSERTION_SORT_THRESHOLD:
                _swap_list(lst, pivot_pos + 1, int(pivot_pos + (1 + r_size / 4)))
                _swap_list(lst, end - 1, int(end - r_size / 4))

                if r_size > NINTHER_THRESHOLD:
                    _swap_list(lst, pivot_pos + 2, int(pivot_pos + (2 + r_size / 4)))
                    _swap_list(lst, pivot_pos + 3, int(pivot_pos + (3 + r_size / 4)))
                    _swap_list(lst, end - 2, int(end - (1 + r_size / 4)))
                    _swap_list(lst, end - 3, int(end - (2 + r_size / 4)))
        
        else:
            if (already_partitioned and _partial_insertion_sort(lst, begin, pivot_pos, comp) and _partial_insertion_sort(lst, pivot_pos + 1, end, comp)):
                return
        
        _pdq_sort(lst, begin, pivot_pos, comp, bad_allowed, leftmost)
        begin = pivot_pos + 1
        leftmost = False

def pdqsort_inplace[T](collection: list[T], compare):
    _pdq_sort(collection, 0, len(collection), compare, _floor_log2(len(collection)), True)

def pdqsort[T](collection: list[T], compare: function[bool,T,T]) -> list[T]:
    """
        Pattern-defeating Quicksort by Orson Peters.
        Published at https://github.com/orlp/pdqsort
    """
    lst = copy(collection)
    if len(lst) == 0:
        return lst
    _pdq_sort(lst, 0, len(lst), compare, _floor_log2(len(lst)), True)
    return lst
