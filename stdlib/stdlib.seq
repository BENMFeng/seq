type range(lo: int, hi: int, step: int):
    def __init__(self: range, lo: int, hi: int, step: int) -> range:
        assert step != 0
        return (lo, hi, step)

    def __init__(self: range, lo: int, hi: int) -> range:
        return (lo, hi, 1)

    def __init__(self: range, hi: int) -> range:
        return (0, hi, 1)

    def __getitem__(self: range, i: int) -> int:
        if i < 0:
            assert self.hi + i >= self.lo
            return self.hi + i

        assert self.lo + i < self.hi
        return self.lo + i

    def __iter__(self: range):
        lo, hi, step = self
        i = lo
        if step > 0:
            while i < hi:
                yield i
                i += step
        else:
            while i > hi:
                yield i
                i += step

    def __len__(self: range):
        l = self.hi - self.lo
        return (l // self.step) + (1 if l % self.step > 0 else 0)

class Box[T]:
    val: T

def min(a, b):
    return a if a < b else b

def max(a, b):
    return a if a > b else b

def len(x):
    return x.__len__()

def iter(x):
    return x.__iter__()

def copy(x):
    return x.__copy__()

def abs(x):
    return x.__abs__()

def hash(x):
    return x.__hash__()

def ord(s: str):
    return int(s.ptr[0])

def chr(i: int):
    p = ptr[byte](1)
    p[0] = byte(i)
    return str(p, 1)

def next(g):
    g.done()
    return g.next()

def any(x):
    for a in x:
        if a:
            return True
    return False

def all(x):
    for a in x:
        if not a:
            return False
    return True

def enum(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def zip(a, b):
    bi = iter(b)
    for i in a:
        if bi.done(): break
        yield (i, bi.next())

def filter(f, x):
    for a in x:
        if f(a):
            yield a

def map(f, x):
    for a in x:
        yield f(a)

def enumerate(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def echo(x):
    print x
    return x

def reversed(x):
    i = len(x)
    while i > 0:
        i -= 1
        yield x[i]

def round(x, n) -> float:
    cdef round(float) -> float
    cdef pow(float, float) -> float
    n := pow(10.0, float(n))
    return round(float(x * n)) / n

def sum(xi):
    x = iter(xi)
    if not x.done():
        s = x.next()
        while not x.done():
            s += x.next()
        x.destroy()
        return s
    else:
        x.destroy()

extend int:
    def __pow__(self: int, exp: int):
        result = 1
        while True:
            if exp & 1:
                result *= self
            exp >>= 1
            if not exp:
                break
            self *= self
        return result

    def __pow__(self: int, exp: float):
        return float(self) ** exp

    def __init__(self: int, s: str):
        cdef atoi(p: ptr[byte]) -> int
        return atoi(s.c_str())

import! list
import! dict
import! set

def sorted_cmp[T](xi: list[T], cmp):
    x = copy(xi)
    for i in range(0, len(x)):
        for j in range(i + 1, len(x)):
            if cmp(x[j], x[i]):
                x[j], x[i] = x[i], x[j]
    return x

def sorted[T](x: list[T]):
    def cmp(x: T, y: T):
        return x < y
    return sorted_cmp(x, cmp)

extend str:
    def __hash__(self: str):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def __add__(self: str, other: str):
        len1 = self.len
        len2 = other.len
        len3 = len1 + len2
        p = ptr[byte](len3)
        str.memcpy(p, self.ptr, len1)
        str.memcpy(p + len1, other.ptr, len2)
        return str(p, len3)

    def __getitem__(self: str, idx: int):
        if idx < 0:
            idx += len(self)
        assert 0 <= idx <= len(self)
        return str(self.ptr + idx, 1)

    def __slice__(self: str, a: int, b: int):
        if a < 0: a += len(self)
        if b < 0: b += len(self)
        if a > len(self): a = len(self)
        if b > len(self): b = len(self)
        assert 0 <= a <= b <= len(self)
        return str(self.ptr + a, b - a)

    def __slice_left__(self: str, b: int):
        if b < 0: b += len(self)
        if b > len(self): b = len(self)
        return str(self.ptr, b)

    def __slice_right__(self: str, a: int):
        if a < 0: a += len(self)
        if a > len(self): a = len(self)
        return str(self.ptr + a, len(self) - a)

    def c_str(self: str):
        n = len(self)
        assert n >= 0
        p = ptr[byte](n + 1)
        str.memcpy(p, self.ptr, n)
        p[n] = byte(0)
        return p

    def __iter__(self: str):
        n = len(self)
        for i in range(n):
            yield self[i]

    def __mul__(self: str, x: int):
        total = x * self.len
        p = ptr[byte](total)
        n = 0
        for _ in range(x):
            str.memcpy(p + n, self.ptr, self.len)
            n += self.len
        return str(p, total)

    def __copy__(self: str):
        n = len(self)
        p = ptr[byte](n)
        str.memcpy(p, self.ptr, n)
        return str(p, n)

    def cat(v: list[str]):
        total = 0
        for s in v:
            total += len(s)
        p = ptr[byte](total)
        n = 0
        for s in v:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)

    def cati(v: generator[str], total: int):
        p = ptr[byte](total)
        n = 0
        for s in v:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)

    def join(self: str, l: list[str]):
        if self == "":
            return str.cat(l)
        assert False

    def _isspace(b: byte):
        return b == byte(32) or b == byte(9) or b == byte(10) or \
               b == byte(11) or b == byte(12) or b == byte(13)

    def lstrip(self: str):
        i = 0
        while i < self.len:
            if not str._isspace(self.ptr[i]):
                break
            i += 1
        return str(self.ptr + i, self.len - i)

    def rstrip(self: str):
        i = self.len - 1
        while i >= 0:
            if not str._isspace(self.ptr[i]):
                break
            i -= 1
        return '' if i < 0 else str(self.ptr, i + 1)

    def strip(self: str):
        return self.lstrip().rstrip()

    def split(self: str, pat: str):
        if len(pat) == 0:
            for i in self: yield i
        elif len(pat) == 1:
            prev = 0
            for i, s in enumerate(self):
                if s == pat[0]:
                    yield self[prev:i]
                    prev = i + 1
            yield self[prev:len(self)]
        else:
            i, l = 0, len(pat)
            prev = 0
            while i < len(self) - l + 1:
                if self[i:i + l] == pat:
                    yield self[prev:i]
                    prev = i + l
                    i += l
                else:
                    i += 1
            yield self[prev:len(self)]

type i8  = Int[8]
type i16 = Int[16]
type i32 = Int[32]
type i64 = Int[64]
type u8  = UInt[8]
type u16 = UInt[16]
type u32 = UInt[32]
type u64 = UInt[64]

import! bio
