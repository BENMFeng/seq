type range(lo: int, hi: int, step: int):
    def __init__(self: range, lo: int, hi: int, step: int) -> range:
        assert step != 0
        return (lo, hi, step)

    def __init__(self: range, lo: int, hi: int) -> range:
        return (lo, hi, 1)

    def __init__(self: range, hi: int) -> range:
        return (0, hi, 1)

    def __getitem__(self: range, i: int) -> int:
        if i < 0:
            assert self.hi + i >= self.lo
            return self.hi + i

        assert self.lo + i < self.hi
        return self.lo + i

    def __iter__(self: range):
        lo, hi, step = self
        i = lo
        if step > 0:
            while i < hi:
                yield i
                i += step
        else:
            while i > hi:
                yield i
                i += step

def min(a, b):
    return a if a < b else b

def max(a, b):
    return a if a > b else b

def len(x):
    return x.__len__()

def iter(x):
    return x.__iter__()

def copy(x):
    return x.__copy__()

def abs(x):
    return x.__abs__()

def hash(x):
    return x.__hash__()

def any(x):
    for a in x:
        if a:
            return True
    return False

def all(x):
    for a in x:
        if not a:
            return False
    return True

def enum(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def zip(a, b):
    bi = iter(b)
    for i in a:
        if bi.done(): break
        yield (i, bi.next())

def filter(f, x):
    for a in x:
        if f(a):
            yield a

def map(f, x):
    for a in x:
        yield f(a)

def enumerate(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def echo(x):
    print x
    return x

def reversed(x):
    i = len(x)
    while i > 0:
        i -= 1
        yield x[i]

def round(x, n) -> float:
    cdef round(float) -> float
    cdef pow(float, float) -> float
    n := pow(10.0, float(n))
    return round(float(x * n)) / n

def sum(xi):
    x = iter(xi)
    if not x.done():
        s = x.next()
        while not x.done():
            s += x.next()
        x.destroy()
        return s
    else:
        x.destroy()

import! list
import! dict
import! set

def sorted_cmp[T](xi: list[T], cmp):
    x = copy(xi)
    for i in range(0, len(x)):
        for j in range(i + 1, len(x)):
            if cmp(x[j], x[i]):
                x[j], x[i] = x[i], x[j]
    return x

def sorted[T](x: list[T]):
    def cmp(x: T, y: T):
        return x < y
    return sorted_cmp(x, cmp)

extend int:
    def __pow__(self: int, exp: int):
        result = 1
        while True:
            if exp & 1:
                result *= self
            exp >>= 1
            if not exp:
                break
            self *= self
        return result

    def __pow__(self: int, exp: float):
        return float(self) ** exp

    def __init__(self: int, s: str) -> int:
        cdef atoi(p: ptr[byte]) -> int
        return atoi(s.ptr)

extend str:
    def __hash__(self: str):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def __add__(self: str, other: str):
        len1 = self.len
        len2 = other.len
        len3 = len1 + len2
        p = ptr[byte](len3)
        str.memcpy(p, self.ptr, len1)
        str.memcpy(p + len1, other.ptr, len2)
        return str(p, len3)

    def __getitem__(self: str, idx: int):
        if idx < 0:
            idx += len(self)
        assert 0 <= idx <= len(self)
        return str(self.ptr + idx, 1)

    def __slice__(self: str, a: int, b: int):
        if a < 0: a += len(self)
        if b < 0: b += len(self)
        if a > len(self): a = len(self)
        if b > len(self): b = len(self)
        assert 0 <= a <= b <= len(self)
        return str(self.ptr + a, b - a)

    def __slice_left__(self: str, b: int):
        if b < 0: b += len(self)
        if b > len(self): b = len(self)
        return str(self.ptr, b)

    def __slice_right__(self: str, a: int):
        if a < 0: a += len(self)
        if a > len(self): a = len(self)
        return str(self.ptr + a, len(self) - a)

    def c_str(self: str):
        n = len(self)
        assert n >= 0
        p = ptr[byte](n + 1)
        for i in range(n):
            p[i] = self.ptr[i]
        p[n] = byte(0)
        return p

    def __iter__(self: str):
        n = len(self)
        for i in range(n):
            yield self[i]

    def __mul__(self: str, x: int):
        total = x * self.len
        p = ptr[byte](total)
        n = 0
        for _ in range(x):
            str.memcpy(p + n, self.ptr, self.len)
            n += self.len
        return str(p, total)

    def cat(v: list[str]):
        total = 0
        for s in v:
            total += len(s)
        p = ptr[byte](total)
        n = 0
        for s in v:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)

    def cati(v: generator[str], total: int):
        p = ptr[byte](total)
        n = 0
        for s in v:
            str.memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)

    def join(self: str, l: list[str]):
        if self == "":
            return str.cat(l)
        assert False

    def copy(s: str) -> str:
        t = seq(s.ptr, s.len).__copy__
        return str(t.ptr, t.len)

    def _isspace(b: byte):
        return b == byte(32) or b == byte(9) or b == byte(10) or \
               b == byte(11) or b == byte(12) or b == byte(13)

    def lstrip(self: str):
        i = 0
        while i < self.len:
            if not str._isspace(self.ptr[i]):
                break
            i += 1
        return str(self.ptr + i, self.len - i)

    def rstrip(self: str):
        i = self.len - 1
        while i >= 0:
            if not str._isspace(self.ptr[i]):
                break
            i -= 1
        return '' if i < 0 else str(self.ptr, i + 1)

    def strip(self: str):
        return self.lstrip().rstrip()

    def split(self: str, pat: str):
        if len(pat) == 0:
            for i in self: yield i
        elif len(pat) == 1:
            prev = 0
            for i, s in enumerate(self):
                if s == pat[0]:
                    yield self[prev:i]
                    prev = i + 1
            yield self[prev:len(self)]
        else:
            i, l = 0, len(pat)
            prev = 0
            while i < len(self) - l + 1:
                if self[i:i + l] == pat:
                    yield self[prev:i]
                    prev = i + l
                    i += l
                else:
                    i += 1
            yield self[prev:len(self)]

extend seq:
    def __init__(self: seq, s: str):
        return seq(s.ptr, s.len)

    def __hash__(self: seq):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def __getitem__(self: seq, idx: int):
        if idx < 0:
            idx += len(self)
        assert 0 <= idx <= len(self)
        return seq(self.ptr + idx, 1)

    def __slice__(self: seq, a: int, b: int):
        if a < 0: a += len(self)
        if b < 0: b += len(self)
        if a > len(self): a = len(self)
        if b > len(self): b = len(self)
        return seq(self.ptr + a, b - a)

    def __slice_left__(self: seq, b: int):
        if b < 0: b += len(self)
        if b > len(self): b = len(self)
        return seq(self.ptr, b)

    def __slice_right__(self: seq, a: int):
        if a < 0: a += len(self)
        if a > len(self): a = len(self)
        return seq(self.ptr + a, len(self) - a)

    def split(self: seq, k: int, step: int):
        i = 0
        while i + k <= len(self):
            yield self[i:i+k]
            i += step

    def kmersx[K](self: seq, step: int):
        k = K.len()
        n = len(self)

        if step >= k:
            # naive
            i = 0
            while i + k <= n:
                yield K(self[i:i+k])
                i += step
        elif n >= k:
            # sliding encoding
            kmer = K(self[:k])
            yield kmer
            i = 0
            while i + k + step <= n:
                j = i + k
                kmer <<= self[j:j+step]
                i += step
                yield kmer

    def kmers[K](self: seq, step: int):
        k = K.len()
        n = len(self)
        i = 0
        while i + k <= n:
            sub = self[i:i+k]
            if not sub.N():
                yield K(sub)
            i += step

    def N(self: seq):
        i = 0
        n = len(self)
        while i < n:
            if self[i] == s'N':
                return i + 1
            i += 1
        return 0

    def __invert__(self: seq) -> seq:
        return self.__copy__().revcomp()

    def revcomp(self: seq) -> seq:
        p = self.ptr
        a = 0
        b = self.len - 1
        while a < b:
            p[a], p[b] = p[b].comp(), p[a].comp()
            a += 1
            b -= 1
        return self

def split(self: seq, k: int, step: int):
    return self.split(k, step)

def kmers[K](self: seq, step: int):
    return self.kmers[K](step)

class OSError:
    msg: str

class ArgumentError:
    msg: str

class File:
    fp: ptr[byte]
    buf: ptr[ptr[byte]]
    sz: ptr[int]

    def __init__(self: File, fp: ptr[byte]):
        self.fp = fp
        self.buf = ptr[ptr[byte]](1)
        self.sz = ptr[int](1)

    def __init__(self: File, path: str, mode: str):
        cdef fopen(ptr[byte], ptr[byte]) -> ptr[byte]
        self.fp = fopen(path.ptr, mode.ptr)
        if not self.fp:
            raise OSError("file could not be opened")
        self.buf = ptr[ptr[byte]](1)
        self.sz = ptr[int](1)

    def close(self):
        cdef fclose(ptr[byte]) -> int
        cdef free(ptr[byte]) -> void
        if self.fp:
            fclose(self.fp)
        if self.buf:
            free(self.buf[0])

    def _iter(self: File):
        cdef getline(ptr[ptr[byte]], n: ptr[int], file: ptr[byte]) -> int
        while True:
            rd = getline(self.buf, self.sz, self.fp)
            if rd != -1:
                if self.buf[0][rd - 1] == byte(10):
                    rd -= 1
                yield str(self.buf[0], rd)
            else:
                break

    def __iter__(self: File):
        for i in self._iter():
            t = seq(i.ptr, i.len).__copy__()
            yield str(t.ptr, t.len)

    def readlines(self):
        return [l for l in self.__iter__()]

    def write(self, s: str):
        cdef fwrite(ptr[byte], int, int, ptr[byte]) -> int
        fwrite(s.ptr, 1, s.len, self.fp)

    def write_gen[T](self, g: generator[T]):
        for s in g:
            self.write(str(s))

def open(path: str, mode: str) -> File:
    return File(path, mode)

type FASTQ(file: File):
    def __init__(self: FASTQ, path: str) -> FASTQ:
        return (open(path, "r"),)

    def __iter__(self: FASTQ):
        line = 0
        for i in self.file._iter():
            if line % 4 == 1:
                yield seq(i.ptr, i.len).__copy__()
            line += 1
        self.file.close()

def fastq(path: str):
    return iter(FASTQ(path))

def seqs(path: str):
    for i in iter(File(path, 'r')):
        yield seq(i.ptr, i.len)

def ord(s: str):
    return int(s.ptr[0])

def chr(i: int):
    p = ptr[byte](1)
    p[0] = byte(i)
    return str(p, 1)

def next(g):
    g.done()
    return g.next()

class Box[T]:
    val: T

type Block(p: ptr[byte], seq_len: int, num_seqs: int):
    def __iter__(self: Block):
        p, seq_len, num_seqs = self.p, self.seq_len, self.num_seqs
        for i in range(num_seqs):
            yield seq(p + i*seq_len, seq_len)

def blocks(gg, sz: int):
    buf = ptr[byte]()
    n = l = i = 0
    for s in iter(gg):
        if l == 0:
            l = s.len
            i = 0
            buf = ptr[byte](l * sz)
        if s.len != l:
            raise ArgumentError("blocks requires identical line lengths")
        str.memcpy(buf + n, s.ptr, l)
        n += l
        i += 1
        if i == sz:
            yield Block(buf, l, i)
            buf = ptr[byte](l * sz)
            n, i = 0, 0
    if i > 0:
        yield Block(buf, l, i)

def blocks2(name: str, size: int):
    cdef fopen(ptr[byte], ptr[byte]) -> ptr[byte]
    cdef fclose(ptr[byte]) -> int
    cdef getline(ptr[ptr[byte]], n: ptr[int], file: ptr[byte]) -> int
    cdef fgets(ptr[byte], int, ptr[byte]) -> ptr[byte]
    cdef free(ptr[byte])

    fp = fopen(name.c_str(), "r".ptr)

    if not fp:
        raise OSError("file could not be opened")

    buf = ptr[byte]()
    sz = 0
    rd = getline(__ptr__(buf), __ptr__(sz), fp)

    if rd != -1:
        if buf[rd - 1] == byte(10):
            rd -= 1

        done = False
        while not done:
            idx = 0
            block = ptr[byte](size*rd + 2)  # one for '\n', one for '\0'
            if buf:
                str.memcpy(block, buf, rd)
                free(buf)
                buf = ptr[byte]()
                idx += 1

            while idx < size:
                off = idx * rd
                p = fgets(block + off, rd + 2, fp)

                if not p:
                    done = True
                    break

                if block[off + rd] != byte(10):
                    raise OSError("all sequences must be of same length for blocking")

                idx += 1

            yield Block(block, rd, idx)

    fclose(fp)
