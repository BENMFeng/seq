type range(lo: int, hi: int)
extend range:
    def __init__(self: range, lo: int, hi: int) -> range:
        return (lo, hi)

    def __init__(self: range, hi: int) -> range:
        return (0, hi)

    def __getitem__(self: range, i: int) -> int:
        if i < 0:
            assert self.hi + i >= self.lo
            return self.hi + i

        assert self.lo + i < self.hi
        return self.lo + i

    def __iter__(self: range):
        lo = self.lo
        hi = self.hi
        i = lo
        while i < hi:
            yield i
            i += 1

def len(x):
    return x.__len__()

def iter(x):
    return x.__iter__()

def copy(x):
    return x.__copy__()

def abs(x):
    return x.__abs__()

def hash(x):
    return x.__hash__()

def any(x):
    for a in x:
        if a:
            return True
    return False

def all(x):
    for a in x:
        if not a:
            return False
    return True

def enum(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def filter(f, x):
    for a in x:
        if f(a):
            yield a

def map(f, x):
    for a in x:
        yield f(a)

def echo(x):
    print x

def reversed(x):
    i = len(x)
    while i > 0:
        i -= 1
        yield x[i]

def round(x, n) -> float:
    extern c round(float) -> float
    extern c pow(float, float) -> float
    n := pow(10.0, float(n))
    return round(float(x * n)) / n

import! list
import! dict
import! set

extend int:
    def __hash__(self: int):
        return self

extend str:
    def __hash__(self: str):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def __add__(self: str, other: str):
        extern c memcpy(dst: ptr[byte], src: ptr[byte], num: int) -> ptr[byte]
        len1 = self.len
        len2 = other.len
        len3 = len1 + len2
        p = ptr[byte](len3)
        memcpy(p, self.ptr, len1)
        memcpy(p + len1, other.ptr, len2)
        return str(p, len3)

    def cat(v: list[str]):
        extern c memcpy(dst: ptr[byte], src: ptr[byte], num: int) -> ptr[byte]
        total = 0
        for s in v:
            total += len(s)
        p = ptr[byte](total)
        n = 0
        for s in v:
            memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)

    # def split(self):


extend seq:
    def __hash__(self: seq):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

class File(fp: ptr[byte], buf: ptr[ptr[byte]], sz: ptr[int]):
    def __init__(self: File, path: str, mode: str):
        extern c fopen(ptr[byte], ptr[byte]) -> ptr[byte]
        self.fp = fopen(path.ptr, mode.ptr)

        self.buf = ptr[ptr[byte]](1)
        self.sz = ptr[int](1)

    def close(self):
        extern c fclose(ptr[byte]) -> int
        extern c free(ptr[byte]) -> void
        if self.fp:
            fclose(self.fp)
        if self.buf:
            free(self.buf[0])

    def __iter__(self: File):
        extern c getline(ptr[ptr[byte]], n: ptr[int], file: ptr[byte]) -> int
        while True:
            rd = getline(self.buf, self.sz, self.fp)
            if rd != -1:
                if self.buf[0][rd - 1] == byte(10):
                    rd -= 1
                yield seq(self.buf[0], rd)
            else:
                break

    def readlines(self):
        return [l for l in self.__iter__()]

def open(path: str, mode: str) -> File:
    return File(path, mode)
