type range(lo: int, hi: int, step: int):
    def __init__(self: range, lo: int, hi: int, step: int) -> range:
        assert step != 0
        return (lo, hi, step)

    def __init__(self: range, lo: int, hi: int) -> range:
        return (lo, hi, 1)

    def __init__(self: range, hi: int) -> range:
        return (0, hi, 1)

    def __getitem__(self: range, i: int) -> int:
        if i < 0:
            assert self.hi + i >= self.lo
            return self.hi + i

        assert self.lo + i < self.hi
        return self.lo + i

    def __iter__(self: range):
        lo, hi, step = self
        i = lo
        if step > 0:
            while i < hi:
                yield i
                i += step
        else:
            while i > hi:
                yield i
                i += step

def len(x):
    return x.__len__()

def iter(x):
    return x.__iter__()

def copy(x):
    return x.__copy__()

def abs(x):
    return x.__abs__()

def hash(x):
    return x.__hash__()

def any(x):
    for a in x:
        if a:
            return True
    return False

def all(x):
    for a in x:
        if not a:
            return False
    return True

def enum(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def filter(f, x):
    for a in x:
        if f(a):
            yield a

def map(f, x):
    for a in x:
        yield f(a)

def enumerate(x):
    i = 0
    for a in x:
        yield (i,a)
        i += 1

def echo(x):
    print x

def reversed(x):
    i = len(x)
    while i > 0:
        i -= 1
        yield x[i]

def round(x, n) -> float:
    extern c round(float) -> float
    extern c pow(float, float) -> float
    n := pow(10.0, float(n))
    return round(float(x * n)) / n

import! list
import! dict
import! set

extend int:
    def __pow__(self: int, exp: int):
        result = 1
        while True:
            if exp & 1:
                result *= self
            exp >>= 1
            if not exp:
                break
            self *= self
        return result

    def __pow__(self: int, exp: float):
        return float(self) ** exp

extend str:
    def __hash__(self: str):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def __add__(self: str, other: str):
        extern c memcpy(dst: ptr[byte], src: ptr[byte], num: int) -> ptr[byte]
        len1 = self.len
        len2 = other.len
        len3 = len1 + len2
        p = ptr[byte](len3)
        memcpy(p, self.ptr, len1)
        memcpy(p + len1, other.ptr, len2)
        return str(p, len3)

    def c_str(self: str):
        n = len(self)
        assert n >= 0
        p = ptr[byte](n + 1)
        for i in range(n):
            p[i] = self.ptr[i]
        p[n] = byte(0)
        return p

    def cat(v: list[str]):
        extern c memcpy(dst: ptr[byte], src: ptr[byte], num: int)
        total = 0
        for s in v:
            total += len(s)
        p = ptr[byte](total)
        n = 0
        for s in v:
            memcpy(p + n, s.ptr, s.len)
            n += s.len
        return str(p, total)

extend seq:
    def __hash__(self: seq):
        h = 0
        p, n = self.ptr, self.len
        for i in range(n):
            h = 31*h + int(p[i])
        return h

    def split(self: seq, k: int, step: int):
        i = 0
        while i + k <= len(self):
            yield self[i:i+k]
            i += step

    def kmersx[`k](self: seq, step: int):
        k = `k.len()
        n = len(self)

        if step >= k:
            # naive
            i = 0
            while i + k <= n:
                yield `k(self[i:i+k])
                i += step
        elif n >= k:
            # sliding encoding
            kmer = `k(self[:k])
            yield kmer
            i = 0
            while i + k + step <= n:
                j = i + k
                kmer <<= self[j:j+step]
                i += step
                yield kmer

    def kmers[`k](self: seq, step: int):
        k = `k.len()
        n = len(self)
        i = 0
        while i + k <= n:
            sub = self[i:i+k]
            if not sub.N():
                yield `k(sub)
            i += step

    def N(self: seq):
        i = 0
        n = len(self)
        while i < n:
            if self[i] == s'N':
                return i + 1
            i += 1
        return 0

def split(self: seq, k: int, step: int):
    return self.split(k, step)

def kmers[`k](self: seq, step: int):
    return self.kmers[`k](step)

class File:
    fp: ptr[byte]
    buf: ptr[ptr[byte]]
    sz: ptr[int]

    def __init__(self: File, path: str, mode: str):
        extern c fopen(ptr[byte], ptr[byte]) -> ptr[byte]
        self.fp = fopen(path.ptr, mode.ptr)

        self.buf = ptr[ptr[byte]](1)
        self.sz = ptr[int](1)

    def close(self):
        extern c fclose(ptr[byte]) -> int
        extern c free(ptr[byte]) -> void
        if self.fp:
            fclose(self.fp)
        if self.buf:
            free(self.buf[0])

    def __iter__(self: File):
        extern c getline(ptr[ptr[byte]], n: ptr[int], file: ptr[byte]) -> int
        while True:
            rd = getline(self.buf, self.sz, self.fp)
            if rd != -1:
                if self.buf[0][rd - 1] == byte(10):
                    rd -= 1
                yield seq(self.buf[0], rd)
            else:
                break

    def readlines(self):
        return [l for l in self.__iter__()]

def open(path: str, mode: str) -> File:
    return File(path, mode)

type FASTQ(file: File):
    def __init__(self: FASTQ, path: str) -> FASTQ:
        return (open(path, "r"),)

    def __iter__(self: FASTQ):
        line = 0
        for s in self.file:
            if line % 4 == 1:
                yield seq(s.ptr, s.len)
            line += 1
        self.file.close()

def fastq(path: str):
    return iter(FASTQ(path))
