from core.c_stubs import CIGAR, Alignment, pseq

# adapted from ksw2:
_ALIGN_SCORE_NEG_INF = -0x40000000
_ALIGN_SCORE_ONLY    = 0x01
_ALIGN_RIGHT         = 0x02
_ALIGN_GENERIC_SC    = 0x04
_ALIGN_APPROX_MAX    = 0x08
_ALIGN_APPROX_DROP   = 0x10
_ALIGN_EXTZ_ONLY     = 0x40
_ALIGN_REV_CIGAR     = 0x80
_ALIGN_SPLICE_FOR    = 0x100
_ALIGN_SPLICE_REV    = 0x200
_ALIGN_SPLICE_FLANK  = 0x400

_ALIGN_KIND_REGULAR = 0
_ALIGN_KIND_DUAL    = 1
_ALIGN_KIND_SPLICE  = 2
_ALIGN_KIND_GLOBAL  = 3

type SubMat(mat: ptr[i8]):
    def _N():
        return 23

    def __init__(self: SubMat, d: dict[tuple[str, str], int]) -> SubMat:
        def aa_code(c: str):
            if len(c) != 1:
                raise ValueError("sequence length != 1: " + c)
            AA = 'ABCDEFGHIKLMNPQRSTVWXYZ'
            assert len(AA) == SubMat._N()
            b = c.ptr[0]
            i = 0
            while i < len(AA):
                if b == AA.ptr[i]:
                    return i
                i += 1
            raise ValueError("unknown amino acid code: " + c)

        N = SubMat._N()
        p = ptr[i8](N * N)
        for i in range(N * N):
            p[i] = i8(0)
        for k,v in d.items():
            if not (-128 <= v <= 127):
                raise ValueError("substitution score out of [-128, 127] range: " + str(v))
            a1 = aa_code(k[0])
            a2 = aa_code(k[1])
            p[a1*N + a2] = i8(v)
            p[a2*N + a1] = i8(v)
        return (p,)

    def __str__(self: SubMat):
        N = SubMat._N()
        s = ''
        k = 0
        for i in range(N):
            for j in range(N):
                s += str(int(self.mat[k])) + ' '
                k += 1
        return s

extend CIGAR:
    def __init__(self: CIGAR) -> CIGAR:
        return (ptr[u32](), 0)

    def __len__(self: CIGAR):
        return self.len

    @property
    def qlen(self: CIGAR):
        return _C.bam_cigar2qlen(self.len, self.value)

    @property
    def rlen(self: CIGAR):
        return _C.bam_cigar2rlen(self.len, self.value)

    def __getitem__(self: CIGAR, idx: int):
        if not (0 <= idx < len(self)):
            raise IndexError("CIGAR index out of range")
        v = self.value[idx]
        return (int(v) >> 4, "MIDNSHP=XB"[int(v) & 0xf])

    def __iter__(self: CIGAR):
        for i in range(len(self)):
            yield self[i]

    def __str__(self: CIGAR):
        def op_to_str(op):
            return str(op[0]) + str(op[1])
        return str.cat([op_to_str(op) for op in self])

extend Alignment:
    def __init__(self: Alignment) -> Alignment:
        return (CIGAR(), 0)

    @property
    def cigar(self: Alignment):
        return self._cigar

    @property
    def score(self: Alignment):
        return self._score

    def __bool__(self: Alignment):
        return self._score != _ALIGN_SCORE_NEG_INF

def _validate_match(m: int):
    if m < 0 or m >= 128:
        raise ValueError("match/mismatch penalty for alignment must be in range [0, 127]")

def _validate_gap(g: int):
    if g < 0 or g >= 128:
        raise ValueError("gap penalty for alignment must be in range [0, 127]")

extend seq:
    def align(self: seq,
              other: seq,
              a: int = 2,
              b: int = 4,
              ambig: int = 0,
              gapo: int = 4,
              gape: int = 2,
              gapo2: int = -1,
              gape2: int = -1,
              bandwidth: int = -1,
              zdrop: int = -1,
              end_bonus: int = 0,
              score_only: bool = False,
              right: bool = False,
              generic_sc: bool = False,
              approx_max: bool = False,
              approx_drop: bool = False,
              ext_only: bool = False,
              rev_cigar: bool = False,
              splice: bool = False,
              splice_fwd: bool = False,
              splice_rev: bool = False,
              splice_flank: bool = False,
              glob: bool = False):

        # validate args
        _validate_match(a)
        _validate_match(b)
        _validate_match(ambig)
        _validate_gap(gapo)
        _validate_gap(gape)

        if splice:
            if bandwidth >= 0:
                raise ValueError("bandwidth cannot be specified for splice alignment")
            if end_bonus != 0:
                raise ValueError("end_bonus cannot be specified for splice alignment")
            if glob:
                raise ValueError("global alignment cannot be done with splice alignment")
        elif (splice_fwd or splice_rev or splice_flank):
            raise ValueError("splice flags require 'splice' argument be set to True")

        if (gapo2 < 0) ^ (gape2 < 0):
            raise ValueError("dual gap o/e costs must both be given or both be omitted")
        dual = (gapo2 >= 0)
        if dual:
            _validate_gap(gapo2)
            _validate_gap(gape2)

        if glob:
            if dual:
                raise ValueError("dual gap costs cannot be specified for global alignment")
            if end_bonus != 0:
                raise ValueError("end_bonus cannot be specified for global alignment")

        mat = __array__[i8](25)
        mat[0]  = i8(a)
        mat[1]  = i8(-b)
        mat[2]  = i8(-b)
        mat[3]  = i8(-b)
        mat[4]  = i8(ambig)
        mat[5]  = i8(-b)
        mat[6]  = i8(a)
        mat[7]  = i8(-b)
        mat[8]  = i8(-b)
        mat[9]  = i8(ambig)
        mat[10] = i8(-b)
        mat[11] = i8(-b)
        mat[12] = i8(a)
        mat[13] = i8(-b)
        mat[14] = i8(ambig)
        mat[15] = i8(-b)
        mat[16] = i8(-b)
        mat[17] = i8(-b)
        mat[18] = i8(a)
        mat[19] = i8(ambig)
        mat[20] = i8(ambig)
        mat[21] = i8(ambig)
        mat[22] = i8(ambig)
        mat[23] = i8(ambig)
        mat[24] = i8(ambig)

        flags = 0
        if score_only:
            flags |= _ALIGN_SCORE_ONLY
        if right:
            flags |= _ALIGN_RIGHT
        if generic_sc:
            flags |= _ALIGN_GENERIC_SC
        if approx_max:
            flags |= _ALIGN_APPROX_MAX
        if approx_drop:
            flags |= _ALIGN_APPROX_DROP
        if splice_fwd:
            flags |= _ALIGN_SPLICE_FOR
        if splice_rev:
            flags |= _ALIGN_SPLICE_REV
        if splice_flank:
            flags |= _ALIGN_SPLICE_FLANK

        kind = _ALIGN_KIND_REGULAR
        if splice:
            kind = _ALIGN_KIND_SPLICE
        elif dual:
            kind = _ALIGN_KIND_DUAL
        elif glob:
            kind = _ALIGN_KIND_GLOBAL

        out = Alignment()
        if kind == _ALIGN_KIND_REGULAR:
            _C.seq_align(self, other, mat.ptr, i8(gapo), i8(gape), bandwidth, zdrop, end_bonus, flags, __ptr__(out))
        elif kind == _ALIGN_KIND_DUAL:
            _C.seq_align_dual(self, other, mat.ptr, i8(gapo), i8(gape), i8(gapo2), i8(gape2), bandwidth, zdrop, end_bonus, flags, __ptr__(out))
        elif kind == _ALIGN_KIND_SPLICE:
            _C.seq_align_splice(self, other, mat.ptr, i8(gapo), i8(gape), i8(gapo2), i8(gape2), zdrop, flags, __ptr__(out))
        elif kind == _ALIGN_KIND_GLOBAL:
            _C.seq_align_global(self, other, mat.ptr, i8(gapo), i8(gape), bandwidth, __ptr__(out))
        else:
            assert False
        return out

    def __matmul__(self: seq, other: seq):
        out = Alignment()
        _C.seq_align_default(self, other, __ptr__(out))
        return out

extend pseq:
    def align(self: pseq,
              other: pseq,
              mat: SubMat,
              gapo: int = 4,
              gape: int = 2,
              gapo2: int = -1,
              gape2: int = -1,
              bandwidth: int = -1,
              zdrop: int = -1,
              end_bonus: int = 0,
              score_only: bool = False,
              right: bool = False,
              generic_sc: bool = False,
              approx_max: bool = False,
              approx_drop: bool = False,
              ext_only: bool = False,
              rev_cigar: bool = False,
              glob: bool = False):

        # validate args
        _validate_gap(gapo)
        _validate_gap(gape)

        if (gapo2 < 0) ^ (gape2 < 0):
            raise ValueError("dual gap o/e costs must both be given or both be omitted")
        dual = (gapo2 >= 0)
        if dual:
            _validate_gap(gapo2)
            _validate_gap(gape2)

        if glob:
            if dual:
                raise ValueError("dual gap costs cannot be specified for global alignment")
            if end_bonus != 0:
                raise ValueError("end_bonus cannot be specified for global alignment")

        flags = 0
        if score_only:
            flags |= _ALIGN_SCORE_ONLY
        if right:
            flags |= _ALIGN_RIGHT
        if generic_sc:
            flags |= _ALIGN_GENERIC_SC
        if approx_max:
            flags |= _ALIGN_APPROX_MAX
        if approx_drop:
            flags |= _ALIGN_APPROX_DROP

        kind = _ALIGN_KIND_REGULAR
        if dual:
            kind = _ALIGN_KIND_DUAL
        elif glob:
            kind = _ALIGN_KIND_GLOBAL

        out = Alignment()
        if kind == _ALIGN_KIND_REGULAR:
            _C.seq_palign(self, other, mat.mat, i8(gapo), i8(gape), bandwidth, zdrop, end_bonus, flags, __ptr__(out))
        elif kind == _ALIGN_KIND_DUAL:
            _C.seq_palign_dual(self, other, mat.mat, i8(gapo), i8(gape), i8(gapo2), i8(gape2), bandwidth, zdrop, end_bonus, flags, __ptr__(out))
        elif kind == _ALIGN_KIND_GLOBAL:
            _C.seq_palign_global(self, other, mat.mat, i8(gapo), i8(gape), bandwidth, __ptr__(out))
        else:
            assert False
        return out

    def __matmul__(self: pseq, other: pseq):
        out = Alignment()
        _C.seq_palign_default(self, other, __ptr__(out))
        return out
