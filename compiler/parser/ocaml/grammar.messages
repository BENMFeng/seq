program: ADD TRUE YIELD
##
## Ends in an error in state: 66.
##
## arith_expr -> nonempty_list(ADD) arith_term . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP reverse_separated_nonempty_llist(COMMA,call_term) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . DOT ID [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## nonempty_list(ADD) arith_term
##

invalid unary expression (unexpected yield expression)

program: ADD YIELD
##
## Ends in an error in state: 39.
##
## nonempty_list(ADD) -> ADD . [ TRUE STRING SEQ NONE MUL LS LP LB KMER INT_S ID FSTRING FLOAT_S FALSE ]
## nonempty_list(ADD) -> ADD . nonempty_list(ADD) [ TRUE STRING SEQ NONE MUL LS LP LB KMER INT_S ID FSTRING FLOAT_S FALSE ]
##
## The known suffix of the stack is as follows:
## ADD
##

invalid unary expression (unexpected yield expression)

program: ASSERT TRUE COMMA TRUE XOREQ
##
## Ends in an error in state: 335.
##
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ SEMICOLON NL COMMA ]
## small_statement -> ASSERT expr COMMA reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ASSERT expr COMMA reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 210, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> expr 
##

invalid assert (unexpected assignment operator)

program: ASSERT TRUE COMMA YIELD
##
## Ends in an error in state: 334.
##
## small_statement -> ASSERT expr COMMA . option(COMMA) [ SEMICOLON NL ]
## small_statement -> ASSERT expr COMMA . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ASSERT expr COMMA
##

invalid assert (unexpected yield expression)

program: ASSERT TRUE XOREQ
##
## Ends in an error in state: 333.
##
## small_statement -> ASSERT expr . [ SEMICOLON NL ]
## small_statement -> ASSERT expr . COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> ASSERT expr . COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ASSERT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

invalid assert (unexpected assignment operator)

program: ASSERT YIELD
##
## Ends in an error in state: 332.
##
## small_statement -> ASSERT . expr [ SEMICOLON NL ]
## small_statement -> ASSERT . expr COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> ASSERT . expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ASSERT
##

invalid assert (unexpected yield expression)

program: AT ID NL FROM ID YIELD
##
## Ends in an error in state: 551.
##
## dot_term -> dot_term . DOT ID [ EXTERN DOT ]
## extern_from -> FROM dot_term . [ EXTERN ]
##
## The known suffix of the stack is as follows:
## FROM dot_term
##

invalid from specifier (unexpected yield expression)

program: AT ID NL FROM YIELD
##
## Ends in an error in state: 550.
##
## extern_from -> FROM . dot_term [ EXTERN ]
##
## The known suffix of the stack is as follows:
## FROM
##

invalid from specifier (unexpected yield expression)

program: AT ID NL YIELD
##
## Ends in an error in state: 621.
##
## nonempty_list(decorator) -> decorator . [ FROM EXTERN DEF ]
## nonempty_list(decorator) -> decorator . nonempty_list(decorator) [ FROM EXTERN DEF ]
##
## The known suffix of the stack is as follows:
## decorator
##

invalid decorator (unexpected yield expression)

program: AT ID YIELD
##
## Ends in an error in state: 578.
##
## decorator -> AT ID . NL [ FROM EXTERN DEF AT ]
##
## The known suffix of the stack is as follows:
## AT ID
##

invalid decorator (unexpected yield expression)

program: AT YIELD
##
## Ends in an error in state: 577.
##
## decorator -> AT . ID NL [ FROM EXTERN DEF AT ]
##
## The known suffix of the stack is as follows:
## AT
##

invalid decorator (unexpected yield expression)

program: B_NOT TRUE YIELD
##
## Ends in an error in state: 60.
##
## arith_expr -> nonempty_list(B_NOT) arith_term . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP reverse_separated_nonempty_llist(COMMA,call_term) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . DOT ID [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## nonempty_list(B_NOT) arith_term
##

invalid operand (unexpected yield expression)

program: B_NOT YIELD
##
## Ends in an error in state: 37.
##
## nonempty_list(B_NOT) -> B_NOT . [ TRUE STRING SEQ NONE MUL LS LP LB KMER INT_S ID FSTRING FLOAT_S FALSE ]
## nonempty_list(B_NOT) -> B_NOT . nonempty_list(B_NOT) [ TRUE STRING SEQ NONE MUL LS LP LB KMER INT_S ID FSTRING FLOAT_S FALSE ]
##
## The known suffix of the stack is as follows:
## B_NOT
##

invalid operand (unexpected yield expression)

program: CLASS ID COLON NL INDENT ID COLON TRUE XOREQ
##
## Ends in an error in state: 633.
##
## decl_statement -> ID COLON expr . NL [ STRING PYDEF PASS ID FROM EXTERN DEF DEDENT AT ]
##
## The known suffix of the stack is as follows:
## ID COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

invalid member declaration (unexpected yield expression)

program: CLASS ID COLON NL INDENT ID COLON YIELD
##
## Ends in an error in state: 632.
##
## decl_statement -> ID COLON . expr NL [ STRING PYDEF PASS ID FROM EXTERN DEF DEDENT AT ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

invalid member declaration (unexpected yield expression)

program: CLASS ID COLON NL INDENT ID YIELD
##
## Ends in an error in state: 631.
##
## decl_statement -> ID . COLON expr NL [ STRING PYDEF PASS ID FROM EXTERN DEF DEDENT AT ]
##
## The known suffix of the stack is as follows:
## ID
##

invalid member declaration (unexpected yield expression)

program: CLASS ID COLON NL INDENT STRING NL YIELD
##
## Ends in an error in state: 637.
##
## nonempty_list(dataclass_member) -> dataclass_member . [ DEDENT ]
## nonempty_list(dataclass_member) -> dataclass_member . nonempty_list(dataclass_member) [ DEDENT ]
##
## The known suffix of the stack is as follows:
## dataclass_member
##

invalid member declaration (unexpected yield expression)

program: CLASS ID COLON NL INDENT YIELD
##
## Ends in an error in state: 630.
##
## cls -> CLASS ID option(generic_list) COLON NL INDENT . nonempty_list(dataclass_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## CLASS ID option(generic_list) COLON NL INDENT
##

unexpected yield expression in class definition

program: CLASS ID COLON NL YIELD
##
## Ends in an error in state: 629.
##
## cls -> CLASS ID option(generic_list) COLON NL . INDENT nonempty_list(dataclass_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## CLASS ID option(generic_list) COLON NL
##

unexpected yield expression (missing indentation?)

program: CLASS ID COLON YIELD
##
## Ends in an error in state: 628.
##
## cls -> CLASS ID option(generic_list) COLON . NL INDENT nonempty_list(dataclass_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## CLASS ID option(generic_list) COLON
##

unexpected yield expression (missing newline?)

program: CLASS ID LS ID RS CLASS
##
## Ends in an error in state: 627.
##
## cls -> CLASS ID option(generic_list) . COLON NL INDENT nonempty_list(dataclass_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## CLASS ID option(generic_list)
##

unexpected class keyword (missing newline?)

program: CLASS ID YIELD
##
## Ends in an error in state: 626.
##
## cls -> CLASS ID . option(generic_list) COLON NL INDENT nonempty_list(dataclass_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## CLASS ID
##

unexpected yield expression (missing newline?)

program: CLASS YIELD
##
## Ends in an error in state: 625.
##
## cls -> CLASS . ID option(generic_list) COLON NL INDENT nonempty_list(dataclass_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## CLASS
##

unexpected yield expression (missing newline?)

program: DEF ID LP COMMA YIELD
##
## Ends in an error in state: 571.
##
## func -> DEF ID option(generic_list) LP option(COMMA) . RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP option(COMMA)
##

invalid parameter specification (unexpected yield expression)

program: DEF ID LP ID EQ TRUE XOREQ
##
## Ends in an error in state: 565.
##
## func -> DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) . option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## reverse_separated_nonempty_llist(COMMA,typed_param) -> reverse_separated_nonempty_llist(COMMA,typed_param) . COMMA typed_param [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 396, spurious reduction of production default_val -> EQ expr 
## In state 398, spurious reduction of production option(default_val) -> default_val 
## In state 397, spurious reduction of production typed_param -> ID option(param_type) option(default_val) 
## In state 399, spurious reduction of production reverse_separated_nonempty_llist(COMMA,typed_param) -> typed_param 
##

invalid default argument

program: DEF ID LP ID RP COLON XOREQ
##
## Ends in an error in state: 569.
##
## func -> DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON
##

unexpected assignment operator

program: DEF ID LP ID RP OF FALSE AS
##
## Ends in an error in state: 568.
##
## func -> DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 435, spurious reduction of production func_ret_type -> OF expr 
## In state 439, spurious reduction of production option(func_ret_type) -> func_ret_type 
##

invalid as specifier

program: DEF ID LP ID RP YIELD
##
## Ends in an error in state: 567.
##
## func -> DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP . option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP
##

unexpected yield expression (missing newline?)

program: DEF ID LP RP COLON XOREQ
##
## Ends in an error in state: 574.
##
## func -> DEF ID option(generic_list) LP option(COMMA) RP option(func_ret_type) COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP option(COMMA) RP option(func_ret_type) COLON
##

unexpected assignment operator

program: DEF ID LP RP OF FALSE AS
##
## Ends in an error in state: 573.
##
## func -> DEF ID option(generic_list) LP option(COMMA) RP option(func_ret_type) . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP option(COMMA) RP option(func_ret_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 435, spurious reduction of production func_ret_type -> OF expr 
## In state 439, spurious reduction of production option(func_ret_type) -> func_ret_type 
##

invalid as specifier

program: DEF ID LP RP YIELD
##
## Ends in an error in state: 572.
##
## func -> DEF ID option(generic_list) LP option(COMMA) RP . option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP option(COMMA) RP
##

unexpected yield expression (missing newline?)

program: DEF ID LP YIELD
##
## Ends in an error in state: 564.
##
## func -> DEF ID option(generic_list) LP . option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> DEF ID option(generic_list) LP . reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list) LP
##

unexpected yield expression

program: DEF ID LS ID COMMA COMMA YIELD
##
## Ends in an error in state: 561.
##
## generic_list -> LS ID COMMA option(COMMA) . RS [ LP COLON ]
##
## The known suffix of the stack is as follows:
## LS ID COMMA option(COMMA)
##

unexpected yield expression

program: DEF ID LS ID COMMA ID COMMA SEMICOLON
##
## Ends in an error in state: 559.
##
## generic_list -> LS ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) . RS [ LP COLON ]
##
## The known suffix of the stack is as follows:
## LS ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 156, spurious reduction of production option(COMMA) -> COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: DEF ID LS ID COMMA ID YIELD
##
## Ends in an error in state: 558.
##
## generic_list -> LS ID COMMA reverse_separated_nonempty_llist(COMMA,ID) . option(COMMA) RS [ LP COLON ]
## reverse_separated_nonempty_llist(COMMA,ID) -> reverse_separated_nonempty_llist(COMMA,ID) . COMMA ID [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## LS ID COMMA reverse_separated_nonempty_llist(COMMA,ID)
##

unexpected yield expression

program: DEF ID LS ID COMMA YIELD
##
## Ends in an error in state: 557.
##
## generic_list -> LS ID COMMA . option(COMMA) RS [ LP COLON ]
## generic_list -> LS ID COMMA . reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) RS [ LP COLON ]
##
## The known suffix of the stack is as follows:
## LS ID COMMA
##

unexpected yield expression

program: DEF ID LS ID RS LESS
##
## Ends in an error in state: 563.
##
## func -> DEF ID option(generic_list) . LP option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> DEF ID option(generic_list) . LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID option(generic_list)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: DEF ID LS ID YIELD
##
## Ends in an error in state: 555.
##
## generic_list -> LS ID . RS [ LP COLON ]
## generic_list -> LS ID . COMMA option(COMMA) RS [ LP COLON ]
## generic_list -> LS ID . COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) RS [ LP COLON ]
##
## The known suffix of the stack is as follows:
## LS ID
##

unexpected yield expression

program: DEF ID LS YIELD
##
## Ends in an error in state: 554.
##
## generic_list -> LS . ID RS [ LP COLON ]
## generic_list -> LS . ID COMMA option(COMMA) RS [ LP COLON ]
## generic_list -> LS . ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) RS [ LP COLON ]
##
## The known suffix of the stack is as follows:
## LS
##

unexpected yield expression

program: DEF ID YIELD
##
## Ends in an error in state: 553.
##
## func -> DEF ID . option(generic_list) LP option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> DEF ID . option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF ID
##

unexpected yield expression

program: DEF YIELD
##
## Ends in an error in state: 552.
##
## func -> DEF . ID option(generic_list) LP option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> DEF . ID option(generic_list) LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## DEF
##

unexpected yield expression

program: DEL TRUE COMMA TRUE XOREQ
##
## Ends in an error in state: 327.
##
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ SEMICOLON NL COMMA ]
## small_statement -> DEL expr COMMA reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## DEL expr COMMA reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 210, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: DEL TRUE COMMA YIELD
##
## Ends in an error in state: 326.
##
## small_statement -> DEL expr COMMA . option(COMMA) [ SEMICOLON NL ]
## small_statement -> DEL expr COMMA . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## DEL expr COMMA
##

unexpected yield expression

program: DEL TRUE XOREQ
##
## Ends in an error in state: 325.
##
## small_statement -> DEL expr . [ SEMICOLON NL ]
## small_statement -> DEL expr . COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> DEL expr . COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## DEL expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: DEL YIELD
##
## Ends in an error in state: 324.
##
## small_statement -> DEL . expr [ SEMICOLON NL ]
## small_statement -> DEL . expr COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> DEL . expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## DEL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE COLON NL INDENT PASS YIELD
##
## Ends in an error in state: 548.
##
## class_member -> PASS . NL [ STRING PYDEF PASS ID FROM EXTERN DEF DEDENT AT ]
##
## The known suffix of the stack is as follows:
## PASS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE COLON NL INDENT STRING NL YIELD
##
## Ends in an error in state: 623.
##
## nonempty_list(class_member) -> class_member . [ DEDENT ]
## nonempty_list(class_member) -> class_member . nonempty_list(class_member) [ DEDENT ]
##
## The known suffix of the stack is as follows:
## class_member
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE COLON NL INDENT STRING YIELD
##
## Ends in an error in state: 546.
##
## class_member -> STRING . NL [ STRING PYDEF PASS ID FROM EXTERN DEF DEDENT AT ]
##
## The known suffix of the stack is as follows:
## STRING
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE COLON NL INDENT YIELD
##
## Ends in an error in state: 545.
##
## extend -> EXTEND expr COLON NL INDENT . nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXTEND expr COLON NL INDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE COLON NL YIELD
##
## Ends in an error in state: 544.
##
## extend -> EXTEND expr COLON NL . INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXTEND expr COLON NL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE COLON YIELD
##
## Ends in an error in state: 543.
##
## extend -> EXTEND expr COLON . NL INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXTEND expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND TRUE XOREQ
##
## Ends in an error in state: 542.
##
## extend -> EXTEND expr . COLON NL INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXTEND expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTEND YIELD
##
## Ends in an error in state: 541.
##
## extend -> EXTEND . expr COLON NL INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXTEND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP COMMA YIELD
##
## Ends in an error in state: 598.
##
## extern_what -> ID LP option(COMMA) . RP option(func_ret_type) option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP ID YIELD
##
## Ends in an error in state: 585.
##
## atom -> ID . [ SUB SPIPE RP PPIPE POW PIPE OR NOTIN NEQ MUL MOD LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FDIV EEQ DOT DIV COMMA B_XOR B_RSH B_OR B_LSH B_AND AT AND ADD ]
## extern_param -> ID . param_type [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP AS ID YIELD
##
## Ends in an error in state: 603.
##
## func -> option(extern_from) EXTERN extern_what . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> option(extern_from) EXTERN extern_what . COMMA option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> option(extern_from) EXTERN extern_what . COMMA reverse_separated_nonempty_llist(COMMA,extern_what) option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## option(extern_from) EXTERN extern_what
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP AS YIELD
##
## Ends in an error in state: 594.
##
## extern_as -> AS . ID [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP COMMA COMMA YIELD
##
## Ends in an error in state: 611.
##
## func -> option(extern_from) EXTERN extern_what COMMA option(COMMA) . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## option(extern_from) EXTERN extern_what COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP COMMA ID LP RP AS ID YIELD
##
## Ends in an error in state: 606.
##
## func -> option(extern_from) EXTERN extern_what COMMA reverse_separated_nonempty_llist(COMMA,extern_what) . option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## reverse_separated_nonempty_llist(COMMA,extern_what) -> reverse_separated_nonempty_llist(COMMA,extern_what) . COMMA extern_what [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## option(extern_from) EXTERN extern_what COMMA reverse_separated_nonempty_llist(COMMA,extern_what)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP COMMA ID LP RP COMMA YIELD
##
## Ends in an error in state: 607.
##
## option(COMMA) -> COMMA . [ NL ]
## reverse_separated_nonempty_llist(COMMA,extern_what) -> reverse_separated_nonempty_llist(COMMA,extern_what) COMMA . extern_what [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,extern_what) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP COMMA YIELD
##
## Ends in an error in state: 605.
##
## func -> option(extern_from) EXTERN extern_what COMMA . option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> option(extern_from) EXTERN extern_what COMMA . reverse_separated_nonempty_llist(COMMA,extern_what) option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## option(extern_from) EXTERN extern_what COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP OF FALSE ANDEQ
##
## Ends in an error in state: 600.
##
## extern_what -> ID LP option(COMMA) RP option(func_ret_type) . option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP option(COMMA) RP option(func_ret_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 435, spurious reduction of production func_ret_type -> OF expr 
## In state 439, spurious reduction of production option(func_ret_type) -> func_ret_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP RP YIELD
##
## Ends in an error in state: 599.
##
## extern_what -> ID LP option(COMMA) RP . option(func_ret_type) option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP option(COMMA) RP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP TRUE COMMA YIELD
##
## Ends in an error in state: 588.
##
## option(COMMA) -> COMMA . [ RP ]
## reverse_separated_nonempty_llist(COMMA,extern_param) -> reverse_separated_nonempty_llist(COMMA,extern_param) COMMA . extern_param [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,extern_param) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP TRUE RP OF FALSE ANDEQ
##
## Ends in an error in state: 593.
##
## extern_what -> ID LP reverse_separated_nonempty_llist(COMMA,extern_param) option(COMMA) RP option(func_ret_type) . option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP reverse_separated_nonempty_llist(COMMA,extern_param) option(COMMA) RP option(func_ret_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 435, spurious reduction of production func_ret_type -> OF expr 
## In state 439, spurious reduction of production option(func_ret_type) -> func_ret_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP TRUE RP YIELD
##
## Ends in an error in state: 592.
##
## extern_what -> ID LP reverse_separated_nonempty_llist(COMMA,extern_param) option(COMMA) RP . option(func_ret_type) option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP reverse_separated_nonempty_llist(COMMA,extern_param) option(COMMA) RP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP TRUE XOREQ
##
## Ends in an error in state: 587.
##
## extern_what -> ID LP reverse_separated_nonempty_llist(COMMA,extern_param) . option(COMMA) RP option(func_ret_type) option(extern_as) [ NL COMMA ]
## reverse_separated_nonempty_llist(COMMA,extern_param) -> reverse_separated_nonempty_llist(COMMA,extern_param) . COMMA extern_param [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP reverse_separated_nonempty_llist(COMMA,extern_param)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 590, spurious reduction of production extern_param -> expr 
## In state 602, spurious reduction of production reverse_separated_nonempty_llist(COMMA,extern_param) -> extern_param 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID LP YIELD
##
## Ends in an error in state: 584.
##
## extern_what -> ID LP . option(COMMA) RP option(func_ret_type) option(extern_as) [ NL COMMA ]
## extern_what -> ID LP . reverse_separated_nonempty_llist(COMMA,extern_param) option(COMMA) RP option(func_ret_type) option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN ID YIELD
##
## Ends in an error in state: 583.
##
## extern_what -> ID . LP option(COMMA) RP option(func_ret_type) option(extern_as) [ NL COMMA ]
## extern_what -> ID . LP reverse_separated_nonempty_llist(COMMA,extern_param) option(COMMA) RP option(func_ret_type) option(extern_as) [ NL COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: EXTERN YIELD
##
## Ends in an error in state: 582.
##
## func -> option(extern_from) EXTERN . extern_what NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> option(extern_from) EXTERN . extern_what COMMA option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## func -> option(extern_from) EXTERN . extern_what COMMA reverse_separated_nonempty_llist(COMMA,extern_what) option(COMMA) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## option(extern_from) EXTERN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA COMMA YIELD
##
## Ends in an error in state: 531.
##
## single_statement -> FOR ID COMMA option(COMMA) . IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA ID COMMA SEMICOLON
##
## Ends in an error in state: 526.
##
## single_statement -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) . IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 156, spurious reduction of production option(COMMA) -> COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA ID IN TRUE COLON XOREQ
##
## Ends in an error in state: 529.
##
## single_statement -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA ID IN TRUE XOREQ
##
## Ends in an error in state: 528.
##
## single_statement -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA ID IN YIELD
##
## Ends in an error in state: 527.
##
## single_statement -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA ID YIELD
##
## Ends in an error in state: 525.
##
## reverse_separated_nonempty_llist(COMMA,ID) -> reverse_separated_nonempty_llist(COMMA,ID) . COMMA ID [ IN COMMA ]
## single_statement -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) . option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA IN TRUE COLON XOREQ
##
## Ends in an error in state: 534.
##
## single_statement -> FOR ID COMMA option(COMMA) IN expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA) IN expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA IN TRUE XOREQ
##
## Ends in an error in state: 533.
##
## single_statement -> FOR ID COMMA option(COMMA) IN expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA) IN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA IN YIELD
##
## Ends in an error in state: 532.
##
## single_statement -> FOR ID COMMA option(COMMA) IN . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID COMMA YIELD
##
## Ends in an error in state: 524.
##
## single_statement -> FOR ID COMMA . option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> FOR ID COMMA . reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID IN TRUE COLON XOREQ
##
## Ends in an error in state: 522.
##
## single_statement -> FOR ID IN expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID IN expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID IN TRUE XOREQ
##
## Ends in an error in state: 521.
##
## single_statement -> FOR ID IN expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID IN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID IN YIELD
##
## Ends in an error in state: 520.
##
## single_statement -> FOR ID IN . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR ID YIELD
##
## Ends in an error in state: 519.
##
## single_statement -> FOR ID . IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> FOR ID . COMMA option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> FOR ID . COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR LP RP IN TRUE COLON XOREQ
##
## Ends in an error in state: 539.
##
## single_statement -> FOR tuple IN expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR tuple IN expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR LP RP IN TRUE XOREQ
##
## Ends in an error in state: 538.
##
## single_statement -> FOR tuple IN expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR tuple IN expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR LP RP IN YIELD
##
## Ends in an error in state: 537.
##
## single_statement -> FOR tuple IN . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR tuple IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR LP RP YIELD
##
## Ends in an error in state: 536.
##
## single_statement -> FOR tuple . IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR tuple
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FOR YIELD
##
## Ends in an error in state: 518.
##
## single_statement -> FOR . ID IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> FOR . ID COMMA option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> FOR . ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> FOR . tuple IN expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FROM ID IMPORT ID AS ID YIELD
##
## Ends in an error in state: 319.
##
## import_statement -> FROM dot_term IMPORT import_term . [ SEMICOLON NL ]
## import_statement -> FROM dot_term IMPORT import_term . COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM dot_term IMPORT import_term . COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM dot_term IMPORT import_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FROM ID IMPORT ID COMMA ID AS ID YIELD
##
## Ends in an error in state: 321.
##
## import_statement -> FROM dot_term IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) . option(COMMA) [ SEMICOLON NL ]
## reverse_separated_nonempty_llist(COMMA,import_term) -> reverse_separated_nonempty_llist(COMMA,import_term) . COMMA import_term [ SEMICOLON NL COMMA ]
##
## The known suffix of the stack is as follows:
## FROM dot_term IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FROM ID IMPORT ID COMMA YIELD
##
## Ends in an error in state: 320.
##
## import_statement -> FROM dot_term IMPORT import_term COMMA . option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM dot_term IMPORT import_term COMMA . reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM dot_term IMPORT import_term COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FROM ID IMPORT YIELD
##
## Ends in an error in state: 317.
##
## import_statement -> FROM dot_term IMPORT . MUL [ SEMICOLON NL ]
## import_statement -> FROM dot_term IMPORT . import_term [ SEMICOLON NL ]
## import_statement -> FROM dot_term IMPORT . import_term COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM dot_term IMPORT . import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM dot_term IMPORT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FROM ID YIELD
##
## Ends in an error in state: 517.
##
## dot_term -> dot_term . DOT ID [ IMPORT EXTERN DOT ]
## extern_from -> FROM dot_term . [ EXTERN ]
## import_statement -> FROM dot_term . IMPORT MUL [ SEMICOLON NL ]
## import_statement -> FROM dot_term . IMPORT import_term [ SEMICOLON NL ]
## import_statement -> FROM dot_term . IMPORT import_term COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM dot_term . IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM dot_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FROM YIELD
##
## Ends in an error in state: 516.
##
## extern_from -> FROM . dot_term [ EXTERN ]
## import_statement -> FROM . dot_term IMPORT MUL [ SEMICOLON NL ]
## import_statement -> FROM . dot_term IMPORT import_term [ SEMICOLON NL ]
## import_statement -> FROM . dot_term IMPORT import_term COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM . dot_term IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: FSTRING YIELD
##
## Ends in an error in state: 33.
##
## nonempty_list(FSTRING) -> FSTRING . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## nonempty_list(FSTRING) -> FSTRING . nonempty_list(FSTRING) [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## FSTRING
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: GLOBAL ID COMMA ID COMMA YIELD
##
## Ends in an error in state: 156.
##
## option(COMMA) -> COMMA . [ SEMICOLON RS NL IN ]
## reverse_separated_nonempty_llist(COMMA,ID) -> reverse_separated_nonempty_llist(COMMA,ID) COMMA . ID [ SEMICOLON RS NL IN COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,ID) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: GLOBAL ID COMMA ID YIELD
##
## Ends in an error in state: 312.
##
## reverse_separated_nonempty_llist(COMMA,ID) -> reverse_separated_nonempty_llist(COMMA,ID) . COMMA ID [ SEMICOLON NL COMMA ]
## small_statement -> GLOBAL ID COMMA reverse_separated_nonempty_llist(COMMA,ID) . option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## GLOBAL ID COMMA reverse_separated_nonempty_llist(COMMA,ID)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: GLOBAL ID COMMA YIELD
##
## Ends in an error in state: 311.
##
## small_statement -> GLOBAL ID COMMA . option(COMMA) [ SEMICOLON NL ]
## small_statement -> GLOBAL ID COMMA . reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## GLOBAL ID COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: GLOBAL ID YIELD
##
## Ends in an error in state: 310.
##
## small_statement -> GLOBAL ID . [ SEMICOLON NL ]
## small_statement -> GLOBAL ID . COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> GLOBAL ID . COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## GLOBAL ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: GLOBAL YIELD
##
## Ends in an error in state: 309.
##
## small_statement -> GLOBAL . ID [ SEMICOLON NL ]
## small_statement -> GLOBAL . ID COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> GLOBAL . ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## GLOBAL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID COLON TRUE EQ YIELD
##
## Ends in an error in state: 307.
##
## assign_statement -> ID COLON expr EQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ID COLON expr EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID COLON TRUE XOREQ
##
## Ends in an error in state: 514.
##
## assign_statement -> ID COLON expr . EQ expr [ SEMICOLON NL ]
## decl_statement -> ID COLON expr . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ID COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID COLON YIELD
##
## Ends in an error in state: 513.
##
## assign_statement -> ID COLON . expr EQ expr [ SEMICOLON NL ]
## decl_statement -> ID COLON . expr NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: ID YIELD
##
## Ends in an error in state: 512.
##
## assign_statement -> ID . COLON expr EQ expr [ SEMICOLON NL ]
## atom -> ID . [ XOREQ SUB SPIPE SEMICOLON RSHEQ PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FDIVEQ FDIV EQ EEQ DOT DIVEQ DIV COMMA B_XOR B_RSH B_OR B_LSH B_AND AT ANDEQ AND ADD ]
## decl_statement -> ID . COLON expr NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON XOREQ
##
## Ends in an error in state: 501.
##
## single_statement -> IF expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> IF expr COLON . suite elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## IF expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL ELIF TRUE COLON XOREQ
##
## Ends in an error in state: 508.
##
## elif_suite -> ELIF expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## elif_suite -> ELIF expr COLON . suite elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ELIF expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL ELIF TRUE COLON YIELD NL XOREQ
##
## Ends in an error in state: 509.
##
## elif_suite -> ELIF expr COLON suite . [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## elif_suite -> ELIF expr COLON suite . elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ELIF expr COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL ELIF TRUE XOREQ
##
## Ends in an error in state: 507.
##
## elif_suite -> ELIF expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## elif_suite -> ELIF expr . COLON suite elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ELIF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL ELIF YIELD
##
## Ends in an error in state: 506.
##
## elif_suite -> ELIF . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## elif_suite -> ELIF . expr COLON suite elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ELIF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL ELSE COLON XOREQ
##
## Ends in an error in state: 504.
##
## elif_suite -> ELSE COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ELSE COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL ELSE YIELD
##
## Ends in an error in state: 503.
##
## elif_suite -> ELSE . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE COLON YIELD NL XOREQ
##
## Ends in an error in state: 502.
##
## single_statement -> IF expr COLON suite . [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> IF expr COLON suite . elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## IF expr COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF TRUE XOREQ
##
## Ends in an error in state: 500.
##
## single_statement -> IF expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> IF expr . COLON suite elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## IF expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IF YIELD
##
## Ends in an error in state: 499.
##
## single_statement -> IF . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## single_statement -> IF . expr COLON suite elif_suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID AS ID YIELD
##
## Ends in an error in state: 291.
##
## import_statement -> IMPORT import_term . [ SEMICOLON NL ]
## import_statement -> IMPORT import_term . COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> IMPORT import_term . COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## IMPORT import_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID AS YIELD
##
## Ends in an error in state: 299.
##
## import_term -> dot_term AS . ID [ SEMICOLON NL COMMA ]
##
## The known suffix of the stack is as follows:
## dot_term AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID COMMA ID AS ID YIELD
##
## Ends in an error in state: 293.
##
## import_statement -> IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) . option(COMMA) [ SEMICOLON NL ]
## reverse_separated_nonempty_llist(COMMA,import_term) -> reverse_separated_nonempty_llist(COMMA,import_term) . COMMA import_term [ SEMICOLON NL COMMA ]
##
## The known suffix of the stack is as follows:
## IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID COMMA ID COMMA YIELD
##
## Ends in an error in state: 294.
##
## option(COMMA) -> COMMA . [ SEMICOLON NL ]
## reverse_separated_nonempty_llist(COMMA,import_term) -> reverse_separated_nonempty_llist(COMMA,import_term) COMMA . import_term [ SEMICOLON NL COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,import_term) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID COMMA YIELD
##
## Ends in an error in state: 292.
##
## import_statement -> IMPORT import_term COMMA . option(COMMA) [ SEMICOLON NL ]
## import_statement -> IMPORT import_term COMMA . reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## IMPORT import_term COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID DOT YIELD
##
## Ends in an error in state: 297.
##
## dot_term -> dot_term DOT . ID [ SEMICOLON NL IMPORT EXTERN DOT COMMA AS ]
##
## The known suffix of the stack is as follows:
## dot_term DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT ID YIELD
##
## Ends in an error in state: 296.
##
## dot_term -> dot_term . DOT ID [ SEMICOLON NL DOT COMMA AS ]
## import_term -> dot_term . [ SEMICOLON NL COMMA ]
## import_term -> dot_term . AS ID [ SEMICOLON NL COMMA ]
##
## The known suffix of the stack is as follows:
## dot_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: IMPORT YIELD
##
## Ends in an error in state: 289.
##
## import_statement -> IMPORT . import_term [ SEMICOLON NL ]
## import_statement -> IMPORT . import_term COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> IMPORT . import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## IMPORT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LAMBDA COLON YIELD
##
## Ends in an error in state: 29.
##
## expr -> LAMBDA loption(separated_nonempty_list(COMMA,ID)) COLON . expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## LAMBDA loption(separated_nonempty_list(COMMA,ID)) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LAMBDA ID COMMA YIELD
##
## Ends in an error in state: 25.
##
## separated_nonempty_list(COMMA,ID) -> ID COMMA . separated_nonempty_list(COMMA,ID) [ COLON ]
##
## The known suffix of the stack is as follows:
## ID COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LAMBDA ID YIELD
##
## Ends in an error in state: 24.
##
## separated_nonempty_list(COMMA,ID) -> ID . [ COLON ]
## separated_nonempty_list(COMMA,ID) -> ID . COMMA separated_nonempty_list(COMMA,ID) [ COLON ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LAMBDA YIELD
##
## Ends in an error in state: 23.
##
## expr -> LAMBDA . loption(separated_nonempty_list(COMMA,ID)) COLON expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## LAMBDA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB COMMA YIELD
##
## Ends in an error in state: 198.
##
## atom -> LB option(COMMA) . RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COLON FALSE COMMA FALSE COLON FALSE XOREQ
##
## Ends in an error in state: 190.
##
## atom -> LB reverse_separated_nonempty_llist(COMMA,dictitem) . option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,dictitem) -> reverse_separated_nonempty_llist(COMMA,dictitem) . COMMA dictitem [ RB COMMA ]
##
## The known suffix of the stack is as follows:
## LB reverse_separated_nonempty_llist(COMMA,dictitem)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 194, spurious reduction of production dictitem -> expr COLON expr 
## In state 195, spurious reduction of production reverse_separated_nonempty_llist(COMMA,dictitem) -> reverse_separated_nonempty_llist(COMMA,dictitem) COMMA dictitem 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COLON FALSE COMMA TRUE XOREQ
##
## Ends in an error in state: 192.
##
## dictitem -> expr . COLON expr [ RB COMMA ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COLON FALSE COMMA YIELD
##
## Ends in an error in state: 191.
##
## option(COMMA) -> COMMA . [ RB ]
## reverse_separated_nonempty_llist(COMMA,dictitem) -> reverse_separated_nonempty_llist(COMMA,dictitem) COMMA . dictitem [ RB COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,dictitem) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COLON FALSE FOR ID IN FALSE RS
##
## Ends in an error in state: 214.
##
## atom -> LB dictitem comprehension . RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB dictitem comprehension
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 145, spurious reduction of production list(comprehension_if) -> 
## In state 148, spurious reduction of production option(comprehension) -> 
## In state 149, spurious reduction of production comprehension -> FOR ID IN pipe_expr list(comprehension_if) option(comprehension) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COLON FALSE XOREQ
##
## Ends in an error in state: 213.
##
## atom -> LB dictitem . comprehension RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,dictitem) -> dictitem . [ RB COMMA ]
##
## The known suffix of the stack is as follows:
## LB dictitem
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 194, spurious reduction of production dictitem -> expr COLON expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COLON YIELD
##
## Ends in an error in state: 193.
##
## dictitem -> expr COLON . expr [ RB FOR COMMA ]
##
## The known suffix of the stack is as follows:
## expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COMMA COMMA YIELD
##
## Ends in an error in state: 208.
##
## atom -> LB expr COMMA option(COMMA) . RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB expr COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COMMA TRUE COMMA SEMICOLON
##
## Ends in an error in state: 206.
##
## atom -> LB expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) . RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production option(COMMA) -> COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COMMA TRUE XOREQ
##
## Ends in an error in state: 203.
##
## atom -> LB expr COMMA reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ RB COMMA ]
##
## The known suffix of the stack is as follows:
## LB expr COMMA reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 210, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE COMMA YIELD
##
## Ends in an error in state: 202.
##
## atom -> LB expr COMMA . option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB expr COMMA . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE FOR ID IN FALSE RS
##
## Ends in an error in state: 211.
##
## atom -> LB expr comprehension . RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB expr comprehension
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 145, spurious reduction of production list(comprehension_if) -> 
## In state 148, spurious reduction of production option(comprehension) -> 
## In state 149, spurious reduction of production comprehension -> FOR ID IN pipe_expr list(comprehension_if) option(comprehension) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB TRUE XOREQ
##
## Ends in an error in state: 200.
##
## atom -> LB expr . RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB expr . COMMA option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB expr . COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB expr . comprehension RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## dictitem -> expr . COLON expr [ RB FOR COMMA ]
##
## The known suffix of the stack is as follows:
## LB expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LB YIELD
##
## Ends in an error in state: 22.
##
## atom -> LB . expr RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB . expr COMMA option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB . expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB . option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB . reverse_separated_nonempty_llist(COMMA,dictitem) option(COMMA) RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB . expr comprehension RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LB . dictitem comprehension RB [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LB
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE COMMA TRUE COMMA COMMA YIELD
##
## Ends in an error in state: 226.
##
## tuple -> LP expr COMMA expr COMMA option(COMMA) . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr COMMA expr COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE COMMA TRUE COMMA TRUE COMMA SEMICOLON
##
## Ends in an error in state: 224.
##
## tuple -> LP expr COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production option(COMMA) -> COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE COMMA TRUE COMMA TRUE XOREQ
##
## Ends in an error in state: 223.
##
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ RP COMMA ]
## tuple -> LP expr COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 210, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE COMMA TRUE COMMA YIELD
##
## Ends in an error in state: 222.
##
## tuple -> LP expr COMMA expr COMMA . option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr COMMA expr COMMA . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr COMMA expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE COMMA TRUE XOREQ
##
## Ends in an error in state: 220.
##
## tuple -> LP expr COMMA expr . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr COMMA expr . COMMA option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr COMMA expr . COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr COMMA expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE COMMA YIELD
##
## Ends in an error in state: 218.
##
## tuple -> LP expr COMMA . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr COMMA . expr RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr COMMA . expr COMMA option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr COMMA . expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE FOR ID IN FALSE RS
##
## Ends in an error in state: 228.
##
## atom -> LP expr comprehension . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr comprehension
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 145, spurious reduction of production list(comprehension_if) -> 
## In state 148, spurious reduction of production option(comprehension) -> 
## In state 149, spurious reduction of production comprehension -> FOR ID IN pipe_expr list(comprehension_if) option(comprehension) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP TRUE XOREQ
##
## Ends in an error in state: 216.
##
## atom -> LP expr . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LP expr . comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA expr RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA expr COMMA option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP XOREQ
##
## Ends in an error in state: 19.
##
## arith_term -> LP . YIELD RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LP . expr RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LP . expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA expr RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA expr COMMA option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LP YIELD YIELD
##
## Ends in an error in state: 20.
##
## arith_term -> LP YIELD . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP YIELD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS COMMA YIELD
##
## Ends in an error in state: 233.
##
## atom -> LS option(COMMA) . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LS option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE COMMA FALSE XOREQ
##
## Ends in an error in state: 230.
##
## atom -> LS reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## LS reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 205, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) COMMA expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE COMMA SEMICOLON
##
## Ends in an error in state: 231.
##
## atom -> LS reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LS reverse_separated_nonempty_llist(COMMA,expr) option(COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 204, spurious reduction of production option(COMMA) -> COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA COMMA YIELD
##
## Ends in an error in state: 163.
##
## comprehension -> FOR ID COMMA option(COMMA) . IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA ID COMMA SEMICOLON
##
## Ends in an error in state: 158.
##
## comprehension -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) . IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 156, spurious reduction of production option(COMMA) -> COMMA 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA ID IN TRUE XOREQ
##
## Ends in an error in state: 160.
##
## comprehension -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN pipe_expr . list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN pipe_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA ID IN YIELD
##
## Ends in an error in state: 159.
##
## comprehension -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN . pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA ID YIELD
##
## Ends in an error in state: 155.
##
## comprehension -> FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID) . option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
## reverse_separated_nonempty_llist(COMMA,ID) -> reverse_separated_nonempty_llist(COMMA,ID) . COMMA ID [ IN COMMA ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA reverse_separated_nonempty_llist(COMMA,ID)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA IN TRUE XOREQ
##
## Ends in an error in state: 165.
##
## comprehension -> FOR ID COMMA option(COMMA) IN pipe_expr . list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA) IN pipe_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA IN YIELD
##
## Ends in an error in state: 164.
##
## comprehension -> FOR ID COMMA option(COMMA) IN . pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA option(COMMA) IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID COMMA YIELD
##
## Ends in an error in state: 153.
##
## comprehension -> FOR ID COMMA . option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
## comprehension -> FOR ID COMMA . reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID IN FALSE RP
##
## Ends in an error in state: 236.
##
## atom -> LS expr comprehension . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LS expr comprehension
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 145, spurious reduction of production list(comprehension_if) -> 
## In state 148, spurious reduction of production option(comprehension) -> 
## In state 149, spurious reduction of production comprehension -> FOR ID IN pipe_expr list(comprehension_if) option(comprehension) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID IN TRUE IF TRUE XOREQ
##
## Ends in an error in state: 151.
##
## list(comprehension_if) -> comprehension_if . list(comprehension_if) [ RS RP RB FOR ]
##
## The known suffix of the stack is as follows:
## comprehension_if
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 147, spurious reduction of production comprehension_if -> IF pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID IN TRUE IF YIELD
##
## Ends in an error in state: 146.
##
## comprehension_if -> IF . pipe_expr [ RS RP RB IF FOR ]
##
## The known suffix of the stack is as follows:
## IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID IN TRUE XOREQ
##
## Ends in an error in state: 145.
##
## comprehension -> FOR ID IN pipe_expr . list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID IN pipe_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID IN YIELD
##
## Ends in an error in state: 144.
##
## comprehension -> FOR ID IN . pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR ID YIELD
##
## Ends in an error in state: 143.
##
## comprehension -> FOR ID . IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
## comprehension -> FOR ID . COMMA option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
## comprehension -> FOR ID . COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE FOR YIELD
##
## Ends in an error in state: 142.
##
## comprehension -> FOR . ID IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
## comprehension -> FOR . ID COMMA option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
## comprehension -> FOR . ID COMMA reverse_separated_nonempty_llist(COMMA,ID) option(COMMA) IN pipe_expr list(comprehension_if) option(comprehension) [ RS RP RB ]
##
## The known suffix of the stack is as follows:
## FOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS TRUE XOREQ
##
## Ends in an error in state: 235.
##
## atom -> LS expr . comprehension RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,expr) -> expr . [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## LS expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: LS YIELD
##
## Ends in an error in state: 18.
##
## atom -> LS . option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LS . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> LS . expr comprehension RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE ADD YIELD
##
## Ends in an error in state: 461.
##
## case_int -> ADD . INT_S [ RS RP OR IF ELLIPSIS COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## ADD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE INT_S ELLIPSIS YIELD
##
## Ends in an error in state: 470.
##
## case_type -> case_int ELLIPSIS . case_int [ RS RP OR IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## case_int ELLIPSIS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE INT_S YIELD
##
## Ends in an error in state: 469.
##
## case_type -> case_int . [ RS RP OR IF COMMA COLON AS ]
## case_type -> case_int . ELLIPSIS case_int [ RS RP OR IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## case_int
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LP TRUE COMMA YIELD
##
## Ends in an error in state: 474.
##
## separated_nonempty_list(COMMA,case_or) -> case_or COMMA . separated_nonempty_list(COMMA,case_or) [ RP ]
##
## The known suffix of the stack is as follows:
## case_or COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LP TRUE RS
##
## Ends in an error in state: 473.
##
## separated_nonempty_list(COMMA,case_or) -> case_or . [ RP ]
## separated_nonempty_list(COMMA,case_or) -> case_or . COMMA separated_nonempty_list(COMMA,case_or) [ RP ]
##
## The known suffix of the stack is as follows:
## case_or
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 466, spurious reduction of production separated_nonempty_list(OR,case_type) -> case_type 
## In state 463, spurious reduction of production case_or -> separated_nonempty_list(OR,case_type) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LP YIELD
##
## Ends in an error in state: 457.
##
## case_type -> LP . separated_nonempty_list(COMMA,case_or) RP [ RS RP OR IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LS COMMA YIELD
##
## Ends in an error in state: 481.
##
## case_type -> LS option(COMMA) . RS [ RS RP OR IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## LS option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LS TRUE COMMA YIELD
##
## Ends in an error in state: 477.
##
## option(COMMA) -> COMMA . [ RS ]
## reverse_separated_nonempty_llist(COMMA,case_or) -> reverse_separated_nonempty_llist(COMMA,case_or) COMMA . case_or [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,case_or) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LS TRUE RP
##
## Ends in an error in state: 476.
##
## case_type -> LS reverse_separated_nonempty_llist(COMMA,case_or) . option(COMMA) RS [ RS RP OR IF COMMA COLON AS ]
## reverse_separated_nonempty_llist(COMMA,case_or) -> reverse_separated_nonempty_llist(COMMA,case_or) . COMMA case_or [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## LS reverse_separated_nonempty_llist(COMMA,case_or)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 466, spurious reduction of production separated_nonempty_list(OR,case_type) -> case_type 
## In state 463, spurious reduction of production case_or -> separated_nonempty_list(OR,case_type) 
## In state 483, spurious reduction of production reverse_separated_nonempty_llist(COMMA,case_or) -> case_or 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE LS YIELD
##
## Ends in an error in state: 456.
##
## case_type -> LS . option(COMMA) RS [ RS RP OR IF COMMA COLON AS ]
## case_type -> LS . reverse_separated_nonempty_llist(COMMA,case_or) option(COMMA) RS [ RS RP OR IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## LS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE SUB YIELD
##
## Ends in an error in state: 452.
##
## case_int -> SUB . INT_S [ RS RP OR IF ELLIPSIS COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## SUB
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE AS ID COLON XOREQ
##
## Ends in an error in state: 493.
##
## case -> CASE case_or AS ID COLON . suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or AS ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE AS ID YIELD
##
## Ends in an error in state: 492.
##
## case -> CASE case_or AS ID . COLON suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or AS ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE AS YIELD
##
## Ends in an error in state: 491.
##
## case -> CASE case_or AS . ID COLON suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE COLON BREAK NL YIELD
##
## Ends in an error in state: 497.
##
## case_suite -> case . [ DEDENT ]
## case_suite -> case . case_suite [ DEDENT ]
##
## The known suffix of the stack is as follows:
## case
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE COLON XOREQ
##
## Ends in an error in state: 489.
##
## case -> CASE case_or COLON . suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE IF TRUE COLON XOREQ
##
## Ends in an error in state: 487.
##
## case -> CASE case_or IF bool_expr COLON . suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or IF bool_expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE IF TRUE XOREQ
##
## Ends in an error in state: 486.
##
## case -> CASE case_or IF bool_expr . COLON suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or IF bool_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE IF YIELD
##
## Ends in an error in state: 485.
##
## case -> CASE case_or IF . bool_expr COLON suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE OR YIELD
##
## Ends in an error in state: 467.
##
## separated_nonempty_list(OR,case_type) -> case_type OR . separated_nonempty_list(OR,case_type) [ RS RP IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## case_type OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE RS
##
## Ends in an error in state: 484.
##
## case -> CASE case_or . COLON suite [ DEDENT CASE ]
## case -> CASE case_or . IF bool_expr COLON suite [ DEDENT CASE ]
## case -> CASE case_or . AS ID COLON suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE case_or
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 466, spurious reduction of production separated_nonempty_list(OR,case_type) -> case_type 
## In state 463, spurious reduction of production case_or -> separated_nonempty_list(OR,case_type) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE TRUE YIELD
##
## Ends in an error in state: 466.
##
## separated_nonempty_list(OR,case_type) -> case_type . [ RS RP IF COMMA COLON AS ]
## separated_nonempty_list(OR,case_type) -> case_type . OR separated_nonempty_list(OR,case_type) [ RS RP IF COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## case_type
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT CASE YIELD
##
## Ends in an error in state: 451.
##
## case -> CASE . case_or COLON suite [ DEDENT CASE ]
## case -> CASE . case_or IF bool_expr COLON suite [ DEDENT CASE ]
## case -> CASE . case_or AS ID COLON suite [ DEDENT CASE ]
##
## The known suffix of the stack is as follows:
## CASE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL INDENT YIELD
##
## Ends in an error in state: 450.
##
## single_statement -> MATCH expr COLON NL INDENT . case_suite DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## MATCH expr COLON NL INDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON NL YIELD
##
## Ends in an error in state: 449.
##
## single_statement -> MATCH expr COLON NL . INDENT case_suite DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## MATCH expr COLON NL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE COLON YIELD
##
## Ends in an error in state: 448.
##
## single_statement -> MATCH expr COLON . NL INDENT case_suite DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## MATCH expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH TRUE XOREQ
##
## Ends in an error in state: 447.
##
## single_statement -> MATCH expr . COLON NL INDENT case_suite DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## MATCH expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MATCH YIELD
##
## Ends in an error in state: 446.
##
## single_statement -> MATCH . expr COLON NL INDENT case_suite DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## MATCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MUL LP TRUE XOREQ
##
## Ends in an error in state: 238.
##
## tuple -> LP expr . COMMA RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA expr RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA expr COMMA option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP expr . COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MUL LP YIELD
##
## Ends in an error in state: 16.
##
## tuple -> LP . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA expr RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA expr COMMA option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## tuple -> LP . expr COMMA expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: MUL YIELD
##
## Ends in an error in state: 15.
##
## atom -> MUL . ID [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## atom -> MUL . tuple [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## MUL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: NL DEDENT
##
## Ends in an error in state: 675.
##
## program -> nonempty_list(statement) . EOF [ # ]
##
## The known suffix of the stack is as follows:
## nonempty_list(statement)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 650, spurious reduction of production nonempty_list(statement) -> statement 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: NL XOREQ
##
## Ends in an error in state: 650.
##
## nonempty_list(statement) -> statement . [ EOF DEDENT ]
## nonempty_list(statement) -> statement . nonempty_list(statement) [ EOF DEDENT ]
##
## The known suffix of the stack is as follows:
## statement
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: NOT YIELD
##
## Ends in an error in state: 13.
##
## cond_expr -> NOT . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## NOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PASS YIELD
##
## Ends in an error in state: 651.
##
## statement -> small_statement . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## statement -> small_statement . SEMICOLON option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## statement -> small_statement . SEMICOLON reverse_separated_nonempty_llist(SEMICOLON,small_statement) option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PREFETCH TRUE COMMA TRUE XOREQ
##
## Ends in an error in state: 280.
##
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ SEMICOLON NL COMMA ]
## small_statement -> PREFETCH expr COMMA reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## PREFETCH expr COMMA reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 210, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PREFETCH TRUE COMMA YIELD
##
## Ends in an error in state: 279.
##
## small_statement -> PREFETCH expr COMMA . option(COMMA) [ SEMICOLON NL ]
## small_statement -> PREFETCH expr COMMA . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## PREFETCH expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PREFETCH TRUE XOREQ
##
## Ends in an error in state: 278.
##
## small_statement -> PREFETCH expr . [ SEMICOLON NL ]
## small_statement -> PREFETCH expr . COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> PREFETCH expr . COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## PREFETCH expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PREFETCH YIELD
##
## Ends in an error in state: 277.
##
## small_statement -> PREFETCH . expr [ SEMICOLON NL ]
## small_statement -> PREFETCH . expr COMMA option(COMMA) [ SEMICOLON NL ]
## small_statement -> PREFETCH . expr COMMA reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## PREFETCH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PRINT TRUE COMMA YIELD
##
## Ends in an error in state: 204.
##
## option(COMMA) -> COMMA . [ SEMICOLON RS RP RB NL ]
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) COMMA . expr [ SEMICOLON RS RP RB NL COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,expr) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PRINT TRUE XOREQ
##
## Ends in an error in state: 274.
##
## print_statement -> PRINT reverse_separated_nonempty_llist(COMMA,expr) . option(COMMA) [ SEMICOLON NL ]
## reverse_separated_nonempty_llist(COMMA,expr) -> reverse_separated_nonempty_llist(COMMA,expr) . COMMA expr [ SEMICOLON NL COMMA ]
##
## The known suffix of the stack is as follows:
## PRINT reverse_separated_nonempty_llist(COMMA,expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 210, spurious reduction of production reverse_separated_nonempty_llist(COMMA,expr) -> expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PRINT YIELD
##
## Ends in an error in state: 273.
##
## print_statement -> PRINT . option(COMMA) [ SEMICOLON NL ]
## print_statement -> PRINT . reverse_separated_nonempty_llist(COMMA,expr) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## PRINT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PTR LP TRUE XOREQ
##
## Ends in an error in state: 242.
##
## expr -> PTR LP expr . RP [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## PTR LP expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PTR LP YIELD
##
## Ends in an error in state: 12.
##
## expr -> PTR LP . expr RP [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## PTR LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PTR YIELD
##
## Ends in an error in state: 11.
##
## expr -> PTR . LP expr RP [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## PTR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP COMMA YIELD
##
## Ends in an error in state: 440.
##
## pyfunc -> PYDEF ID LP option(COMMA) . RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP ID EQ TRUE XOREQ
##
## Ends in an error in state: 431.
##
## pyfunc -> PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) . option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## reverse_separated_nonempty_llist(COMMA,typed_param) -> reverse_separated_nonempty_llist(COMMA,typed_param) . COMMA typed_param [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 396, spurious reduction of production default_val -> EQ expr 
## In state 398, spurious reduction of production option(default_val) -> default_val 
## In state 397, spurious reduction of production typed_param -> ID option(param_type) option(default_val) 
## In state 399, spurious reduction of production reverse_separated_nonempty_llist(COMMA,typed_param) -> typed_param 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP ID RP COLON XOREQ
##
## Ends in an error in state: 437.
##
## pyfunc -> PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP ID RP OF TRUE AS
##
## Ends in an error in state: 436.
##
## pyfunc -> PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 435, spurious reduction of production func_ret_type -> OF expr 
## In state 439, spurious reduction of production option(func_ret_type) -> func_ret_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP ID RP YIELD
##
## Ends in an error in state: 433.
##
## pyfunc -> PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP . option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP RP COLON XOREQ
##
## Ends in an error in state: 443.
##
## pyfunc -> PYDEF ID LP option(COMMA) RP option(func_ret_type) COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP option(COMMA) RP option(func_ret_type) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP RP OF FALSE AS
##
## Ends in an error in state: 442.
##
## pyfunc -> PYDEF ID LP option(COMMA) RP option(func_ret_type) . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP option(COMMA) RP option(func_ret_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 435, spurious reduction of production func_ret_type -> OF expr 
## In state 439, spurious reduction of production option(func_ret_type) -> func_ret_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP RP OF YIELD
##
## Ends in an error in state: 434.
##
## func_ret_type -> OF . expr [ NL COMMA COLON AS ]
##
## The known suffix of the stack is as follows:
## OF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP RP YIELD
##
## Ends in an error in state: 441.
##
## pyfunc -> PYDEF ID LP option(COMMA) RP . option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP option(COMMA) RP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID LP YIELD
##
## Ends in an error in state: 430.
##
## pyfunc -> PYDEF ID LP . option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## pyfunc -> PYDEF ID LP . reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF ID YIELD
##
## Ends in an error in state: 429.
##
## pyfunc -> PYDEF ID . LP option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## pyfunc -> PYDEF ID . LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: PYDEF YIELD
##
## Ends in an error in state: 428.
##
## pyfunc -> PYDEF . ID LP option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## pyfunc -> PYDEF . ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP option(func_ret_type) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## PYDEF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: RETURN YIELD
##
## Ends in an error in state: 271.
##
## small_single_statement -> RETURN . loption(separated_nonempty_list(COMMA,expr)) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## RETURN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: SEQ YIELD
##
## Ends in an error in state: 9.
##
## nonempty_list(SEQ) -> SEQ . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## nonempty_list(SEQ) -> SEQ . nonempty_list(SEQ) [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## SEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: STRING YIELD
##
## Ends in an error in state: 7.
##
## nonempty_list(STRING) -> STRING . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## nonempty_list(STRING) -> STRING . nonempty_list(STRING) [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## STRING
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: SUB TRUE YIELD
##
## Ends in an error in state: 52.
##
## arith_expr -> nonempty_list(SUB) arith_term . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP reverse_separated_nonempty_llist(COMMA,call_term) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . DOT ID [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## nonempty_list(SUB) arith_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: SUB YIELD
##
## Ends in an error in state: 5.
##
## nonempty_list(SUB) -> SUB . [ TRUE STRING SEQ NONE MUL LS LP LB KMER INT_S ID FSTRING FLOAT_S FALSE ]
## nonempty_list(SUB) -> SUB . nonempty_list(SUB) [ TRUE STRING SEQ NONE MUL LS LP LB KMER INT_S ID FSTRING FLOAT_S FALSE ]
##
## The known suffix of the stack is as follows:
## SUB
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: THROW YIELD
##
## Ends in an error in state: 269.
##
## small_single_statement -> THROW . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## THROW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE ADD YIELD
##
## Ends in an error in state: 113.
##
## arith_expr -> arith_expr ADD . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr ADD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE AND YIELD
##
## Ends in an error in state: 71.
##
## bool_and_expr -> cond_expr AND . bool_and_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## cond_expr AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE ANDEQ YIELD
##
## Ends in an error in state: 379.
##
## assign_statement -> expr ANDEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr ANDEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE AT YIELD
##
## Ends in an error in state: 81.
##
## arith_expr -> arith_expr AT . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr AT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE B_AND YIELD
##
## Ends in an error in state: 117.
##
## arith_expr -> arith_expr B_AND . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr B_AND
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE B_LSH YIELD
##
## Ends in an error in state: 115.
##
## arith_expr -> arith_expr B_LSH . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr B_LSH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE B_OR YIELD
##
## Ends in an error in state: 119.
##
## arith_expr -> arith_expr B_OR . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr B_OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE B_RSH YIELD
##
## Ends in an error in state: 111.
##
## arith_expr -> arith_expr B_RSH . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr B_RSH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE B_XOR YIELD
##
## Ends in an error in state: 109.
##
## arith_expr -> arith_expr B_XOR . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr B_XOR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE COMMA YIELD
##
## Ends in an error in state: 251.
##
## separated_nonempty_list(COMMA,expr) -> expr COMMA . separated_nonempty_list(COMMA,expr) [ SEMICOLON NL EQ ]
##
## The known suffix of the stack is as follows:
## expr COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE DIV YIELD
##
## Ends in an error in state: 87.
##
## arith_expr -> arith_expr DIV . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr DIV
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE DIVEQ YIELD
##
## Ends in an error in state: 377.
##
## assign_statement -> expr DIVEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr DIVEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE DOT YIELD
##
## Ends in an error in state: 67.
##
## arith_term -> arith_term DOT . ID [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term DOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE EEQ YIELD
##
## Ends in an error in state: 107.
##
## cond_expr -> arith_expr EEQ . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr EEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE ELSE
##
## Ends in an error in state: 42.
##
## expr -> pipe_expr . [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
## expr -> pipe_expr . IF pipe_expr ELSE expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## pipe_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE EQ TRUE EQ YIELD
##
## Ends in an error in state: 354.
##
## separated_nonempty_list(EQ,expr_list) -> expr_list EQ . separated_nonempty_list(EQ,expr_list) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr_list EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE EQ YIELD
##
## Ends in an error in state: 351.
##
## assign_statement -> expr_list EQ . separated_nonempty_list(EQ,expr_list) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr_list EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE FDIV YIELD
##
## Ends in an error in state: 85.
##
## arith_expr -> arith_expr FDIV . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr FDIV
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE FDIVEQ YIELD
##
## Ends in an error in state: 375.
##
## assign_statement -> expr FDIVEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr FDIVEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE GEQ YIELD
##
## Ends in an error in state: 105.
##
## cond_expr -> arith_expr GEQ . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr GEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE GREAT YIELD
##
## Ends in an error in state: 103.
##
## cond_expr -> arith_expr GREAT . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr GREAT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE IF TRUE ELSE YIELD
##
## Ends in an error in state: 45.
##
## expr -> pipe_expr IF pipe_expr ELSE . expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## pipe_expr IF pipe_expr ELSE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE IF TRUE XOREQ
##
## Ends in an error in state: 44.
##
## expr -> pipe_expr IF pipe_expr . ELSE expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## pipe_expr IF pipe_expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE IF YIELD
##
## Ends in an error in state: 43.
##
## expr -> pipe_expr IF . pipe_expr ELSE expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## pipe_expr IF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE IN YIELD
##
## Ends in an error in state: 101.
##
## cond_expr -> arith_expr IN . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr IN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE IS YIELD
##
## Ends in an error in state: 99.
##
## cond_expr -> arith_expr IS . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr IS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE ISNOT YIELD
##
## Ends in an error in state: 97.
##
## cond_expr -> arith_expr ISNOT . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr ISNOT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LEQ YIELD
##
## Ends in an error in state: 95.
##
## cond_expr -> arith_expr LEQ . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr LEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LESS YIELD
##
## Ends in an error in state: 93.
##
## cond_expr -> arith_expr LESS . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr LESS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP COMMA YIELD
##
## Ends in an error in state: 139.
##
## arith_term -> arith_term LP option(COMMA) . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LP option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP ELLIPSIS YIELD
##
## Ends in an error in state: 133.
##
## arith_term -> arith_term LP reverse_separated_nonempty_llist(COMMA,call_term) . option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,call_term) -> reverse_separated_nonempty_llist(COMMA,call_term) . COMMA call_term [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## arith_term LP reverse_separated_nonempty_llist(COMMA,call_term)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP ID EQ YIELD
##
## Ends in an error in state: 63.
##
## call_term -> ID EQ . expr [ RP COMMA ]
## call_term -> ID EQ . ELLIPSIS [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP ID YIELD
##
## Ends in an error in state: 62.
##
## atom -> ID . [ SUB SPIPE RP PPIPE POW PIPE OR NOTIN NEQ MUL MOD LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIV EEQ DOT DIV COMMA B_XOR B_RSH B_OR B_LSH B_AND AT AND ADD ]
## call_term -> ID . EQ expr [ RP COMMA ]
## call_term -> ID . EQ ELLIPSIS [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP TRUE COMMA YIELD
##
## Ends in an error in state: 134.
##
## option(COMMA) -> COMMA . [ RP ]
## reverse_separated_nonempty_llist(COMMA,call_term) -> reverse_separated_nonempty_llist(COMMA,call_term) COMMA . call_term [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,call_term) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP TRUE FOR ID IN FALSE RS
##
## Ends in an error in state: 168.
##
## arith_term -> arith_term LP expr comprehension . RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LP expr comprehension
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 145, spurious reduction of production list(comprehension_if) -> 
## In state 148, spurious reduction of production option(comprehension) -> 
## In state 149, spurious reduction of production comprehension -> FOR ID IN pipe_expr list(comprehension_if) option(comprehension) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP TRUE XOREQ
##
## Ends in an error in state: 141.
##
## arith_term -> arith_term LP expr . comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## call_term -> expr . [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## arith_term LP expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LP YIELD
##
## Ends in an error in state: 61.
##
## arith_term -> arith_term LP . option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LP . reverse_separated_nonempty_llist(COMMA,call_term) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LP . expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS COLON COLON FALSE XOREQ
##
## Ends in an error in state: 172.
##
## arith_term -> arith_term LS index_term . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term . COMMA RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term . COMMA index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term . COMMA index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term . COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LS index_term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 171, spurious reduction of production option(expr) -> expr 
## In state 58, spurious reduction of production index_term -> option(expr) COLON option(expr) COLON option(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS COLON COLON YIELD
##
## Ends in an error in state: 57.
##
## index_term -> option(expr) COLON option(expr) COLON . option(expr) [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## option(expr) COLON option(expr) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS COLON TRUE AS
##
## Ends in an error in state: 56.
##
## index_term -> option(expr) COLON option(expr) . [ RS COMMA ]
## index_term -> option(expr) COLON option(expr) . COLON option(expr) [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## option(expr) COLON option(expr)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 171, spurious reduction of production option(expr) -> expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS COLON YIELD
##
## Ends in an error in state: 55.
##
## index_term -> option(expr) COLON . option(expr) [ RS COMMA ]
## index_term -> option(expr) COLON . option(expr) COLON option(expr) [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## option(expr) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE COMMA COLON COLON FALSE XOREQ
##
## Ends in an error in state: 176.
##
## arith_term -> arith_term LS index_term COMMA index_term . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term COMMA index_term . COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term COMMA index_term . COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LS index_term COMMA index_term
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 171, spurious reduction of production option(expr) -> expr 
## In state 58, spurious reduction of production index_term -> option(expr) COLON option(expr) COLON option(expr) 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE COMMA TRUE COMMA COLON COLON FALSE XOREQ
##
## Ends in an error in state: 179.
##
## arith_term -> arith_term LS index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) . option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## reverse_separated_nonempty_llist(COMMA,index_term) -> reverse_separated_nonempty_llist(COMMA,index_term) . COMMA index_term [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## arith_term LS index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 171, spurious reduction of production option(expr) -> expr 
## In state 58, spurious reduction of production index_term -> option(expr) COLON option(expr) COLON option(expr) 
## In state 187, spurious reduction of production reverse_separated_nonempty_llist(COMMA,index_term) -> index_term 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE COMMA TRUE COMMA COMMA YIELD
##
## Ends in an error in state: 185.
##
## arith_term -> arith_term LS index_term COMMA index_term COMMA option(COMMA) . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LS index_term COMMA index_term COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE COMMA TRUE COMMA TRUE COMMA YIELD
##
## Ends in an error in state: 180.
##
## option(COMMA) -> COMMA . [ RS ]
## reverse_separated_nonempty_llist(COMMA,index_term) -> reverse_separated_nonempty_llist(COMMA,index_term) COMMA . index_term [ RS COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,index_term) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE COMMA TRUE COMMA YIELD
##
## Ends in an error in state: 178.
##
## arith_term -> arith_term LS index_term COMMA index_term COMMA . option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term COMMA index_term COMMA . reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LS index_term COMMA index_term COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE COMMA YIELD
##
## Ends in an error in state: 174.
##
## arith_term -> arith_term LS index_term COMMA . RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term COMMA . index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term COMMA . index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS index_term COMMA . index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LS index_term COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS TRUE XOREQ
##
## Ends in an error in state: 182.
##
## index_term -> expr . [ RS COMMA ]
## option(expr) -> expr . [ COLON ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LS YIELD
##
## Ends in an error in state: 53.
##
## arith_term -> arith_term LS . index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS . index_term COMMA RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS . index_term COMMA index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS . index_term COMMA index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term LS . index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term LS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE LSHEQ YIELD
##
## Ends in an error in state: 373.
##
## assign_statement -> expr LSHEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr LSHEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE MINEQ YIELD
##
## Ends in an error in state: 371.
##
## assign_statement -> expr MINEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr MINEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE MOD YIELD
##
## Ends in an error in state: 83.
##
## arith_expr -> arith_expr MOD . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr MOD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE MODEQ YIELD
##
## Ends in an error in state: 369.
##
## assign_statement -> expr MODEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr MODEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE MUL YIELD
##
## Ends in an error in state: 79.
##
## arith_expr -> arith_expr MUL . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr MUL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE MULEQ YIELD
##
## Ends in an error in state: 367.
##
## assign_statement -> expr MULEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr MULEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE NEQ YIELD
##
## Ends in an error in state: 91.
##
## cond_expr -> arith_expr NEQ . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr NEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE NOTIN YIELD
##
## Ends in an error in state: 89.
##
## cond_expr -> arith_expr NOTIN . cond_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ OR NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ AND ]
##
## The known suffix of the stack is as follows:
## arith_expr NOTIN
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE OR YIELD
##
## Ends in an error in state: 125.
##
## bool_expr -> bool_and_expr OR . bool_expr [ XOREQ SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ PLUSEQ PIPE OREQ NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## bool_and_expr OR
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE OREQ YIELD
##
## Ends in an error in state: 365.
##
## assign_statement -> expr OREQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr OREQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE PIPE YIELD
##
## Ends in an error in state: 129.
##
## pipe_expr -> bool_expr PIPE . pipe_expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## bool_expr PIPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE PLUSEQ YIELD
##
## Ends in an error in state: 363.
##
## assign_statement -> expr PLUSEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr PLUSEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE POW YIELD
##
## Ends in an error in state: 77.
##
## arith_expr -> arith_expr POW . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr POW
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE POWEQ YIELD
##
## Ends in an error in state: 361.
##
## assign_statement -> expr POWEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr POWEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE PPIPE YIELD
##
## Ends in an error in state: 127.
##
## pipe_expr -> bool_expr PPIPE . pipe_expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## bool_expr PPIPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE RS
##
## Ends in an error in state: 356.
##
## assign_statement -> expr . PLUSEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . MINEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . MULEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . DIVEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . MODEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . POWEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . FDIVEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . LSHEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . RSHEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . ANDEQ expr [ SEMICOLON NL ]
## assign_statement -> expr . OREQ expr [ SEMICOLON NL ]
## assign_statement -> expr . XOREQ expr [ SEMICOLON NL ]
## separated_nonempty_list(COMMA,expr) -> expr . [ SEMICOLON NL EQ ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ SEMICOLON NL EQ ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE RSHEQ YIELD
##
## Ends in an error in state: 359.
##
## assign_statement -> expr RSHEQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr RSHEQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE SPIPE YIELD
##
## Ends in an error in state: 122.
##
## pipe_expr -> bool_expr SPIPE . pipe_expr [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ IF FOR FDIVEQ EQ ELSE DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## bool_expr SPIPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE SUB YIELD
##
## Ends in an error in state: 75.
##
## arith_expr -> arith_expr SUB . arith_expr [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_expr SUB
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE XOREQ YIELD
##
## Ends in an error in state: 357.
##
## assign_statement -> expr XOREQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## expr XOREQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRUE YIELD
##
## Ends in an error in state: 73.
##
## arith_expr -> arith_term . [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP reverse_separated_nonempty_llist(COMMA,call_term) option(COMMA) RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LP expr comprehension RP [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . LS index_term COMMA index_term COMMA reverse_separated_nonempty_llist(COMMA,index_term) option(COMMA) RS [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
## arith_term -> arith_term . DOT ID [ XOREQ SUB SPIPE SEMICOLON RSHEQ RS RP RB PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FOR FDIVEQ FDIV EQ ELSE EEQ DOT DIVEQ DIV COMMA COLON B_XOR B_RSH B_OR B_LSH B_AND AT AS ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## arith_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON NL INDENT NL EOF
##
## Ends in an error in state: 666.
##
## suite -> NL INDENT nonempty_list(statement) . DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## NL INDENT nonempty_list(statement)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 650, spurious reduction of production nonempty_list(statement) -> statement 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON NL INDENT XOREQ
##
## Ends in an error in state: 285.
##
## suite -> NL INDENT . nonempty_list(statement) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## NL INDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON NL YIELD
##
## Ends in an error in state: 284.
##
## suite -> NL . INDENT nonempty_list(statement) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## NL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON PASS YIELD
##
## Ends in an error in state: 339.
##
## suite -> small_statement . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
## suite -> small_statement . SEMICOLON option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
## suite -> small_statement . SEMICOLON reverse_separated_nonempty_llist(SEMICOLON,small_statement) option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON XOREQ
##
## Ends in an error in state: 408.
##
## try_statement -> TRY COLON . suite list(catch) option(finally) [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## TRY COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT COLON BREAK NL XOREQ
##
## Ends in an error in state: 426.
##
## list(catch) -> catch . list(catch) [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## catch
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT COLON XOREQ
##
## Ends in an error in state: 411.
##
## catch -> EXCEPT COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT TRUE AS ID COLON XOREQ
##
## Ends in an error in state: 418.
##
## catch -> EXCEPT expr AS ID COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr AS ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT TRUE AS ID YIELD
##
## Ends in an error in state: 417.
##
## catch -> EXCEPT expr AS ID . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr AS ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT TRUE AS YIELD
##
## Ends in an error in state: 416.
##
## catch -> EXCEPT expr AS . ID COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT TRUE COLON XOREQ
##
## Ends in an error in state: 414.
##
## catch -> EXCEPT expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT TRUE XOREQ
##
## Ends in an error in state: 413.
##
## catch -> EXCEPT expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## catch -> EXCEPT expr . AS ID COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL EXCEPT YIELD
##
## Ends in an error in state: 410.
##
## catch -> EXCEPT . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## catch -> EXCEPT . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## catch -> EXCEPT . expr AS ID COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## EXCEPT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL FINALLY COLON XOREQ
##
## Ends in an error in state: 422.
##
## finally -> FINALLY COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FINALLY COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL FINALLY YIELD
##
## Ends in an error in state: 421.
##
## finally -> FINALLY . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## FINALLY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD NL XOREQ
##
## Ends in an error in state: 409.
##
## try_statement -> TRY COLON suite . list(catch) option(finally) [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## TRY COLON suite
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD SEMICOLON PASS YIELD
##
## Ends in an error in state: 345.
##
## reverse_separated_nonempty_llist(SEMICOLON,small_statement) -> reverse_separated_nonempty_llist(SEMICOLON,small_statement) . SEMICOLON small_statement [ SEMICOLON NL ]
## suite -> small_statement SEMICOLON reverse_separated_nonempty_llist(SEMICOLON,small_statement) . option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement SEMICOLON reverse_separated_nonempty_llist(SEMICOLON,small_statement)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD SEMICOLON SEMICOLON NEQ
##
## Ends in an error in state: 384.
##
## suite -> small_statement SEMICOLON option(SEMICOLON) . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement SEMICOLON option(SEMICOLON)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY COLON YIELD SEMICOLON XOREQ
##
## Ends in an error in state: 340.
##
## suite -> small_statement SEMICOLON . option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
## suite -> small_statement SEMICOLON . reverse_separated_nonempty_llist(SEMICOLON,small_statement) option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FINALLY FALSE EXTERN EXTEND EXCEPT EOF ELSE ELIF DEL DEF DEDENT CONTINUE CLASS CASE B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TRY YIELD
##
## Ends in an error in state: 407.
##
## try_statement -> TRY . COLON suite list(catch) option(finally) [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## TRY
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID EQ YIELD
##
## Ends in an error in state: 267.
##
## small_single_statement -> TYPE ID EQ . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## TYPE ID EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP COMMA YIELD
##
## Ends in an error in state: 405.
##
## type_head -> TYPE ID LP option(COMMA) . RP [ NL COLON ]
##
## The known suffix of the stack is as follows:
## TYPE ID LP option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP ID COLON TRUE XOREQ
##
## Ends in an error in state: 394.
##
## typed_param -> ID option(param_type) . option(default_val) [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## ID option(param_type)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 392, spurious reduction of production param_type -> COLON expr 
## In state 393, spurious reduction of production option(param_type) -> param_type 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP ID COLON YIELD
##
## Ends in an error in state: 391.
##
## param_type -> COLON . expr [ RP EQ COMMA ]
##
## The known suffix of the stack is as follows:
## COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP ID COMMA YIELD
##
## Ends in an error in state: 401.
##
## option(COMMA) -> COMMA . [ RP ]
## reverse_separated_nonempty_llist(COMMA,typed_param) -> reverse_separated_nonempty_llist(COMMA,typed_param) COMMA . typed_param [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,typed_param) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP ID EQ TRUE XOREQ
##
## Ends in an error in state: 400.
##
## reverse_separated_nonempty_llist(COMMA,typed_param) -> reverse_separated_nonempty_llist(COMMA,typed_param) . COMMA typed_param [ RP COMMA ]
## type_head -> TYPE ID LP reverse_separated_nonempty_llist(COMMA,typed_param) . option(COMMA) RP [ NL COLON ]
##
## The known suffix of the stack is as follows:
## TYPE ID LP reverse_separated_nonempty_llist(COMMA,typed_param)
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
## In state 396, spurious reduction of production default_val -> EQ expr 
## In state 398, spurious reduction of production option(default_val) -> default_val 
## In state 397, spurious reduction of production typed_param -> ID option(param_type) option(default_val) 
## In state 399, spurious reduction of production reverse_separated_nonempty_llist(COMMA,typed_param) -> typed_param 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP ID EQ YIELD
##
## Ends in an error in state: 395.
##
## default_val -> EQ . expr [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## EQ
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP ID YIELD
##
## Ends in an error in state: 390.
##
## typed_param -> ID . option(param_type) option(default_val) [ RP COMMA ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP RP COLON NL INDENT YIELD
##
## Ends in an error in state: 645.
##
## typ -> type_head COLON NL INDENT . nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## type_head COLON NL INDENT
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP RP COLON NL YIELD
##
## Ends in an error in state: 644.
##
## typ -> type_head COLON NL . INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## type_head COLON NL
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP RP COLON YIELD
##
## Ends in an error in state: 643.
##
## typ -> type_head COLON . NL INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## type_head COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP RP YIELD
##
## Ends in an error in state: 641.
##
## typ -> type_head . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## typ -> type_head . COLON NL INDENT nonempty_list(class_member) DEDENT [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## type_head
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID LP YIELD
##
## Ends in an error in state: 389.
##
## type_head -> TYPE ID LP . option(COMMA) RP [ NL COLON ]
## type_head -> TYPE ID LP . reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP [ NL COLON ]
##
## The known suffix of the stack is as follows:
## TYPE ID LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE ID YIELD
##
## Ends in an error in state: 388.
##
## small_single_statement -> TYPE ID . EQ expr [ SEMICOLON NL ]
## type_head -> TYPE ID . LP option(COMMA) RP [ NL COLON ]
## type_head -> TYPE ID . LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP [ NL COLON ]
##
## The known suffix of the stack is as follows:
## TYPE ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPE YIELD
##
## Ends in an error in state: 387.
##
## small_single_statement -> TYPE . ID EQ expr [ SEMICOLON NL ]
## type_head -> TYPE . ID LP option(COMMA) RP [ NL COLON ]
## type_head -> TYPE . ID LP reverse_separated_nonempty_llist(COMMA,typed_param) option(COMMA) RP [ NL COLON ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPEOF LP TRUE XOREQ
##
## Ends in an error in state: 244.
##
## expr -> TYPEOF LP expr . RP [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## TYPEOF LP expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPEOF LP YIELD
##
## Ends in an error in state: 3.
##
## expr -> TYPEOF LP . expr RP [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## TYPEOF LP
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: TYPEOF YIELD
##
## Ends in an error in state: 2.
##
## expr -> TYPEOF . LP expr RP [ XOREQ SEMICOLON RSHEQ RS RP RB POWEQ PLUSEQ OREQ NL MULEQ MODEQ MINEQ LSHEQ FOR FDIVEQ EQ DIVEQ COMMA COLON AS ANDEQ ]
##
## The known suffix of the stack is as follows:
## TYPEOF
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WHILE TRUE COLON XOREQ
##
## Ends in an error in state: 288.
##
## single_statement -> WHILE expr COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WHILE expr COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WHILE TRUE XOREQ
##
## Ends in an error in state: 287.
##
## single_statement -> WHILE expr . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WHILE expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WHILE YIELD
##
## Ends in an error in state: 286.
##
## single_statement -> WHILE . expr COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WHILE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE AS ID YIELD
##
## Ends in an error in state: 254.
##
## with_statement -> WITH with_clause . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## with_statement -> WITH with_clause . COMMA option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## with_statement -> WITH with_clause . COMMA reverse_separated_nonempty_llist(COMMA,with_clause) option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE AS YIELD
##
## Ends in an error in state: 261.
##
## with_clause -> expr AS . ID [ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr AS
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COLON XOREQ
##
## Ends in an error in state: 672.
##
## with_statement -> WITH with_clause COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COMMA COLON XOREQ
##
## Ends in an error in state: 670.
##
## with_statement -> WITH with_clause COMMA option(COMMA) COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause COMMA option(COMMA) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COMMA COMMA CLASS
##
## Ends in an error in state: 669.
##
## with_statement -> WITH with_clause COMMA option(COMMA) . COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause COMMA option(COMMA)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COMMA TRUE AS ID YIELD
##
## Ends in an error in state: 257.
##
## reverse_separated_nonempty_llist(COMMA,with_clause) -> reverse_separated_nonempty_llist(COMMA,with_clause) . COMMA with_clause [ COMMA COLON ]
## with_statement -> WITH with_clause COMMA reverse_separated_nonempty_llist(COMMA,with_clause) . option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause COMMA reverse_separated_nonempty_llist(COMMA,with_clause)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COMMA TRUE COLON XOREQ
##
## Ends in an error in state: 264.
##
## with_statement -> WITH with_clause COMMA reverse_separated_nonempty_llist(COMMA,with_clause) option(COMMA) COLON . suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause COMMA reverse_separated_nonempty_llist(COMMA,with_clause) option(COMMA) COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COMMA TRUE COMMA YIELD
##
## Ends in an error in state: 258.
##
## option(COMMA) -> COMMA . [ COLON ]
## reverse_separated_nonempty_llist(COMMA,with_clause) -> reverse_separated_nonempty_llist(COMMA,with_clause) COMMA . with_clause [ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(COMMA,with_clause) COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE COMMA YIELD
##
## Ends in an error in state: 255.
##
## with_statement -> WITH with_clause COMMA . option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## with_statement -> WITH with_clause COMMA . reverse_separated_nonempty_llist(COMMA,with_clause) option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH with_clause COMMA
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH TRUE XOREQ
##
## Ends in an error in state: 260.
##
## with_clause -> expr . [ COMMA COLON ]
## with_clause -> expr . AS ID [ COMMA COLON ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: WITH YIELD
##
## Ends in an error in state: 253.
##
## with_statement -> WITH . with_clause COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## with_statement -> WITH . with_clause COMMA option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## with_statement -> WITH . with_clause COMMA reverse_separated_nonempty_llist(COMMA,with_clause) option(COMMA) COLON suite [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## WITH
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: XOREQ
##
## Ends in an error in state: 0.
##
## program' -> . program [ # ]
##
## The known suffix of the stack is as follows:
##
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD FROM YIELD
##
## Ends in an error in state: 246.
##
## small_single_statement -> YIELD FROM . expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## YIELD FROM
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON FROM ID YIELD
##
## Ends in an error in state: 316.
##
## dot_term -> dot_term . DOT ID [ IMPORT DOT ]
## import_statement -> FROM dot_term . IMPORT MUL [ SEMICOLON NL ]
## import_statement -> FROM dot_term . IMPORT import_term [ SEMICOLON NL ]
## import_statement -> FROM dot_term . IMPORT import_term COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM dot_term . IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM dot_term
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON FROM YIELD
##
## Ends in an error in state: 315.
##
## import_statement -> FROM . dot_term IMPORT MUL [ SEMICOLON NL ]
## import_statement -> FROM . dot_term IMPORT import_term [ SEMICOLON NL ]
## import_statement -> FROM . dot_term IMPORT import_term COMMA option(COMMA) [ SEMICOLON NL ]
## import_statement -> FROM . dot_term IMPORT import_term COMMA reverse_separated_nonempty_llist(COMMA,import_term) option(COMMA) [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## FROM
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON ID COLON TRUE XOREQ
##
## Ends in an error in state: 306.
##
## assign_statement -> ID COLON expr . EQ expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ID COLON expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON ID COLON YIELD
##
## Ends in an error in state: 305.
##
## assign_statement -> ID COLON . expr EQ expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## ID COLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON ID YIELD
##
## Ends in an error in state: 304.
##
## assign_statement -> ID . COLON expr EQ expr [ SEMICOLON NL ]
## atom -> ID . [ XOREQ SUB SPIPE SEMICOLON RSHEQ PPIPE POWEQ POW PLUSEQ PIPE OREQ OR NOTIN NL NEQ MULEQ MUL MODEQ MOD MINEQ LSHEQ LS LP LESS LEQ ISNOT IS IN IF GREAT GEQ FDIVEQ FDIV EQ EEQ DOT DIVEQ DIV COMMA B_XOR B_RSH B_OR B_LSH B_AND AT ANDEQ AND ADD ]
##
## The known suffix of the stack is as follows:
## ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON PASS YIELD
##
## Ends in an error in state: 653.
##
## reverse_separated_nonempty_llist(SEMICOLON,small_statement) -> reverse_separated_nonempty_llist(SEMICOLON,small_statement) . SEMICOLON small_statement [ SEMICOLON NL ]
## statement -> small_statement SEMICOLON reverse_separated_nonempty_llist(SEMICOLON,small_statement) . option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement SEMICOLON reverse_separated_nonempty_llist(SEMICOLON,small_statement)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON SEMICOLON NEQ
##
## Ends in an error in state: 656.
##
## statement -> small_statement SEMICOLON option(SEMICOLON) . NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement SEMICOLON option(SEMICOLON)
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON TYPE ID YIELD
##
## Ends in an error in state: 266.
##
## small_single_statement -> TYPE ID . EQ expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## TYPE ID
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON TYPE YIELD
##
## Ends in an error in state: 265.
##
## small_single_statement -> TYPE . ID EQ expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## TYPE
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON XOREQ
##
## Ends in an error in state: 652.
##
## statement -> small_statement SEMICOLON . option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
## statement -> small_statement SEMICOLON . reverse_separated_nonempty_llist(SEMICOLON,small_statement) option(SEMICOLON) NL [ YIELD WITH WHILE TYPEOF TYPE TRY TRUE THROW SUB STRING SEQ RETURN PYDEF PTR PRINT PREFETCH PASS NOT NONE NL MUL MATCH LS LP LB LAMBDA KMER INT_S IMPORT IF ID GLOBAL FSTRING FROM FOR FLOAT_S FALSE EXTERN EXTEND EOF DEL DEF DEDENT CONTINUE CLASS B_NOT BREAK AT ASSERT ADD ]
##
## The known suffix of the stack is as follows:
## small_statement SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD SEMICOLON YIELD SEMICOLON XOREQ
##
## Ends in an error in state: 346.
##
## option(SEMICOLON) -> SEMICOLON . [ NL ]
## reverse_separated_nonempty_llist(SEMICOLON,small_statement) -> reverse_separated_nonempty_llist(SEMICOLON,small_statement) SEMICOLON . small_statement [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## reverse_separated_nonempty_llist(SEMICOLON,small_statement) SEMICOLON
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD TRUE XOREQ
##
## Ends in an error in state: 250.
##
## separated_nonempty_list(COMMA,expr) -> expr . [ SEMICOLON NL EQ ]
## separated_nonempty_list(COMMA,expr) -> expr . COMMA separated_nonempty_list(COMMA,expr) [ SEMICOLON NL EQ ]
##
## The known suffix of the stack is as follows:
## expr
##
## WARNING: This example involves spurious reductions.
## This implies that, although the LR(1) items shown above provide an
## accurate view of the past (what has been recognized so far), they
## may provide an INCOMPLETE view of the future (what was expected next).
## In state 73, spurious reduction of production arith_expr -> arith_term 
## In state 74, spurious reduction of production cond_expr -> arith_expr 
## In state 70, spurious reduction of production bool_and_expr -> cond_expr 
## In state 124, spurious reduction of production bool_expr -> bool_and_expr 
## In state 121, spurious reduction of production pipe_expr -> bool_expr 
## In state 42, spurious reduction of production expr -> pipe_expr 
##

<YOUR SYNTAX ERROR MESSAGE HERE>

program: YIELD YIELD
##
## Ends in an error in state: 1.
##
## small_single_statement -> YIELD . loption(separated_nonempty_list(COMMA,expr)) [ SEMICOLON NL ]
## small_single_statement -> YIELD . FROM expr [ SEMICOLON NL ]
##
## The known suffix of the stack is as follows:
## YIELD
##

<YOUR SYNTAX ERROR MESSAGE HERE>

